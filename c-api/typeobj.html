
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>型オブジェクト &#8212; Python 2.7.14 ドキュメント</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.14',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7.14 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="循環参照ガベージコレクションをサポートする" href="gcsupport.html" />
    <link rel="prev" title="共通のオブジェクト構造体 (common object structure)" href="structures.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/c-api/typeobj.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="gcsupport.html" title="循環参照ガベージコレクションをサポートする"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="structures.html" title="共通のオブジェクト構造体 (common object structure)"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.14</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API リファレンスマニュアル</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="objimpl.html" accesskey="U">オブジェクト実装サポート (object implementation support)</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="type-objects">
<span id="type-structs"></span><h1>型オブジェクト<a class="headerlink" href="#type-objects" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>新スタイルの型を定義する構造体: <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></code></a> 構造体は、おそらく Python オブジェクトシステムの中で最も重要な構造体の1つでしょう。型オブジェクトは <code class="xref c c-func docutils literal"><span class="pre">PyObject_*()</span></code> 系や <code class="xref c c-func docutils literal"><span class="pre">PyType_*()</span></code> 系の関数で扱えますが、ほとんどの Python アプリケーションにとって、さして面白みのある機能を提供しません。型オブジェクトはオブジェクトがどのように振舞うかを決める基盤ですから、インタプリタ自体や新たな型を定義する拡張モジュールでは非常に重要な存在です。</p>
<p>型オブジェクトは標準の型 (standard type) に比べるとかなり大きな構造体です。各型オブジェクトは多くの値を保持しており、そのほとんどは C 関数へのポインタで、それぞれの関数はその型の機能の小さい部分を実装しています。この節では、型オブジェクトの各フィールドについて詳細を説明します。各フィールドは、構造体内で出現する順番に説明されています。</p>
<p>Typedefs: unaryfunc, binaryfunc, ternaryfunc, inquiry, coercion, intargfunc,
intintargfunc, intobjargproc, intintobjargproc, objobjargproc, destructor,
freefunc, printfunc, getattrfunc, getattrofunc, setattrfunc, setattrofunc,
cmpfunc, reprfunc, hashfunc</p>
<p><a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></code></a> の構造体定義は <code class="file docutils literal"><span class="pre">Include/object.h</span></code> で見つけられるはずです。参照の手間を省くために、ここでは定義を繰り返します:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_typeobject</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">tp_name</span><span class="p">;</span> <span class="cm">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span>
    <span class="kt">int</span> <span class="n">tp_basicsize</span><span class="p">,</span> <span class="n">tp_itemsize</span><span class="p">;</span> <span class="cm">/* For allocation */</span>

    <span class="cm">/* Methods to implement standard operations */</span>

    <span class="n">destructor</span> <span class="n">tp_dealloc</span><span class="p">;</span>
    <span class="n">printfunc</span> <span class="n">tp_print</span><span class="p">;</span>
    <span class="n">getattrfunc</span> <span class="n">tp_getattr</span><span class="p">;</span>
    <span class="n">setattrfunc</span> <span class="n">tp_setattr</span><span class="p">;</span>
    <span class="n">cmpfunc</span> <span class="n">tp_compare</span><span class="p">;</span>
    <span class="n">reprfunc</span> <span class="n">tp_repr</span><span class="p">;</span>

    <span class="cm">/* Method suites for standard classes */</span>

    <span class="n">PyNumberMethods</span> <span class="o">*</span><span class="n">tp_as_number</span><span class="p">;</span>
    <span class="n">PySequenceMethods</span> <span class="o">*</span><span class="n">tp_as_sequence</span><span class="p">;</span>
    <span class="n">PyMappingMethods</span> <span class="o">*</span><span class="n">tp_as_mapping</span><span class="p">;</span>

    <span class="cm">/* More standard operations (here for binary compatibility) */</span>

    <span class="n">hashfunc</span> <span class="n">tp_hash</span><span class="p">;</span>
    <span class="n">ternaryfunc</span> <span class="n">tp_call</span><span class="p">;</span>
    <span class="n">reprfunc</span> <span class="n">tp_str</span><span class="p">;</span>
    <span class="n">getattrofunc</span> <span class="n">tp_getattro</span><span class="p">;</span>
    <span class="n">setattrofunc</span> <span class="n">tp_setattro</span><span class="p">;</span>

    <span class="cm">/* Functions to access object as input/output buffer */</span>
    <span class="n">PyBufferProcs</span> <span class="o">*</span><span class="n">tp_as_buffer</span><span class="p">;</span>

    <span class="cm">/* Flags to define presence of optional/expanded features */</span>
    <span class="kt">long</span> <span class="n">tp_flags</span><span class="p">;</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">tp_doc</span><span class="p">;</span> <span class="cm">/* Documentation string */</span>

    <span class="cm">/* Assigned meaning in release 2.0 */</span>
    <span class="cm">/* call function for all accessible objects */</span>
    <span class="n">traverseproc</span> <span class="n">tp_traverse</span><span class="p">;</span>

    <span class="cm">/* delete references to contained objects */</span>
    <span class="n">inquiry</span> <span class="n">tp_clear</span><span class="p">;</span>

    <span class="cm">/* Assigned meaning in release 2.1 */</span>
    <span class="cm">/* rich comparisons */</span>
    <span class="n">richcmpfunc</span> <span class="n">tp_richcompare</span><span class="p">;</span>

    <span class="cm">/* weak reference enabler */</span>
    <span class="kt">long</span> <span class="n">tp_weaklistoffset</span><span class="p">;</span>

    <span class="cm">/* Added in release 2.2 */</span>
    <span class="cm">/* Iterators */</span>
    <span class="n">getiterfunc</span> <span class="n">tp_iter</span><span class="p">;</span>
    <span class="n">iternextfunc</span> <span class="n">tp_iternext</span><span class="p">;</span>

    <span class="cm">/* Attribute descriptor and subclassing stuff */</span>
    <span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="o">*</span><span class="n">tp_methods</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="o">*</span><span class="n">tp_members</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyGetSetDef</span> <span class="o">*</span><span class="n">tp_getset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">_typeobject</span> <span class="o">*</span><span class="n">tp_base</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_dict</span><span class="p">;</span>
    <span class="n">descrgetfunc</span> <span class="n">tp_descr_get</span><span class="p">;</span>
    <span class="n">descrsetfunc</span> <span class="n">tp_descr_set</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">tp_dictoffset</span><span class="p">;</span>
    <span class="n">initproc</span> <span class="n">tp_init</span><span class="p">;</span>
    <span class="n">allocfunc</span> <span class="n">tp_alloc</span><span class="p">;</span>
    <span class="n">newfunc</span> <span class="n">tp_new</span><span class="p">;</span>
    <span class="n">freefunc</span> <span class="n">tp_free</span><span class="p">;</span> <span class="cm">/* Low-level free-memory routine */</span>
    <span class="n">inquiry</span> <span class="n">tp_is_gc</span><span class="p">;</span> <span class="cm">/* For PyObject_IS_GC */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_bases</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_mro</span><span class="p">;</span> <span class="cm">/* method resolution order */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_cache</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_subclasses</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_weaklist</span><span class="p">;</span>

<span class="p">}</span> <span class="n">PyTypeObject</span><span class="p">;</span>
</pre></div>
</div>
<p>型オブジェクト構造体は <a class="reference internal" href="structures.html#c.PyVarObject" title="PyVarObject"><code class="xref c c-type docutils literal"><span class="pre">PyVarObject</span></code></a> 構造体を拡張したものです。 <code class="xref py py-attr docutils literal"><span class="pre">ob_size</span></code> フィールドは、(通常 class 文が呼び出す <code class="xref py py-func docutils literal"><span class="pre">type_new()</span></code> で生成される) 動的な型に使います。 <a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code class="xref c c-data docutils literal"><span class="pre">PyType_Type</span></code></a> (メタタイプ) は <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal"><span class="pre">tp_itemsize</span></code></a> を初期化するので注意してください。すなわち、 インスタンス (つまり型オブジェクト) には <code class="xref py py-attr docutils literal"><span class="pre">ob_size</span></code> フィールドが存在しなければ <em>なりません</em> 。</p>
<dl class="member">
<dt id="c.PyObject._ob_next">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject._ob_next</code><a class="headerlink" href="#c.PyObject._ob_next" title="この定義へのパーマリンク">¶</a></dt>
<dt id="c.PyObject._ob_prev">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject._ob_prev</code><a class="headerlink" href="#c.PyObject._ob_prev" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これらのフィールドはマクロ <code class="docutils literal"><span class="pre">Py_TRACE_REFS</span></code> が定義されている場合のみ存在します。 <code class="docutils literal"><span class="pre">PyObject_HEAD_INIT</span></code> マクロを使うと、フィールドを <em>NULL</em> に初期化します。静的にメモリ確保されているオブジェクトでは、これらのフィールドは常に <em>NULL</em> のままです。動的にメモリ確保されるオブジェクトの場合、これら二つのフィールドは、ヒープ上の <em>全ての</em> 存続中のオブジェクトからなる二重リンクリストでオブジェクトをリンクする際に使われます。このことは様々なデバッグ目的に利用できます; 現状では、環境変数 <span class="target" id="index-6"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDUMPREFS"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONDUMPREFS</span></code></a> が設定されているときに、プログラムの実行終了時点で存続しているオブジェクトを出力するのが唯一の用例です。</p>
<p>サブタイプはこのフィールドを継承しません。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyObject.ob_refcnt">
Py_ssize_t <code class="descname">PyObject.ob_refcnt</code><a class="headerlink" href="#c.PyObject.ob_refcnt" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>型オブジェクトの参照カウントで、 <code class="docutils literal"><span class="pre">PyObject_HEAD_INIT</span></code> はこの値を <code class="docutils literal"><span class="pre">1</span></code> に初期化します。静的にメモリ確保された型オブジェクトでは、型のインスタンス (<code class="xref py py-attr docutils literal"><span class="pre">ob_type</span></code> が該当する型を指しているオブジェクト) は参照をカウントする対象には <em>なりません</em> 。動的にメモリ確保される型オブジェクトの場合、インスタンスは参照カウントの対象に <em>なります</em> 。</p>
<p>サブタイプはこのフィールドを継承しません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.5 で変更: </span>このフィールドは以前は <code class="xref c c-type docutils literal"><span class="pre">int</span></code> でした。この変更により、 64bit システムを正しくサポートするには修正が必要になります。</p>
</div>
</dd></dl>

<dl class="member">
<dt id="c.PyObject.ob_type">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a>* <code class="descname">PyObject.ob_type</code><a class="headerlink" href="#c.PyObject.ob_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>型自体の型、別の言い方をするとメタタイプです。 <code class="docutils literal"><span class="pre">PyObject_HEAD_INIT</span></code> マクロで初期化され、通常は <code class="docutils literal"><span class="pre">&amp;PyType_Type</span></code> になります。しかし、(少なくとも) Windows で利用できる動的ロード可能な拡張モジュールでは、コンパイラは有効な初期化ではないと文句をつけます。そこで、ならわしとして、 <code class="docutils literal"><span class="pre">PyObject_HEAD_INIT</span></code> には <em>NULL</em> を渡して初期化しておき、他の操作を行う前にモジュールの初期化関数で明示的にこのフィールドを初期化することになっています。この操作は以下のように行います:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Foo_Type</span><span class="p">.</span><span class="n">ob_type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">;</span>
</pre></div>
</div>
<p>上の操作は、該当する型のいかなるインスタンス生成よりも前にしておかねばなりません。 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> は <code class="xref py py-attr docutils literal"><span class="pre">ob_type</span></code> が <em>NULL</em> かどうか調べ、 <em>NULL</em> の場合には初期化します: Python 2.2 では、 <code class="docutils literal"><span class="pre">&amp;PyType_Type</span></code> にセットします; in Python 2.2.1 およびそれ以降では基底クラスの <code class="xref py py-attr docutils literal"><span class="pre">ob_type</span></code> フィールドに初期化します。 <code class="xref py py-attr docutils literal"><span class="pre">ob_type</span></code> が非ゼロの場合、 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> はこのフィールドを変更しません。</p>
<p>Python 2.2 では、サブタイプはこのフィールドを継承しません。 2.2.1 と 2.3 以降では、サブタイプはこのフィールドを継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyVarObject.ob_size">
Py_ssize_t <code class="descname">PyVarObject.ob_size</code><a class="headerlink" href="#c.PyVarObject.ob_size" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>静的にメモリ確保されている型オブジェクトの場合、このフィールドはゼロに初期化されます。動的にメモリ確保されている型オブジェクトの場合、このフィールドは内部使用される特殊な意味を持ちます。</p>
<p>サブタイプはこのフィールドを継承しません。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_name">
char* <code class="descname">PyTypeObject.tp_name</code><a class="headerlink" href="#c.PyTypeObject.tp_name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>型の名前が入っている NUL 終端された文字列へのポインタです。モジュールのグローバル変数としてアクセスできる型の場合、この文字列は完全なモジュール名、ドット、そして型の名前と続く文字列になります; 組み込み型の場合、ただの型の名前です。モジュールがあるパッケージのサブモジュールの場合、完全なパッケージ名が完全なモジュール名の一部になっています。例えば、パッケージ <code class="xref py py-mod docutils literal"><span class="pre">P</span></code> 内のサブモジュール <code class="xref py py-mod docutils literal"><span class="pre">Q</span></code> に入っているモジュール <code class="xref py py-mod docutils literal"><span class="pre">M</span></code> 内で定義されている <code class="xref py py-class docutils literal"><span class="pre">T</span></code> は、 <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal"><span class="pre">tp_name</span></code></a> を <code class="docutils literal"><span class="pre">&quot;P.Q.M.T&quot;</span></code> に初期化します。</p>
<p>動的にメモリ確保される型オブジェクトの場合、このフィールドは単に型の名前になり、モジュール名は型の辞書内でキー <code class="docutils literal"><span class="pre">'__module__'</span></code> に対する値として明示的に保存されます。</p>
<p>静的にメモリ確保される型オブジェクトの場合、 <code class="xref py py-attr docutils literal"><span class="pre">tp_name</span></code> フィールドにはドットが含まれているはずです。最後のドットよりも前にある部分文字列全体は <code class="xref py py-attr docutils literal"><span class="pre">__module__</span></code> 属性として、またドットよりも後ろにある部分は <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a> 属性としてアクセスできます。</p>
<p>ドットが入っていない場合、 <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal"><span class="pre">tp_name</span></code></a> フィールドの内容全てが <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a> 属性になり、 <code class="xref py py-attr docutils literal"><span class="pre">__module__</span></code> 属性は (前述のように型の辞書内で明示的にセットしないかぎり) 未定義になります。このため、その型は pickle 化できないことになります。さらに、 pydoc が作成するモジュールドキュメントのリストにも載らなくなります。</p>
<p>サブタイプはこのフィールドを継承しません。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_basicsize">
Py_ssize_t <code class="descname">PyTypeObject.tp_basicsize</code><a class="headerlink" href="#c.PyTypeObject.tp_basicsize" title="この定義へのパーマリンク">¶</a></dt>
<dt id="c.PyTypeObject.tp_itemsize">
Py_ssize_t <code class="descname">PyTypeObject.tp_itemsize</code><a class="headerlink" href="#c.PyTypeObject.tp_itemsize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これらのフィールドは、型インスタンスのバイトサイズを計算できるようにします。</p>
<p>型には二つの種類があります: 固定長インスタンスの型は、 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal"><span class="pre">tp_itemsize</span></code></a> フィールドがゼロで、可変長インスタンスの方は <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal"><span class="pre">tp_itemsize</span></code></a> フィールドが非ゼロの値になります。固定長インスタンスの型の場合、全てのインスタンスは等しく <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal"><span class="pre">tp_basicsize</span></code></a> で与えられたサイズになります。</p>
<p>可変長インスタンスの型の場合、インスタンスには <code class="xref py py-attr docutils literal"><span class="pre">ob_size</span></code> フィールドがなくてはならず、インスタンスのサイズは N をオブジェクトの &quot;長さ&quot; として、 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal"><span class="pre">tp_basicsize</span></code></a> と N かける <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal"><span class="pre">tp_itemsize</span></code></a> の加算になります。N の値は通常、インスタンスの <code class="xref py py-attr docutils literal"><span class="pre">ob_size</span></code> フィールドに記憶されます。ただし例外がいくつかあります: 例えば、長整数では負の値を <code class="xref py py-attr docutils literal"><span class="pre">ob_size</span></code> に使って、インスタンスの表す値が負であることを示し、 N 自体は <code class="docutils literal"><span class="pre">abs(ob_size)</span></code> になります。また、 <code class="xref py py-attr docutils literal"><span class="pre">ob_size</span></code> フィールドがあるからといって、必ずしもインスタンスが可変長であることを意味しません (例えば、リスト型の構造体は固定長のインスタンスになるにもかかわらず、インスタンスにはちゃんと意味を持った <code class="xref py py-attr docutils literal"><span class="pre">ob_size</span></code> フィールドがあります)。</p>
<p>基本サイズには、 <a class="reference internal" href="structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code class="xref c c-macro docutils literal"><span class="pre">PyObject_HEAD</span></code></a> マクロまたは <a class="reference internal" href="structures.html#c.PyObject_VAR_HEAD" title="PyObject_VAR_HEAD"><code class="xref c c-macro docutils literal"><span class="pre">PyObject_VAR_HEAD</span></code></a> マクロ (インスタンス構造体を宣言するのに使ったどちらかのマクロ) で宣言されているフィールドが入っています。さらに、 <code class="xref py py-attr docutils literal"><span class="pre">_ob_prev</span></code> および <code class="xref py py-attr docutils literal"><span class="pre">_ob_next</span></code> フィールドがある場合、これらのフィールドもサイズに加算されます。従って、 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal"><span class="pre">tp_basicsize</span></code></a> の正しい初期化パラメタを得るには、インスタンスデータのレイアウトを宣言するのに使う構造体に対して <code class="docutils literal"><span class="pre">sizeof</span></code> 演算子を使うしかありません。基本サイズには、GC ヘッダサイズは入っていません (これは Python 2.2 からの新しい仕様です; 2.1 や 2.0 では、GC ヘッダサイズは <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal"><span class="pre">tp_basicsize</span></code></a> に入っていました)。</p>
<p>これらのフィールドはサブタイプに別々に継承されます。基底タイプが 0 でない <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal"><span class="pre">tp_itemsize</span></code></a> を持っていた場合、基底タイプの実装に依存しますが、一般的にはサブタイプで別の 0 で無い値を <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal"><span class="pre">tp_itemsize</span></code></a> に設定するのは安全ではありません。</p>
<p>アラインメントに関する注釈: 変数の各要素を配置する際に特定のアラインメントが必要となる場合、 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal"><span class="pre">tp_basicsize</span></code></a> の値に気をつけなければなりません。例: ある型が <code class="docutils literal"><span class="pre">double</span></code> の配列を実装しているとします。 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal"><span class="pre">tp_itemsize</span></code></a> は <code class="docutils literal"><span class="pre">sizeof(double)</span></code> です。 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal"><span class="pre">tp_basicsize</span></code></a> が <code class="docutils literal"><span class="pre">sizeof(double)</span></code> (ここではこれを <code class="docutils literal"><span class="pre">double</span></code> のアラインメントが要求するサイズと仮定する) の個数分のサイズになるようにするのはプログラマの責任です。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_dealloc">
destructor <code class="descname">PyTypeObject.tp_dealloc</code><a class="headerlink" href="#c.PyTypeObject.tp_dealloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インスタンスのデストラクタ関数へのポインタです。この関数は (単量子 <code class="docutils literal"><span class="pre">None</span></code> や <code class="docutils literal"><span class="pre">Ellipsis</span></code> の場合のように) インスタンスが決してメモリ解放されない型でない限り必ず定義しなければなりません。</p>
<p>デストラクタ関数は、参照カウントが新たにゼロになった際に <a class="reference internal" href="refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal"><span class="pre">Py_DECREF()</span></code></a> や <a class="reference internal" href="refcounting.html#c.Py_XDECREF" title="Py_XDECREF"><code class="xref c c-func docutils literal"><span class="pre">Py_XDECREF()</span></code></a> マクロから呼び出されます。呼び出された時点では、インスタンスはまだ存在しますが、インスタンスに対する参照は全くない状態です。デストラクタ関数はインスタンスが保持している全ての参照を解放し、インスタンスが確保している全てのメモリバッファを (バッファの確保時に使った関数に対応するメモリ解放関数を使って) 解放し、最後に (デストラクタ関数の最後の操作として) その型の <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal"><span class="pre">tp_free</span></code></a> 関数を呼び出します。ある型がサブタイプを作成できない (<a class="reference internal" href="#Py_TPFLAGS_BASETYPE" title="Py_TPFLAGS_BASETYPE"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_BASETYPE</span></code></a> フラグがセットされていない) 場合、 <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal"><span class="pre">tp_free</span></code></a> の代わりにオブジェクトのメモリ解放関数 (deallocator) を直接呼び出してもかまいません。オブジェクトのメモリ解放関数は、インスタンスのメモリ確保を行う際に使った関数に対応したものでなければなりません; インスタンスを <a class="reference internal" href="allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-func docutils literal"><span class="pre">PyObject_New()</span></code></a> や <code class="xref c c-func docutils literal"><span class="pre">PyObject_VarNew()</span></code> でメモリ確保した場合には、通常 <a class="reference internal" href="allocation.html#c.PyObject_Del" title="PyObject_Del"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Del()</span></code></a> を使い、 <a class="reference internal" href="gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_New()</span></code></a> や <a class="reference internal" href="gcsupport.html#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_NewVar()</span></code></a> で確保した場合には <a class="reference internal" href="gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_Del()</span></code></a> を使います。</p>
<p>サブタイプはこのフィールドを継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_print">
printfunc <code class="descname">PyTypeObject.tp_print</code><a class="headerlink" href="#c.PyTypeObject.tp_print" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドで、インスタンスの出力 (print) を行う関数を指すポインタです。</p>
<p>出力関数は、インスタンスが <em>実体のある (real)</em> ファイルに出力される場合にのみ呼び出されます; (<a class="reference internal" href="../library/stringio.html#StringIO.StringIO" title="StringIO.StringIO"><code class="xref py py-class docutils literal"><span class="pre">StringIO</span></code></a> インスタンスのような) 擬似ファイルに出力される場合には、インスタンスの <a class="reference internal" href="#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> や <a class="reference internal" href="#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code class="xref c c-member docutils literal"><span class="pre">tp_str</span></code></a> が指す関数が呼び出され、文字列への変換を行います。また、 <a class="reference internal" href="#c.PyTypeObject.tp_print" title="PyTypeObject.tp_print"><code class="xref c c-member docutils literal"><span class="pre">tp_print</span></code></a> が <em>NULL</em> の場合にもこれらの関数が呼び出されます。 <a class="reference internal" href="#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> や <a class="reference internal" href="#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code class="xref c c-member docutils literal"><span class="pre">tp_str</span></code></a> と異なる出力を生成するような <a class="reference internal" href="#c.PyTypeObject.tp_print" title="PyTypeObject.tp_print"><code class="xref c c-member docutils literal"><span class="pre">tp_print</span></code></a> は、決して型に実装してはなりません。</p>
<p>出力関数は <a class="reference internal" href="object.html#c.PyObject_Print" title="PyObject_Print"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Print()</span></code></a> と同じシグネチャ: <code class="docutils literal"><span class="pre">int</span> <span class="pre">tp_print(PyObject</span> <span class="pre">*self,</span> <span class="pre">FILE</span> <span class="pre">*file,</span> <span class="pre">int</span> <span class="pre">flags)</span></code> で呼び出されます。 <em>self</em> 引数は出力されるインスタンスを指します。 <em>file</em> 引数は出力先となる標準入出力 (stdio) ファイルです。 <em>flags</em> 引数はフラグビットを組み合わせた値です。現在定義されているフラグビットは <code class="xref py py-const docutils literal"><span class="pre">Py_PRINT_RAW</span></code> のみです。 <code class="xref py py-const docutils literal"><span class="pre">Py_PRINT_RAW</span></code> フラグビットがセットされていれば、インスタンスは <a class="reference internal" href="#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code class="xref c c-member docutils literal"><span class="pre">tp_str</span></code></a> と同じ書式で出力されます; <code class="xref py py-const docutils literal"><span class="pre">Py_PRINT_RAW</span></code> フラグビットがクリアされていれば、インスタンスは <a class="reference internal" href="#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> と同じ書式で出力されます。操作中にエラーが生じたときは、この関数は <code class="docutils literal"><span class="pre">-1</span></code> を返して例外状態をセットしなければなりません。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_print" title="PyTypeObject.tp_print"><code class="xref c c-member docutils literal"><span class="pre">tp_print</span></code></a> フィールドは撤廃されるかもしれません。いずれにせよ、 <a class="reference internal" href="#c.PyTypeObject.tp_print" title="PyTypeObject.tp_print"><code class="xref c c-member docutils literal"><span class="pre">tp_print</span></code></a> は定義せず、代わりに <a class="reference internal" href="#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> や <a class="reference internal" href="#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code class="xref c c-member docutils literal"><span class="pre">tp_str</span></code></a> に頼って出力を行うようにしてください。</p>
<p>サブタイプはこのフィールドを継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_getattr">
getattrfunc <code class="descname">PyTypeObject.tp_getattr</code><a class="headerlink" href="#c.PyTypeObject.tp_getattr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、 get-attribute-string を行う関数を指します。</p>
<p>このフィールドは非推奨です。このフィールドを定義するときは、 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal"><span class="pre">tp_getattro</span></code></a> 関数と同じように動作し、属性名は Python 文字列 オブジェクトではなく C 文字列で指定するような関数を指すようにしなければなりません。シグネチャは次の通りです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span> <span class="nf">tp_getattr</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">attr_name</span><span class="p">);</span>
</pre></div>
</div>
<p>このフィールドは <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal"><span class="pre">tp_getattro</span></code></a> と共にサブタイプに継承されます: すなわち、サブタイプの <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal"><span class="pre">tp_getattr</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal"><span class="pre">tp_getattro</span></code></a> が共に <em>NULL</em> の場合、サブタイプは基底タイプから <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal"><span class="pre">tp_getattr</span></code></a> と <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal"><span class="pre">tp_getattro</span></code></a> を両方とも継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_setattr">
setattrfunc <code class="descname">PyTypeObject.tp_setattr</code><a class="headerlink" href="#c.PyTypeObject.tp_setattr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのポインタで、属性の設定と削除を行う関数を指します。</p>
<p>このフィールドは非推奨です。このフィールドを定義するときは、 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal"><span class="pre">tp_setattro</span></code></a> 関数と同じように動作し、属性名は Python 文字列 オブジェクトではなく C 文字列で指定するような関数を指すようにしなければなりません。シグネチャは次の通りです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span> <span class="nf">tp_setattr</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
<p>引数 <em>v</em> に <em>NULL</em> を設定すると属性を削除します。このフィールドは <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal"><span class="pre">tp_setattro</span></code></a> と共にサブタイプに継承されます: すなわち、サブタイプの <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal"><span class="pre">tp_setattr</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal"><span class="pre">tp_setattro</span></code></a> が両方とも <em>NULL</em> のとき、サブタイプは基底タイプから <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal"><span class="pre">tp_setattr</span></code></a> と <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal"><span class="pre">tp_setattro</span></code></a> を両方とも継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_compare">
cmpfunc <code class="descname">PyTypeObject.tp_compare</code><a class="headerlink" href="#c.PyTypeObject.tp_compare" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、三値比較 (three-way comparison) を行う関数を指します。</p>
<p>シグネチャは <a class="reference internal" href="object.html#c.PyObject_Compare" title="PyObject_Compare"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Compare()</span></code></a> と同じです。この関数は <em>self</em> が <em>other</em> よりも大きければ <code class="docutils literal"><span class="pre">1</span></code>, <em>self</em> と <em>other</em> の値が等しければ <code class="docutils literal"><span class="pre">0</span></code>, <em>self</em> が <em>other</em> より小さければ <code class="docutils literal"><span class="pre">-1</span></code> を返します。この関数は、比較操作中にエラーが生じた場合、例外状態をセットして <code class="docutils literal"><span class="pre">-1</span></code> を返さねばなりません。</p>
<p>このフィールドは <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal"><span class="pre">tp_hash</span></code></a> と共にサブタイプに継承されます: すなわち、サブタイプの <a class="reference internal" href="#c.PyTypeObject.tp_compare" title="PyTypeObject.tp_compare"><code class="xref c c-member docutils literal"><span class="pre">tp_compare</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal"><span class="pre">tp_hash</span></code></a> が共に <em>NULL</em> の場合、サブタイプは基底タイプから <a class="reference internal" href="#c.PyTypeObject.tp_compare" title="PyTypeObject.tp_compare"><code class="xref c c-member docutils literal"><span class="pre">tp_compare</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal"><span class="pre">tp_hash</span></code></a> の三つを一緒に継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_repr">
reprfunc <code class="descname">PyTypeObject.tp_repr</code><a class="headerlink" href="#c.PyTypeObject.tp_repr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-1">オプションのフィールドです。ポインタで、組み込み関数 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> を実装している関数を指します。</p>
<p>シグネチャは <a class="reference internal" href="object.html#c.PyObject_Repr" title="PyObject_Repr"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Repr()</span></code></a> と同じです。この関数は文字列オブジェクトか Unicode オブジェクトを返さなければなりません。理想的には、この関数が返す文字列は、適切な環境で <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> に渡した場合、同じ値を持つオブジェクトになるような文字列でなければなりません。不可能な場合には、オブジェクトの型と値から導出した内容の入った <code class="docutils literal"><span class="pre">'&lt;'</span></code> から始まって <code class="docutils literal"><span class="pre">'&gt;'</span></code> で終わる文字列を返さなければなりません。</p>
<p>このフィールドが設定されていない場合、 <code class="docutils literal"><span class="pre">&lt;%s</span> <span class="pre">object</span> <span class="pre">at</span> <span class="pre">%p&gt;</span></code> の形式をとる文字列が返されます。 <code class="docutils literal"><span class="pre">%s</span></code> は型の名前に、 <code class="docutils literal"><span class="pre">%p</span></code> はオブジェクトのメモリアドレスに置き換えられます。</p>
<p>サブタイプはこのフィールドを継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.tp_as_number">
<a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods">PyNumberMethods</a>* <code class="descname">tp_as_number</code><a class="headerlink" href="#c.tp_as_number" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>数値プロトコルを実装した追加の構造体を指すポインタです。これらのフィールドについては <a class="reference internal" href="#number-structs"><span class="std std-ref">数値オブジェクト構造体</span></a> で説明されています。</p>
<p><code class="xref c c-member docutils literal"><span class="pre">tp_as_number</span></code> フィールドは継承されませんが、そこの含まれるフィールドが個別に継承されます。</p>
</dd></dl>

<dl class="member">
<dt id="c.tp_as_sequence">
<a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods">PySequenceMethods</a>* <code class="descname">tp_as_sequence</code><a class="headerlink" href="#c.tp_as_sequence" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンスプロトコルを実装した追加の構造体を指すポインタです。これらのフィールドについては <a class="reference internal" href="#sequence-structs"><span class="std std-ref">シーケンスオブジェクト構造体</span></a> で説明されています。</p>
<p><code class="xref c c-member docutils literal"><span class="pre">tp_as_sequence</span></code> フィールドは継承されませんが、これに含まれるフィールドが個別に継承されます。</p>
</dd></dl>

<dl class="member">
<dt id="c.tp_as_mapping">
<a class="reference internal" href="#c.PyMappingMethods" title="PyMappingMethods">PyMappingMethods</a>* <code class="descname">tp_as_mapping</code><a class="headerlink" href="#c.tp_as_mapping" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>マッピングプロトコルを実装した追加の構造体を指すポインタです。これらのフィールドについては <a class="reference internal" href="#mapping-structs"><span class="std std-ref">マップ型オブジェクト構造体</span></a> で説明されています。</p>
<p><code class="xref c c-member docutils literal"><span class="pre">tp_as_mapping</span></code> フィールドは継承されませんが、これに含まれるフィールドが個別に継承されます。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_hash">
hashfunc <code class="descname">PyTypeObject.tp_hash</code><a class="headerlink" href="#c.PyTypeObject.tp_hash" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-2">オプションのフィールドです。ポインタで、組み込み関数 <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a> を実装している関数を指します。</p>
<p>シグネチャは <a class="reference internal" href="object.html#c.PyObject_Hash" title="PyObject_Hash"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Hash()</span></code></a> と同じです。この関数は C の <code class="xref c c-type docutils literal"><span class="pre">long</span></code> 型の値を返さねばなりません。通常時には <code class="docutils literal"><span class="pre">-1</span></code> を戻り値にしてはなりません; ハッシュ値の計算中にエラーが生じた場合、関数は例外をセットして <code class="docutils literal"><span class="pre">-1</span></code> を返さねばなりません。</p>
<p>このフィールドは明示的に <a class="reference internal" href="object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal"><span class="pre">PyObject_HashNotImplemented()</span></code></a> に設定することで、親 type からのハッシュメソッドの継承をブロックすることができます。これは Python レベルでの <code class="docutils literal"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> と同等に解釈され、 <code class="docutils literal"><span class="pre">isinstance(o,</span> <span class="pre">collections.Hashable)</span></code> が正しく <code class="docutils literal"><span class="pre">False</span></code> を返すようになります。逆もまた可能であることに注意してください - Python レベルで <code class="docutils literal"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> を設定することで <code class="docutils literal"><span class="pre">tp_hash</span></code> スロットは <a class="reference internal" href="object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal"><span class="pre">PyObject_HashNotImplemented()</span></code></a> に設定されます。</p>
<p>このフィールドが設定されていない場合、二つの可能性があります: <a class="reference internal" href="#c.PyTypeObject.tp_compare" title="PyTypeObject.tp_compare"><code class="xref c c-member docutils literal"><span class="pre">tp_compare</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a> フィールドの両方が <em>NULL</em> の場合、オブジェクトのアドレスに基づいたデフォルトのハッシュ値が返されます; それ以外の場合、 <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出されます。</p>
<p>このフィールドは <a class="reference internal" href="#c.PyTypeObject.tp_compare" title="PyTypeObject.tp_compare"><code class="xref c c-member docutils literal"><span class="pre">tp_compare</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a> と共にサブタイプに継承されます: すなわち、サブタイプの <a class="reference internal" href="#c.PyTypeObject.tp_compare" title="PyTypeObject.tp_compare"><code class="xref c c-member docutils literal"><span class="pre">tp_compare</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal"><span class="pre">tp_hash</span></code></a> が共に <em>NULL</em> の場合、サブタイプは基底タイプから <a class="reference internal" href="#c.PyTypeObject.tp_compare" title="PyTypeObject.tp_compare"><code class="xref c c-member docutils literal"><span class="pre">tp_compare</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal"><span class="pre">tp_hash</span></code></a> の三つをいずれも継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_call">
ternaryfunc <code class="descname">PyTypeObject.tp_call</code><a class="headerlink" href="#c.PyTypeObject.tp_call" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、オブジェクトの呼び出しを実装している関数を指します。オブジェクトが呼び出し可能でない場合には <em>NULL</em> にしなければなりません。シグネチャは <a class="reference internal" href="object.html#c.PyObject_Call" title="PyObject_Call"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Call()</span></code></a> と同じです。</p>
<p>サブタイプはこのフィールドを継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_str">
reprfunc <code class="descname">PyTypeObject.tp_str</code><a class="headerlink" href="#c.PyTypeObject.tp_str" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、組み込みの演算 <a class="reference internal" href="../library/functions.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> を実装している関数を指します。(<a class="reference internal" href="../library/functions.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> が型の一つになったため、 <a class="reference internal" href="../library/functions.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> は <a class="reference internal" href="../library/functions.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> のコンストラクタを呼び出すことに注意してください。このコンストラクタは実際の処理を行う上で <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Str()</span></code></a> を呼び出し、さらに <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Str()</span></code></a> がこのハンドラを呼び出すことになります。)</p>
<p>シグネチャは <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Str()</span></code></a> と同じです; この関数は文字列オブジェクトか Unicode オブジェクトを返さねばなりません。また、この関数はオブジェクトを &quot;分かりやすく (friendly)&quot; 表現した文字列を返さねばなりません。というのは、この文字列は <a class="reference internal" href="../reference/simple_stmts.html#print"><code class="xref std std-keyword docutils literal"><span class="pre">print</span></code></a> 文で使われることになる表記だからです。</p>
<p>このフィールドが設定されていない場合、文字列表現を返すためには <a class="reference internal" href="object.html#c.PyObject_Repr" title="PyObject_Repr"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Repr()</span></code></a> が呼び出されます。</p>
<p>サブタイプはこのフィールドを継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_getattro">
getattrofunc <code class="descname">PyTypeObject.tp_getattro</code><a class="headerlink" href="#c.PyTypeObject.tp_getattro" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、 get-attribute を実装している関数を指します。</p>
<p>シグネチャは <a class="reference internal" href="object.html#c.PyObject_GetAttr" title="PyObject_GetAttr"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GetAttr()</span></code></a> と同じです。対する通常の属性検索を実装している <a class="reference internal" href="object.html#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GenericGetAttr()</span></code></a> をこのフィールドに設定しておくと往々にして便利です。</p>
<p>このフィールドは <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal"><span class="pre">tp_getattr</span></code></a> と共にサブタイプに継承されます: すなわち、サブタイプの <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal"><span class="pre">tp_getattr</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal"><span class="pre">tp_getattro</span></code></a> が共に <em>NULL</em> の場合、サブタイプは基底タイプから <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal"><span class="pre">tp_getattr</span></code></a> と <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal"><span class="pre">tp_getattro</span></code></a> を両方とも継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_setattro">
setattrofunc <code class="descname">PyTypeObject.tp_setattro</code><a class="headerlink" href="#c.PyTypeObject.tp_setattro" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのポインタで、属性の設定と削除を行う関数を指します。</p>
<p>シグネチャは <a class="reference internal" href="object.html#c.PyObject_SetAttr" title="PyObject_SetAttr"><code class="xref c c-func docutils literal"><span class="pre">PyObject_SetAttr()</span></code></a> と同じですが、 <em>v</em> に <em>NULL</em> を指定して属性を削除できるようにしなければなりません。通常の属性設定を実装している <a class="reference internal" href="object.html#c.PyObject_GenericSetAttr" title="PyObject_GenericSetAttr"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GenericSetAttr()</span></code></a>  をこのフィールドに設定しておくとたいていの場合は便利です。</p>
<p>このフィールドは <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal"><span class="pre">tp_setattr</span></code></a> と共にサブタイプに継承されます: すなわち、サブタイプの <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal"><span class="pre">tp_setattr</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal"><span class="pre">tp_setattro</span></code></a> が共に <em>NULL</em> の場合、サブタイプは基底タイプから <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal"><span class="pre">tp_setattr</span></code></a> と <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal"><span class="pre">tp_setattro</span></code></a> を両方とも継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_as_buffer">
<a class="reference internal" href="#c.PyBufferProcs" title="PyBufferProcs">PyBufferProcs</a>* <code class="descname">PyTypeObject.tp_as_buffer</code><a class="headerlink" href="#c.PyTypeObject.tp_as_buffer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バッファインタフェースを実装しているオブジェクトにのみ関連する、一連のフィールド群が入った別の構造体を指すポインタです。構造体内の各フィールドは <a class="reference internal" href="#buffer-structs"><span class="std std-ref">バッファオブジェクト構造体 (buffer object structure)</span></a> で説明します。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal"><span class="pre">tp_as_buffer</span></code></a> フィールド自体は継承されませんが、これに含まれるフィールドは個別に継承されます。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_flags">
long <code class="descname">PyTypeObject.tp_flags</code><a class="headerlink" href="#c.PyTypeObject.tp_flags" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このフィールドは様々なフラグからなるビットマスクです。いくつかのフラグは、特定の状況において変則的なセマンティクスが適用されることを示します; その他のフラグは、型オブジェクト (あるいは <code class="xref c c-member docutils literal"><span class="pre">tp_as_number</span></code> 、 <code class="xref c c-member docutils literal"><span class="pre">tp_as_sequence</span></code> 、 <code class="xref c c-member docutils literal"><span class="pre">tp_as_mapping</span></code> 、 および <a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal"><span class="pre">tp_as_buffer</span></code></a> が参照している拡張機能構造体) の特定のフィールドのうち、過去から現在までずっと存在していたわけではないものが有効になっていることを示すために使われます; フラグビットがクリアされていれば、フラグが保護しているフィールドにはアクセスしない代わりに、その値はゼロか <em>NULL</em> になっているとみなさなければなりません。</p>
<p>このフィールドの継承は複雑です。ほとんどのフラグビットは個別に継承されます。つまり、基底タイプであるフラグビットがセットされている場合、サブタイプはそのフラグビットを継承します。機能拡張のための構造体に関するフラグビットは、その機能拡張構造体が継承されるときに限定して継承されます。すなわち、基底タイプのフラグビットの値は、機能拡張構造体へのポインタと一緒にサブタイプにコピーされます。 <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> フラグビットは、 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> フィールドと合わせてコピーされます。すなわち、サブタイプの <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> フラグビットがクリアで、かつ (<a class="reference internal" href="#Py_TPFLAGS_HAVE_RICHCOMPARE" title="Py_TPFLAGS_HAVE_RICHCOMPARE"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_RICHCOMPARE</span></code></a> フラグビットの指定によって) <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> フィールドがサブタイプ内に存在しており、かつ値が <em>NULL</em> の場合に基底タイプから値を継承します。</p>
<p>以下に挙げるビットマスクは現在定義されているものです; フラグは <code class="docutils literal"><span class="pre">|</span></code> 演算子で論理和を取って <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal"><span class="pre">tp_flags</span></code></a> フィールドの値を作成できます。 <a class="reference internal" href="type.html#c.PyType_HasFeature" title="PyType_HasFeature"><code class="xref c c-func docutils literal"><span class="pre">PyType_HasFeature()</span></code></a> マクロは型とフラグ値、 <em>tp</em> および <em>f</em> をとり、 <code class="docutils literal"><span class="pre">tp-&gt;tp_flags</span> <span class="pre">&amp;</span> <span class="pre">f</span></code> が非ゼロかどうか調べます。</p>
<dl class="data">
<dt id="Py_TPFLAGS_HAVE_GETCHARBUFFER">
<code class="descname">Py_TPFLAGS_HAVE_GETCHARBUFFER</code><a class="headerlink" href="#Py_TPFLAGS_HAVE_GETCHARBUFFER" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このビットがセットされていれば、 <a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal"><span class="pre">tp_as_buffer</span></code></a> が参照する <a class="reference internal" href="#c.PyBufferProcs" title="PyBufferProcs"><code class="xref c c-type docutils literal"><span class="pre">PyBufferProcs</span></code></a> 構造体には <code class="xref py py-attr docutils literal"><span class="pre">bf_getcharbuffer</span></code> フィールドがあります。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_HAVE_SEQUENCE_IN">
<code class="descname">Py_TPFLAGS_HAVE_SEQUENCE_IN</code><a class="headerlink" href="#Py_TPFLAGS_HAVE_SEQUENCE_IN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このビットがセットされていれば、 <code class="xref c c-member docutils literal"><span class="pre">tp_as_sequence</span></code> が参照する <a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><code class="xref c c-type docutils literal"><span class="pre">PySequenceMethods</span></code></a> 構造体には <code class="xref py py-attr docutils literal"><span class="pre">sq_contains</span></code> フィールドがあります。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_GC">
<code class="descname">Py_TPFLAGS_GC</code><a class="headerlink" href="#Py_TPFLAGS_GC" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このビットは旧式のものです。このシンボルが指し示していたビットはもはや使われていません。シンボルの現在の定義はゼロになっています。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_HAVE_INPLACEOPS">
<code class="descname">Py_TPFLAGS_HAVE_INPLACEOPS</code><a class="headerlink" href="#Py_TPFLAGS_HAVE_INPLACEOPS" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このビットがセットされていれば、 <code class="xref c c-member docutils literal"><span class="pre">tp_as_sequence</span></code> が参照する <a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><code class="xref c c-type docutils literal"><span class="pre">PySequenceMethods</span></code></a> 構造体、および <code class="xref c c-member docutils literal"><span class="pre">tp_as_number</span></code> が参照する <a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal"><span class="pre">PyNumberMethods</span></code></a> 構造体には in-place 演算に関するフィールドが入っています。具体的に言うと、 <a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal"><span class="pre">PyNumberMethods</span></code></a> 構造体はフィールド <code class="xref py py-attr docutils literal"><span class="pre">nb_inplace_add</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_inplace_subtract</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_inplace_multiply</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_inplace_divide</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_inplace_remainder</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_inplace_power</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_inplace_lshift</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_inplace_rshift</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_inplace_and</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_inplace_xor</span></code>,および <code class="xref py py-attr docutils literal"><span class="pre">nb_inplace_or</span></code> を持つことになります; また、 <a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><code class="xref c c-type docutils literal"><span class="pre">PySequenceMethods</span></code></a> 構造体はフィールド <code class="xref py py-attr docutils literal"><span class="pre">sq_inplace_concat</span></code> および <code class="xref py py-attr docutils literal"><span class="pre">sq_inplace_repeat</span></code> を持つことになります。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_CHECKTYPES">
<code class="descname">Py_TPFLAGS_CHECKTYPES</code><a class="headerlink" href="#Py_TPFLAGS_CHECKTYPES" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このビットがセットされていれば、 <code class="xref c c-member docutils literal"><span class="pre">tp_as_number</span></code> が参照する <a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal"><span class="pre">PyNumberMethods</span></code></a> 構造体内で定義されている二項演算子および三項演算子は任意のオブジェクト型を非演算子にとるようになり、必要に応じて引数の型変換を行います。このビットがクリアなら、演算子は全ての引数が現在のオブジェクト型と同じであるよう要求し、演算の呼び出し側は演算に先立って型変換を行うものと想定します。対象となる演算子は <code class="xref py py-attr docutils literal"><span class="pre">nb_add</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_subtract</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_multiply</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_divide</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_remainder</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_divmod</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_power</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_lshift</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_rshift</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_and</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nb_xor</span></code>,および <code class="xref py py-attr docutils literal"><span class="pre">nb_or</span></code> です。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_HAVE_RICHCOMPARE">
<code class="descname">Py_TPFLAGS_HAVE_RICHCOMPARE</code><a class="headerlink" href="#Py_TPFLAGS_HAVE_RICHCOMPARE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このビットがセットされていれば、型オブジェクトには <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a> フィールド、そして <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> フィールドがあります。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_HAVE_WEAKREFS">
<code class="descname">Py_TPFLAGS_HAVE_WEAKREFS</code><a class="headerlink" href="#Py_TPFLAGS_HAVE_WEAKREFS" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このビットがセットされていれば、構造体には <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_weaklistoffset</span></code></a> フィールドが定義されています。 <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_weaklistoffset</span></code></a> フィールドの値がゼロより大きければ、この型のインスタンスは弱参照で参照できます。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_HAVE_ITER">
<code class="descname">Py_TPFLAGS_HAVE_ITER</code><a class="headerlink" href="#Py_TPFLAGS_HAVE_ITER" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このビットがセットされていれば、型オブジェクトには <a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal"><span class="pre">tp_iternext</span></code></a> フィールドがあります。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_HAVE_CLASS">
<code class="descname">Py_TPFLAGS_HAVE_CLASS</code><a class="headerlink" href="#Py_TPFLAGS_HAVE_CLASS" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このビットがセットされていれば、型オブジェクトは Python 2.2 以降で定義されている新たなフィールド: <a class="reference internal" href="#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code class="xref c c-member docutils literal"><span class="pre">tp_methods</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code class="xref c c-member docutils literal"><span class="pre">tp_members</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_getset" title="PyTypeObject.tp_getset"><code class="xref c c-member docutils literal"><span class="pre">tp_getset</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal"><span class="pre">tp_base</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal"><span class="pre">tp_dict</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_descr_get" title="PyTypeObject.tp_descr_get"><code class="xref c c-member docutils literal"><span class="pre">tp_descr_get</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_descr_set" title="PyTypeObject.tp_descr_set"><code class="xref c c-member docutils literal"><span class="pre">tp_descr_set</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_dictoffset</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal"><span class="pre">tp_alloc</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal"><span class="pre">tp_free</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_is_gc" title="PyTypeObject.tp_is_gc"><code class="xref c c-member docutils literal"><span class="pre">tp_is_gc</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_bases" title="PyTypeObject.tp_bases"><code class="xref c c-member docutils literal"><span class="pre">tp_bases</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_mro" title="PyTypeObject.tp_mro"><code class="xref c c-member docutils literal"><span class="pre">tp_mro</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_cache" title="PyTypeObject.tp_cache"><code class="xref c c-member docutils literal"><span class="pre">tp_cache</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_subclasses" title="PyTypeObject.tp_subclasses"><code class="xref c c-member docutils literal"><span class="pre">tp_subclasses</span></code></a>,および <a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code class="xref c c-member docutils literal"><span class="pre">tp_weaklist</span></code></a> があります。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_HEAPTYPE">
<code class="descname">Py_TPFLAGS_HEAPTYPE</code><a class="headerlink" href="#Py_TPFLAGS_HEAPTYPE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>型オブジェクト自体がヒープにメモリ確保される場合にセットされるビットです。型オブジェクト自体がヒープにメモリ確保される場合、インスタンスの <code class="xref py py-attr docutils literal"><span class="pre">ob_type</span></code> フィールドは型オブジェクトへの参照とみなされます。この場合、新たなインスタンスを生成する度に型オブジェクトを INCREF し、インスタンスを解放するたびに DECREF します (サブタイプのインスタンスには適当されません; インスタンスが <code class="xref py py-attr docutils literal"><span class="pre">ob_type</span></code> で参照している型だけが INCREF および DECREF されます)。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_BASETYPE">
<code class="descname">Py_TPFLAGS_BASETYPE</code><a class="headerlink" href="#Py_TPFLAGS_BASETYPE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>型を別の型の基底タイプとして使える場合にセットされるビットです。このビットがクリアならば、この型のサブタイプは生成できません (Java における &quot;final&quot; クラスに似たクラスになります)。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_READY">
<code class="descname">Py_TPFLAGS_READY</code><a class="headerlink" href="#Py_TPFLAGS_READY" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>型オブジェクトが <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> で完全に初期化されるとセットされるビットです。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_READYING">
<code class="descname">Py_TPFLAGS_READYING</code><a class="headerlink" href="#Py_TPFLAGS_READYING" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> による型オブジェクトの初期化処理中にセットされるビットです。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_HAVE_GC">
<code class="descname">Py_TPFLAGS_HAVE_GC</code><a class="headerlink" href="#Py_TPFLAGS_HAVE_GC" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトがガベージコレクション (GC) をサポートする場合にセットされるビットです。このビットがセットされている場合、インスタンスは <a class="reference internal" href="gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_New()</span></code></a> を使って生成し、 <a class="reference internal" href="gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_Del()</span></code></a> を使って破壊しなければなりません。詳しい情報は <a class="reference internal" href="gcsupport.html#supporting-cycle-detection"><span class="std std-ref">循環参照ガベージコレクションをサポートする</span></a> にあります。このビットはまた、GC に関連するフィールド <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> が型オブジェクト内に存在することを示します; しかし、これらのフィールドは <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> がクリアでも <a class="reference internal" href="#Py_TPFLAGS_HAVE_RICHCOMPARE" title="Py_TPFLAGS_HAVE_RICHCOMPARE"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_RICHCOMPARE</span></code></a> がセットされている場合には存在します。</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_DEFAULT">
<code class="descname">Py_TPFLAGS_DEFAULT</code><a class="headerlink" href="#Py_TPFLAGS_DEFAULT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>型オブジェクトおよび拡張機能構造体の特定のフィールドの存在の有無に関連する全てのビットからなるビットマスクです。現状では、このビットマスクには以下のビット: <a class="reference internal" href="#Py_TPFLAGS_HAVE_GETCHARBUFFER" title="Py_TPFLAGS_HAVE_GETCHARBUFFER"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GETCHARBUFFER</span></code></a>, <a class="reference internal" href="#Py_TPFLAGS_HAVE_SEQUENCE_IN" title="Py_TPFLAGS_HAVE_SEQUENCE_IN"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_SEQUENCE_IN</span></code></a>, <a class="reference internal" href="#Py_TPFLAGS_HAVE_INPLACEOPS" title="Py_TPFLAGS_HAVE_INPLACEOPS"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_INPLACEOPS</span></code></a>, <a class="reference internal" href="#Py_TPFLAGS_HAVE_RICHCOMPARE" title="Py_TPFLAGS_HAVE_RICHCOMPARE"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_RICHCOMPARE</span></code></a>, <a class="reference internal" href="#Py_TPFLAGS_HAVE_WEAKREFS" title="Py_TPFLAGS_HAVE_WEAKREFS"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_WEAKREFS</span></code></a>, <a class="reference internal" href="#Py_TPFLAGS_HAVE_ITER" title="Py_TPFLAGS_HAVE_ITER"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_ITER</span></code></a>,および <a class="reference internal" href="#Py_TPFLAGS_HAVE_CLASS" title="Py_TPFLAGS_HAVE_CLASS"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_CLASS</span></code></a> が入っています。</p>
</dd></dl>

</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_doc">
char* <code class="descname">PyTypeObject.tp_doc</code><a class="headerlink" href="#c.PyTypeObject.tp_doc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、この型オブジェクトの docstring を与える NUL 終端された C の文字列を指します。この値は型オブジェクトと型のインスタンスにおける <code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code> 属性として公開されます。</p>
<p>サブタイプはこのフィールドを継承 <em>しません</em> 。</p>
</dd></dl>

<p>以下の三つのフィールドは、 <a class="reference internal" href="#Py_TPFLAGS_HAVE_RICHCOMPARE" title="Py_TPFLAGS_HAVE_RICHCOMPARE"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_RICHCOMPARE</span></code></a> フラグビットがセットされている場合にのみ存在します。</p>
<dl class="member">
<dt id="c.PyTypeObject.tp_traverse">
<a class="reference internal" href="gcsupport.html#c.traverseproc" title="traverseproc">traverseproc</a> <code class="descname">PyTypeObject.tp_traverse</code><a class="headerlink" href="#c.PyTypeObject.tp_traverse" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、ガベージコレクタのためのトラバーサル関数 (traversal function) を指します。 <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> がセットされている場合にのみ使われます。Pythonのガベージコレクションの枠組みに関する詳細は <a class="reference internal" href="gcsupport.html#supporting-cycle-detection"><span class="std std-ref">循環参照ガベージコレクションをサポートする</span></a> にあります。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> ポインタは、ガベージコレクタが循環参照を見つけるために使われます。 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> 関数の典型的な実装は、インスタンスの各メンバのうち Pythonオブジェクトに対して <a class="reference internal" href="gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal"><span class="pre">Py_VISIT()</span></code></a> を呼び出します。例えば、次のコードは <a class="reference internal" href="../library/thread.html#module-thread" title="thread: Create multiple threads of control within one interpreter."><code class="xref py py-mod docutils literal"><span class="pre">thread</span></code></a> 拡張モジュールの <code class="xref c c-func docutils literal"><span class="pre">local_traverse()</span></code> 関数になります:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">local_traverse</span><span class="p">(</span><span class="n">localobject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">kw</span><span class="p">);</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal"><span class="pre">Py_VISIT()</span></code></a> が循環参照になる恐れのあるメンバにだけ呼び出されていることに注目してください。 <code class="docutils literal"><span class="pre">self-&gt;key</span></code> メンバもありますが、それは <em>NULL</em> か Python文字列なので、循環参照の一部になることはありません。</p>
<p>一方、メンバが循環参照の一部になり得ないと判っていても、デバッグ目的で巡回したい場合があるかもしれないので、 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal"><span class="pre">gc</span></code></a> モジュールの <a class="reference internal" href="../library/gc.html#gc.get_referents" title="gc.get_referents"><code class="xref py py-func docutils literal"><span class="pre">get_referents()</span></code></a> 関数は循環参照になり得ないメンバも返します。</p>
<p><a class="reference internal" href="gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal"><span class="pre">Py_VISIT()</span></code></a> は <code class="xref c c-func docutils literal"><span class="pre">local_traverse()</span></code> が <em>visit</em> と <em>arg</em> という決まった名前の引数を持つことを要求します。</p>
<p>このフィールドは <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> および <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> フラグビットと一緒に継承されます: フラグビット、 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a>,および <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> の値がサブタイプで全てゼロになっており、 <em>かつ</em> サブタイプで <a class="reference internal" href="#Py_TPFLAGS_HAVE_RICHCOMPARE" title="Py_TPFLAGS_HAVE_RICHCOMPARE"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_RICHCOMPARE</span></code></a> フラグビットがセットされている場合に、基底タイプから値を継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_clear">
<a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry">inquiry</a> <code class="descname">PyTypeObject.tp_clear</code><a class="headerlink" href="#c.PyTypeObject.tp_clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、ガベージコレクタにおける消去関数 (clear function) を指します。 <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> がセットされている場合にのみ使われます。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> メンバ関数は GC が検出した循環しているゴミの循環参照を壊すために用いられます。総合的な視点で考えると、システム内の全ての <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> 関数が連携して、全ての循環参照を破壊しなければなりません。 (訳注: ある型が <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> を実装しなくても全ての循環参照が破壊できるのであれば実装しなくても良い) これはとても繊細で、もし少しでも不確かな部分があるのであれば、 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> 関数を提供するべきです。例えば、タプルは <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> を実装しません。なぜなら、タプルだけで構成された循環参照がみつかることは無いからです。従って、タプル以外の型の <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> 関数だけで、タプルを含むどんな循環参照も必ず破壊できることになります。これは簡単に判ることではなく、 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> の実装を避ける良い理由はめったにありません。</p>
<p>次の例にあるように、 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> の実装は、インスタンスから Python オブジェクトだと思われるメンバへの参照を外し、それらのメンバへのポインタに <em>NULL</em> をセットすべきです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">local_clear</span><span class="p">(</span><span class="n">localobject</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">kw</span><span class="p">);</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>参照のクリアはデリケートなので、 <a class="reference internal" href="refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code class="xref c c-func docutils literal"><span class="pre">Py_CLEAR()</span></code></a> マクロを使うべきです: ポインタを <em>NULL</em> にセットするまで、そのオブジェクトの参照カウントをデクリメントしてはいけません。参照カウントのデクリメントすると、そのオブジェクトが破棄されるかもしれず、 (そのオブジェクトに関連付けられたファイナライザ、弱参照のコールバックにより) 任意のPythonコードの実行を含む後片付け処理が実行されるかもしれないからです。もしそういったコードが再び <em>self</em> を参照することがあれば、すでに持っていたオブジェクトへのポインタは <em>NULL</em> になっているので、 <em>self</em> は所有していたオブジェクトをもう利用できないことを認識できます。 <a class="reference internal" href="refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code class="xref c c-func docutils literal"><span class="pre">Py_CLEAR()</span></code></a> マクロはその手続きを安全な順番で実行します。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> 関数の目的は参照カウントを破壊することなので、 Python 文字列や Python 整数のような、循環参照に含むことのできないオブジェクトをクリアする必要はありません。一方、所有する全ての Python オブジェクトをクリアするようにし、その型の <a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> 関数が <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> 関数を実行するようにすると実装が楽になるでしょう。</p>
<p>Pythonのガベージコレクションの仕組みについての詳細は、 <a class="reference internal" href="gcsupport.html#supporting-cycle-detection"><span class="std std-ref">循環参照ガベージコレクションをサポートする</span></a> にあります。</p>
<p>このフィールドは <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> および <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> フラグビットと一緒に継承されます: フラグビット、 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a>,および <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> の値がサブタイプで全てゼロになっており、 <em>かつ</em> サブタイプで <a class="reference internal" href="#Py_TPFLAGS_HAVE_RICHCOMPARE" title="Py_TPFLAGS_HAVE_RICHCOMPARE"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_RICHCOMPARE</span></code></a> フラグビットがセットされている場合に、基底タイプから値を継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_richcompare">
richcmpfunc <code class="descname">PyTypeObject.tp_richcompare</code><a class="headerlink" href="#c.PyTypeObject.tp_richcompare" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドで、拡張比較関数 (rich comparison function) を指すポインタです。拡張比較関数のシグネチャは <code class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*tp_richcompare(PyObject</span> <span class="pre">*a,</span> <span class="pre">PyObject</span> <span class="pre">*b,</span> <span class="pre">int</span> <span class="pre">op)</span></code> です。</p>
<p>この関数は、比較結果を返すべきです。(普通は <code class="docutils literal"><span class="pre">Py_True</span></code> か <code class="docutils literal"><span class="pre">Py_False</span></code> です。) 比較が未定義の場合は、<code class="docutils literal"><span class="pre">Py_NotImplemented</span></code> を、それ以外のエラーが発生した場合には例外状態をセットして <code class="docutils literal"><span class="pre">NULL</span></code> を返さなければなりません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">限られた種類の比較だけが可能 (例えば、 <code class="docutils literal"><span class="pre">==</span></code> と <code class="docutils literal"><span class="pre">!=</span></code> が可能で <code class="docutils literal"><span class="pre">&lt;</span></code> などが不可能) な型を実装したい場合、拡張比較関数で直接 <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を返します。</p>
</div>
<p>このフィールドは <a class="reference internal" href="#c.PyTypeObject.tp_compare" title="PyTypeObject.tp_compare"><code class="xref c c-member docutils literal"><span class="pre">tp_compare</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal"><span class="pre">tp_hash</span></code></a> と共にサブタイプに継承されます: すなわち、サブタイプの <a class="reference internal" href="#c.PyTypeObject.tp_compare" title="PyTypeObject.tp_compare"><code class="xref c c-member docutils literal"><span class="pre">tp_compare</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal"><span class="pre">tp_hash</span></code></a> が共に <em>NULL</em> の場合、サブタイプは基底タイプから <a class="reference internal" href="#c.PyTypeObject.tp_compare" title="PyTypeObject.tp_compare"><code class="xref c c-member docutils literal"><span class="pre">tp_compare</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal"><span class="pre">tp_hash</span></code></a> の三つを一緒に継承します。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a> および <a class="reference internal" href="object.html#c.PyObject_RichCompare" title="PyObject_RichCompare"><code class="xref c c-func docutils literal"><span class="pre">PyObject_RichCompare()</span></code></a> 関数の第三引数に使うための定数としては以下が定義されています:</p>
<table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">定数</th>
<th class="head">比較</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">Py_LT</span></code></td>
<td><code class="docutils literal"><span class="pre">&lt;</span></code></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal"><span class="pre">Py_LE</span></code></td>
<td><code class="docutils literal"><span class="pre">&lt;=</span></code></td>
</tr>
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">Py_EQ</span></code></td>
<td><code class="docutils literal"><span class="pre">==</span></code></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal"><span class="pre">Py_NE</span></code></td>
<td><code class="docutils literal"><span class="pre">!=</span></code></td>
</tr>
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">Py_GT</span></code></td>
<td><code class="docutils literal"><span class="pre">&gt;</span></code></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal"><span class="pre">Py_GE</span></code></td>
<td><code class="docutils literal"><span class="pre">&gt;=</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<p>次のフィールドは、 <a class="reference internal" href="#Py_TPFLAGS_HAVE_WEAKREFS" title="Py_TPFLAGS_HAVE_WEAKREFS"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_WEAKREFS</span></code></a> フラグビットがセットされている場合にのみ存在します。</p>
<dl class="member">
<dt id="c.PyTypeObject.tp_weaklistoffset">
long <code class="descname">PyTypeObject.tp_weaklistoffset</code><a class="headerlink" href="#c.PyTypeObject.tp_weaklistoffset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>型のインスタンスが弱参照可能な場合、このフィールドはゼロよりも大きな数になり、インスタンス構造体における弱参照リストの先頭を示すオフセットが入ります (GC ヘッダがある場合には無視します); このオフセット値は <code class="xref c c-func docutils literal"><span class="pre">PyObject_ClearWeakRefs()</span></code> および <code class="xref c c-func docutils literal"><span class="pre">PyWeakref_*()</span></code> 関数が利用します。インスタンス構造体には、 <em>NULL</em> に初期化された <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> 型のフィールドが入っていなければなりません。</p>
<p>このフィールドを <a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code class="xref c c-member docutils literal"><span class="pre">tp_weaklist</span></code></a> と混同しないようにしてください; これは型オブジェクト自身への弱参照からなるリストの先頭です。</p>
<p>このフィールドはサブタイプに継承されますが、以下の規則を読んでください。サブタイプはこのオフセット値をオーバライドすることがあります; 従って、サブタイプでは弱参照リストの先頭が基底タイプとは異なる場合があります。リストの先頭は常に <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_weaklistoffset</span></code></a> で分かるはずなので、このことは問題にはならないはずです。</p>
<p><a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> 文で定義された型に <code class="xref py py-attr docutils literal"><span class="pre">__slots__</span></code> 宣言が全くなく、かつ基底タイプが弱参照可能でない場合、その型を弱参照可能にするには弱参照リストの先頭を表すスロットをインスタンスデータレイアウト構造体に追加し、スロットのオフセットを <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_weaklistoffset</span></code></a> に設定します。</p>
<p>型の <a class="reference internal" href="../reference/datamodel.html#__slots__" title="__slots__"><code class="xref py py-attr docutils literal"><span class="pre">__slots__</span></code></a> の宣言に <code class="xref py py-attr docutils literal"><span class="pre">__weakref__</span></code> という名前のスロットが含まれているとき、スロットはその型のインスタンスにおける弱参照リストの先頭を表すスロットになり、スロットのオフセットが型の <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_weaklistoffset</span></code></a> に入ります。</p>
<p>型の <a class="reference internal" href="../reference/datamodel.html#__slots__" title="__slots__"><code class="xref py py-attr docutils literal"><span class="pre">__slots__</span></code></a> 宣言が <code class="xref py py-attr docutils literal"><span class="pre">__weakref__</span></code> という名前のスロットを含んでいないとき、その型は基底タイプから <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_weaklistoffset</span></code></a> を継承します。</p>
</dd></dl>

<p>次の二つのフィールドは、 <a class="reference internal" href="#Py_TPFLAGS_HAVE_ITER" title="Py_TPFLAGS_HAVE_ITER"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_ITER</span></code></a> フラグビットがセットされている場合にのみ存在します。</p>
<dl class="member">
<dt id="c.PyTypeObject.tp_iter">
getiterfunc <code class="descname">PyTypeObject.tp_iter</code><a class="headerlink" href="#c.PyTypeObject.tp_iter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションの変数で、そのオブジェクトのイテレータを返す関数へのポインタです。この値が存在することは、通常この型のインスタンスがイテレート可能であることを示しています。(しかし、シーケンスはこの関数がなくてもイテレート可能ですし、旧スタイルクラスのインスタンスは <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> メソッドを定義していなくてもこの関数を持っています)</p>
<p>この関数は <a class="reference internal" href="object.html#c.PyObject_GetIter" title="PyObject_GetIter"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GetIter()</span></code></a> と同じシグネチャを持っています。</p>
<p>サブタイプはこのフィールドを継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_iternext">
iternextfunc <code class="descname">PyTypeObject.tp_iternext</code><a class="headerlink" href="#c.PyTypeObject.tp_iternext" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドで、イテレータにおいて次の要素を返す関数へのポインタです。イテレータの要素がなくなると、この関数は <em>NULL</em> を返さなければなりません。 <a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 例外は設定してもしなくても良いです。その他のエラーが発生したときも、 <em>NULL</em> を返さなければなりません。このフィールドがあると、通常この型のインスタンスがイテレータであることを示します (ただし、旧スタイルのインスタンスでは、たとえ <a class="reference internal" href="../library/stdtypes.html#iterator.next" title="iterator.next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a> メソッドが定義されていなくても常にこの関数を持っています)。</p>
<p>イテレータ型では、 <a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a> 関数も定義されていなければならず、その関数は (新たなイテレータインスタンスではなく) イテレータインスタンス自体を返さねばなりません。</p>
<p>この関数のシグネチャは <a class="reference internal" href="iter.html#c.PyIter_Next" title="PyIter_Next"><code class="xref c c-func docutils literal"><span class="pre">PyIter_Next()</span></code></a> と同じです。</p>
<p>サブタイプはこのフィールドを継承します。</p>
</dd></dl>

<p>次の <a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code class="xref c c-member docutils literal"><span class="pre">tp_weaklist</span></code></a> までのフィールドは、 <a class="reference internal" href="#Py_TPFLAGS_HAVE_CLASS" title="Py_TPFLAGS_HAVE_CLASS"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_CLASS</span></code></a> フラグビットがセットされている場合にのみ存在します。</p>
<dl class="member">
<dt id="c.PyTypeObject.tp_methods">
struct <a class="reference internal" href="structures.html#c.PyMethodDef" title="PyMethodDef">PyMethodDef</a>* <code class="descname">PyTypeObject.tp_methods</code><a class="headerlink" href="#c.PyTypeObject.tp_methods" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、この型の正規 (regular) のメソッドを宣言している <a class="reference internal" href="structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal"><span class="pre">PyMethodDef</span></code></a> 構造体からなる、 <em>NULL</em> で終端された静的な配列を指します。</p>
<p>配列の各要素ごとに、メソッドデスクリプタの入った、要素が型の辞書 (下記の <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal"><span class="pre">tp_dict</span></code></a> 参照) に追加されます。</p>
<p>サブタイプはこのフィールドを継承しません (メソッドは別個のメカニズムで継承されています)。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_members">
struct <a class="reference internal" href="structures.html#c.PyMemberDef" title="PyMemberDef">PyMemberDef</a>* <code class="descname">PyTypeObject.tp_members</code><a class="headerlink" href="#c.PyTypeObject.tp_members" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、型の正規 (regular) のデータメンバ (フィールドおよびスロット) を宣言している <a class="reference internal" href="structures.html#c.PyMemberDef" title="PyMemberDef"><code class="xref c c-type docutils literal"><span class="pre">PyMemberDef</span></code></a> 構造体からなる、 <em>NULL</em> で終端された静的な配列を指します。</p>
<p>配列の各要素ごとに、メンバデスクリプタの入った、要素が型の辞書 (下記の <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal"><span class="pre">tp_dict</span></code></a> 参照) に追加されます。</p>
<p>サブタイプはこのフィールドを継承しません (メンバは別個のメカニズムで継承されています)。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_getset">
struct <a class="reference internal" href="structures.html#c.PyGetSetDef" title="PyGetSetDef">PyGetSetDef</a>* <code class="descname">PyTypeObject.tp_getset</code><a class="headerlink" href="#c.PyTypeObject.tp_getset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、インスタンスの算出属性 (computed attribute) を宣言している <a class="reference internal" href="structures.html#c.PyGetSetDef" title="PyGetSetDef"><code class="xref c c-type docutils literal"><span class="pre">PyGetSetDef</span></code></a> 構造体からなる、 <em>NULL</em> で終端された静的な配列を指します。</p>
<p>配列の各要素ごとに、 getter/setter デスクリプタの入った、要素が型の辞書 (下記の <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal"><span class="pre">tp_dict</span></code></a> 参照) に追加されます。</p>
<p>サブタイプはこのフィールドを継承しません (算出属性は別個のメカニズムで継承されています)。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_base">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a>* <code class="descname">PyTypeObject.tp_base</code><a class="headerlink" href="#c.PyTypeObject.tp_base" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、型に関するプロパティを継承する基底タイプへのポインタです。このフィールドのレベルでは、単継承 (single inheritance) だけがサポートされています; 多重継承はメタタイプの呼び出しによる動的な型オブジェクトの生成を必要とします。</p>
<p>(当たり前ですが) サブタイプはこのフィールドを継承しません。しかし、このフィールドのデフォルト値は (Python プログラマは <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> 型として知っている) <code class="docutils literal"><span class="pre">&amp;PyBaseObject_Type</span></code> になります。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_dict">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyTypeObject.tp_dict</code><a class="headerlink" href="#c.PyTypeObject.tp_dict" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>型の辞書は <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> によってこのフィールドに収められます。</p>
<p>このフィールドは通常、 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> を呼び出す前に <em>NULL</em> に初期化しておかなければなりません; あるいは、型の初期属性の入った辞書で初期化しておいてもかまいません。 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> が型をひとたび初期化すると、型の新たな属性をこの辞書に追加できるのは、属性が (<a class="reference internal" href="../reference/datamodel.html#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal"><span class="pre">__add__()</span></code></a> のような) オーバロード用演算でないときだけです。</p>
<p>サブタイプはこのフィールドを継承しません (が、この辞書内で定義されている属性は異なるメカニズムで継承されます)。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_descr_get">
descrgetfunc <code class="descname">PyTypeObject.tp_descr_get</code><a class="headerlink" href="#c.PyTypeObject.tp_descr_get" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、 &quot;デスクリプタ get&quot; 関数を指します。</p>
<p>関数のシグネチャは次のとおりです</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span> <span class="nf">tp_descr_get</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
</pre></div>
</div>
<p>サブタイプはこのフィールドを継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_descr_set">
descrsetfunc <code class="descname">PyTypeObject.tp_descr_set</code><a class="headerlink" href="#c.PyTypeObject.tp_descr_set" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのポインタで、デスクリプタの値の設定と削除を行う関数を指します。</p>
<p>関数のシグネチャは次のとおりです</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">tp_descr_set</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p><em>value</em> 引数に <em>NULL</em> を設定して値を消します。このフィールドはサブタイプに継承されます。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_dictoffset">
long <code class="descname">PyTypeObject.tp_dictoffset</code><a class="headerlink" href="#c.PyTypeObject.tp_dictoffset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>型のインスタンスにインスタンス変数の入った辞書がある場合、このフィールドは非ゼロの値になり、型のインスタンスデータ構造体におけるインスタンス変数辞書へのオフセットが入ります; このオフセット値は <a class="reference internal" href="object.html#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GenericGetAttr()</span></code></a> が使います。</p>
<p>このフィールドを <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal"><span class="pre">tp_dict</span></code></a> と混同しないようにしてください; これは型オブジェクト自身の属性の辞書です。</p>
<p>このフィールドの値がゼロより大きければ、値はインスタンス構造体の先頭からの オフセットを表します。値がゼロより小さければ、インスタンス構造体の <em>末尾</em> からのオフセットを表します。負のオフセットを使うコストは比較的高くつくので、 インスタンス構造体に可変長部分があるときのみ使うべきです。例えば、 <a class="reference internal" href="../library/functions.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> や <a class="reference internal" href="../library/functions.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> のサブタイプにインスタンス変数の辞書を追加する場合には、負のオフセットを使います。この場合、たとえ辞書が基本のオブジェクトレイアウトに含まれていなくても、 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal"><span class="pre">tp_basicsize</span></code></a> フィールドは追加された辞書を考慮にいれなければならないことに注意してください。ポインタサイズが 4 バイトのシステムでは、 構造体の最後尾に辞書が宣言されていることを示す場合、 <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_dictoffset</span></code></a> を <code class="docutils literal"><span class="pre">-4</span></code> にしなければなりません。</p>
<p>負の <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_dictoffset</span></code></a> から、インスタンスでの実際のオフセットを計算するには以下のようにします:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">dictoffset</span> <span class="o">=</span> <span class="n">tp_basicsize</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">ob_size</span><span class="p">)</span><span class="o">*</span><span class="n">tp_itemsize</span> <span class="o">+</span> <span class="n">tp_dictoffset</span>
<span class="k">if</span> <span class="n">dictoffset</span> <span class="n">is</span> <span class="n">not</span> <span class="n">aligned</span> <span class="n">on</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">:</span>
    <span class="n">round</span> <span class="n">up</span> <span class="n">to</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで、 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal"><span class="pre">tp_basicsize</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal"><span class="pre">tp_itemsize</span></code></a> および <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_dictoffset</span></code></a> は型オブジェクトから取り出され、 <code class="xref py py-attr docutils literal"><span class="pre">ob_size</span></code> はインスタンスから取り出されます。長整数は符号を記憶するのに <code class="xref py py-attr docutils literal"><span class="pre">ob_size</span></code> の符号を使うため、 <code class="xref py py-attr docutils literal"><span class="pre">ob_size</span></code> は絶対値を使います。(この計算を自分で行う必要はまったくありません; <code class="xref c c-func docutils literal"><span class="pre">_PyObject_GetDictPtr()</span></code> がやってくれます。)</p>
<p>このフィールドはサブタイプに継承されますが、以下の規則を読んでください。サブタイプはこのオフセット値をオーバライドすることがあります; 従って、サブタイプでは辞書のオフセットが基底タイプとは異なる場合があります。辞書のオフセットは常に <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_dictoffset</span></code></a> で分かるはずなので、このことは問題にはならないはずです。</p>
<p><a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> 文で定義された型に <code class="xref py py-attr docutils literal"><span class="pre">__slots__</span></code> 宣言がなく、かつ基底タイプの全てにインスタンス変数辞書がない場合、辞書のスロットをインスタンスデータレイアウト構造体に追加し、スロットのオフセットを <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_dictoffset</span></code></a> に設定します。</p>
<p><a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> 文で定義された型に <a class="reference internal" href="../reference/datamodel.html#__slots__" title="__slots__"><code class="xref py py-attr docutils literal"><span class="pre">__slots__</span></code></a> 宣言がある場合、この型は基底タイプから <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_dictoffset</span></code></a> を継承します。</p>
<p>(<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> という名前のスロットを <a class="reference internal" href="../reference/datamodel.html#__slots__" title="__slots__"><code class="xref py py-attr docutils literal"><span class="pre">__slots__</span></code></a> 宣言に追加しても、期待どおりの効果は得られず、単に混乱を招くだけになります。とはいえ、これは将来 <code class="xref py py-attr docutils literal"><span class="pre">__weakref__</span></code> のように追加されるはずです。)</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_init">
initproc <code class="descname">PyTypeObject.tp_init</code><a class="headerlink" href="#c.PyTypeObject.tp_init" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、インスタンス初期化関数を指します。</p>
<p>この関数はクラスにおける <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドに対応します。 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> と同様、 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> を呼び出さずにインスタンスを作成できます。また、 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> を再度呼び出してインスタンスの再初期化もできます。</p>
<p>関数のシグネチャは次のとおりです</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">tp_init</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
</pre></div>
</div>
<p><em>self</em> 引数は初期化するインスタンスです; <em>args</em> および <em>kwds</em> 引数は、 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> を呼び出す際の固定引数およびキーワード引数です。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a> 関数のフィールドが <em>NULL</em> でない場合、型の呼び出しで普通にインスタンスを生成する際に、型の <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> がインスタンスを返した後に <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a> が呼び出されます。 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> が元の型のサブタイプでない別の型を返す場合、 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a> は全く呼び出されません; <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> が元の型のサブタイプのインスタンスを返す場合、サブタイプの <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a> が呼び出されます。 (VERSION NOTE: ここに書かれている内容は、Python 2.2.1 以降での実装に関するものです。Python 2.2 では、 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a> は <em>NULL</em> でない限り <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> が返す全てのオブジェクトに対して常に呼び出されます。) not <em>NULL</em>.)</p>
<p>サブタイプはこのフィールドを継承します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_alloc">
allocfunc <code class="descname">PyTypeObject.tp_alloc</code><a class="headerlink" href="#c.PyTypeObject.tp_alloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、インスタンスのメモリ確保関数を指します。</p>
<p>関数のシグネチャは次のとおりです</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="n">nitems</span><span class="p">)</span>
</pre></div>
</div>
<p>この関数の目的は、メモリ確保をメモリ初期化から分離することにあります。この関数は、インスタンス用の的確なサイズ、適切なアラインメント、ゼロによる初期化がなされ、 <code class="xref py py-attr docutils literal"><span class="pre">ob_refcnt</span></code> を <code class="docutils literal"><span class="pre">1</span></code> に、 <code class="xref py py-attr docutils literal"><span class="pre">ob_type</span></code> を型引数 (type argument) にセットしたメモリブロックへのポインタを返さねばなりません。型の <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal"><span class="pre">tp_itemsize</span></code></a> がゼロでない場合、オブジェクトの <code class="xref py py-attr docutils literal"><span class="pre">ob_size</span></code> フィールドは <em>nitems</em> に初期化され、確保されるメモリブロックの長さは <code class="docutils literal"><span class="pre">tp_basicsize</span> <span class="pre">+</span> <span class="pre">nitems*tp_itemsize</span></code> を <code class="docutils literal"><span class="pre">sizeof(void*)</span></code> の倍数に切り上げた値になるはずです; それ以外の場合、 <em>nitems</em> の値は使われず、メモリブロックの長さは <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal"><span class="pre">tp_basicsize</span></code></a> になるはずです。</p>
<p>この関数をインスタンス初期化の他のどの処理にも、追加でメモリ確保をする場合でさえ使ってはなりません; そうした処理は <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> で行わねばなりません。</p>
<p>静的なサブタイプはこのフィールドを継承しますが、動的なサブタイプ (<a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> 文で生成するサブタイプ) の場合は継承しません; 後者の場合、このフィールドは常に <a class="reference internal" href="type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal"><span class="pre">PyType_GenericAlloc()</span></code></a> にセットされ、標準のヒープ上メモリ確保戦略が強制されます。静的に定義する型の場合でも、 <a class="reference internal" href="type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal"><span class="pre">PyType_GenericAlloc()</span></code></a> を推奨します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_new">
newfunc <code class="descname">PyTypeObject.tp_new</code><a class="headerlink" href="#c.PyTypeObject.tp_new" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、インスタンス生成関数を指します。</p>
<p>このフィールドが <em>NULL</em> を指している型では、型を呼び出して新たなインスタンスを生成できません; こうした型では、おそらくファクトリ関数のように、インスタンスを生成する他の方法があるはずです。</p>
<p>関数のシグネチャは次のとおりです</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">subtype</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
</pre></div>
</div>
<p><em>subtype</em> 引数は生成するオブジェクトの型です; <em>args</em> および <em>kwds</em> 引数は、型を呼び出すときの位置引数およびキーワード引数です。サブタイプは <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> 関数を呼び出すときに使う型と同じである必要はないことに注意してください; その型の (無関係ではない) サブタイプのこともあります。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> 関数は <code class="docutils literal"><span class="pre">subtype-&gt;tp_alloc(subtype,</span> <span class="pre">nitems)</span></code> を呼び出してオブジェクトのメモリ領域を確保し、初期化で絶対に必要とされる処理だけを行います。省略したり繰り返したりしても問題のない初期化処理は <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a> ハンドラ内に配置しなければなりません。だいたいの目安としては、変更不能な型では初期化は全て <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> で行い、一方、変更可能な型ではほとんどの初期化を <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a> に回すべきです。</p>
<p>サブタイプはこのフィールドを継承します。例外として、 <a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal"><span class="pre">tp_base</span></code></a> が <em>NULL</em> か <code class="docutils literal"><span class="pre">&amp;PyBaseObject_Type</span></code> になっている静的な型では継承しません。後者が例外になっているのは、旧式の拡張型が Python 2.2 でリンクされたときに呼び出し可能オブジェクトにならないようにするための予防措置です。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_free">
destructor <code class="descname">PyTypeObject.tp_free</code><a class="headerlink" href="#c.PyTypeObject.tp_free" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、インスタンスのメモリ解放関数を指します。</p>
<p>この関数のシグネチャは少し変更されています; Python 2.2 および 2.2.1 では、シグネチャは <code class="xref c c-type docutils literal"><span class="pre">destructor</span></code></p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">tp_free</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p>でしたが、 Python 2.3 以降では、シグネチャは <code class="xref c c-type docutils literal"><span class="pre">freefunc</span></code> になっています:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">tp_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p>両方のバージョンと互換性のある初期値は <code class="docutils literal"><span class="pre">_PyObject_Del</span></code> です。 <code class="docutils literal"><span class="pre">_PyObject_Del</span></code> の定義は Python 2.3 で適切に対応できるよう変更されました。</p>
<p>静的なサブタイプはこのフィールドを継承しますが、動的なサブタイプ (<a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> 文で生成するサブタイプ) の場合は継承しません; 後者の場合、このフィールドには <a class="reference internal" href="type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal"><span class="pre">PyType_GenericAlloc()</span></code></a> と <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> フラグビットの値に対応させるのにふさわしいメモリ解放関数がセットされます。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_is_gc">
<a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry">inquiry</a> <code class="descname">PyTypeObject.tp_is_gc</code><a class="headerlink" href="#c.PyTypeObject.tp_is_gc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのフィールドです。ポインタで、ガベージコレクタから呼び出される関数を指します。</p>
<p>ガベージコレクタは、オブジェクトを回収して良いかどうかを知る必要があります。通常は、オブジェクトの型の <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal"><span class="pre">tp_flags</span></code></a> フィールドを見て、 <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> フラグビットを調べるだけで十分です。しかし、ある型では静的にメモリ確保されたインスタンスと動的にメモリ確保されたインスタンスが混じっていて、静的にメモリ確保されたインスタンスは回収できません。こうした型では、関数を定義しなければなりません; 関数はインスタンスが回収可能の場合には <code class="docutils literal"><span class="pre">1</span></code> を、回収不能の場合には <code class="docutils literal"><span class="pre">0</span></code> を返さねばなりません。シグネチャは</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">tp_is_gc</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
</pre></div>
</div>
<p>(上記のような型の例は、型オブジェクト自体です。メタタイプ <a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code class="xref c c-data docutils literal"><span class="pre">PyType_Type</span></code></a> は、型のメモリ確保が静的か動的かを区別するためにこの関数を定義しています。)</p>
<p>サブタイプはこのフィールドを継承します。 (VERSION NOTE: Python 2.2 では、このフィールドは継承されませんでした。 2.2.1 以降のバージョンから継承されるようになりました。)</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_bases">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyTypeObject.tp_bases</code><a class="headerlink" href="#c.PyTypeObject.tp_bases" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>基底型からなるタプルです。</p>
<p><a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> 文で生成されたクラスの場合このフィールドがセットされます。静的に定義されている型の場合には、このフィールドは <em>NULL</em> になります。</p>
<p>このフィールドは継承されません。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_mro">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyTypeObject.tp_mro</code><a class="headerlink" href="#c.PyTypeObject.tp_mro" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>基底タイプ群を展開した集合が入っているタプルです。集合は該当する型自体からはじまり、 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> で終わります。メソッド解決順序 (Method Resolution Order) に従って並んでいます。</p>
<p>このフィールドは継承されません; フィールドの値は <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> で毎回計算されます。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_cache">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyTypeObject.tp_cache</code><a class="headerlink" href="#c.PyTypeObject.tp_cache" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>使用されていません。継承されません。内部で使用するためだけのものです。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_subclasses">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyTypeObject.tp_subclasses</code><a class="headerlink" href="#c.PyTypeObject.tp_subclasses" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サブクラスへの弱参照からなるリストです。継承されません。内部で使用するためだけのものです。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_weaklist">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyTypeObject.tp_weaklist</code><a class="headerlink" href="#c.PyTypeObject.tp_weaklist" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この型オブジェクトに対する弱参照からなるリストの先頭です。</p>
</dd></dl>

<p>The remaining fields are only defined if the feature test macro
<code class="xref py py-const docutils literal"><span class="pre">COUNT_ALLOCS</span></code> is defined, and are for internal use only. They are
documented here for completeness.  None of these fields are inherited by
subtypes. See the <span class="target" id="index-3"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONSHOWALLOCCOUNT"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONSHOWALLOCCOUNT</span></code></a> environment variable.</p>
<dl class="member">
<dt id="c.PyTypeObject.tp_allocs">
Py_ssize_t <code class="descname">PyTypeObject.tp_allocs</code><a class="headerlink" href="#c.PyTypeObject.tp_allocs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリ確保の回数です。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_frees">
Py_ssize_t <code class="descname">PyTypeObject.tp_frees</code><a class="headerlink" href="#c.PyTypeObject.tp_frees" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリ解放の回数です。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_maxalloc">
Py_ssize_t <code class="descname">PyTypeObject.tp_maxalloc</code><a class="headerlink" href="#c.PyTypeObject.tp_maxalloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>同時にメモリ確保できる最大オブジェクト数です。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_next">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a>* <code class="descname">PyTypeObject.tp_next</code><a class="headerlink" href="#c.PyTypeObject.tp_next" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>次のゼロでない <a class="reference internal" href="#c.PyTypeObject.tp_allocs" title="PyTypeObject.tp_allocs"><code class="xref c c-member docutils literal"><span class="pre">tp_allocs</span></code></a> フィールドを持つ型オブジェクトへのポインタです。</p>
</dd></dl>

<p>また、 Python のガベージコレクションでは、 <em>tp_dealloc</em> を呼び出すのはオブジェクトを生成したスレッドだけではなく、任意の Python スレッドかもしれないという点にも注意して下さい。 (オブジェクトが循環参照の一部の場合、任意のスレッドのガベージコレクションによって解放されてしまうかもしれません)。Python API 側からみれば、 <em>tp_dealloc</em> を呼び出すスレッドはグローバルインタプリタロック (GIL: Global Interpreter Lock) を獲得するので、これは問題ではありません。しかしながら、削除されようとしているオブジェクトが何らかの C や C++ ライブラリ由来のオブジェクトを削除する場合、 <em>tp_dealloc</em> を呼び出すスレッドのオブジェクトを削除することで、ライブラリの仮定している何らかの規約に違反しないように気を付ける必要があります。</p>
</div>
<div class="section" id="number-object-structures">
<span id="number-structs"></span><h1>数値オブジェクト構造体<a class="headerlink" href="#number-object-structures" title="このヘッドラインへのパーマリンク">¶</a></h1>
<dl class="type">
<dt id="c.PyNumberMethods">
<code class="descname">PyNumberMethods</code><a class="headerlink" href="#c.PyNumberMethods" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>拡張型で数値型プロトコルを実装するために使われる関数群へのポインタを保持するために使われる構造体です。以下のほとんどすべての関数は <a class="reference internal" href="number.html#number"><span class="std std-ref">数値型プロトコル (number protocol)</span></a> で解説されている似た名前の関数から利用されます。</p>
<p>以下は構造体の定義です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
     <span class="n">binaryfunc</span> <span class="n">nb_add</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_subtract</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_multiply</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_divide</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_remainder</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_divmod</span><span class="p">;</span>
     <span class="n">ternaryfunc</span> <span class="n">nb_power</span><span class="p">;</span>
     <span class="n">unaryfunc</span> <span class="n">nb_negative</span><span class="p">;</span>
     <span class="n">unaryfunc</span> <span class="n">nb_positive</span><span class="p">;</span>
     <span class="n">unaryfunc</span> <span class="n">nb_absolute</span><span class="p">;</span>
     <span class="n">inquiry</span> <span class="n">nb_nonzero</span><span class="p">;</span>       <span class="cm">/* Used by PyObject_IsTrue */</span>
     <span class="n">unaryfunc</span> <span class="n">nb_invert</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_lshift</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_rshift</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_and</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_xor</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_or</span><span class="p">;</span>
     <span class="n">coercion</span> <span class="n">nb_coerce</span><span class="p">;</span>       <span class="cm">/* Used by the coerce() function */</span>
     <span class="n">unaryfunc</span> <span class="n">nb_int</span><span class="p">;</span>
     <span class="n">unaryfunc</span> <span class="n">nb_long</span><span class="p">;</span>
     <span class="n">unaryfunc</span> <span class="n">nb_float</span><span class="p">;</span>
     <span class="n">unaryfunc</span> <span class="n">nb_oct</span><span class="p">;</span>
     <span class="n">unaryfunc</span> <span class="n">nb_hex</span><span class="p">;</span>

     <span class="cm">/* Added in release 2.0 */</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_add</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_subtract</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_multiply</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_divide</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_remainder</span><span class="p">;</span>
     <span class="n">ternaryfunc</span> <span class="n">nb_inplace_power</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_lshift</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_rshift</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_and</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_xor</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_or</span><span class="p">;</span>

     <span class="cm">/* Added in release 2.2 */</span>
     <span class="n">binaryfunc</span> <span class="n">nb_floor_divide</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_true_divide</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_floor_divide</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_true_divide</span><span class="p">;</span>

     <span class="cm">/* Added in release 2.5 */</span>
     <span class="n">unaryfunc</span> <span class="n">nb_index</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyNumberMethods</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<p>2引数および3引数の関数は、 <a class="reference internal" href="#Py_TPFLAGS_CHECKTYPES" title="Py_TPFLAGS_CHECKTYPES"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_CHECKTYPES</span></code></a> フラグによっては、異なる種類の引数を受け取るかもしれません。</p>
<ul>
<li><p class="first"><a class="reference internal" href="#Py_TPFLAGS_CHECKTYPES" title="Py_TPFLAGS_CHECKTYPES"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_CHECKTYPES</span></code></a> がセットされていない場合、関数の引数はオブジェクトの型であることが保証されます。呼び出し側は <code class="xref py py-attr docutils literal"><span class="pre">nb_coerce</span></code> メンバで指定されている型強制メソッドを呼び出して引数を変換する責任があります。</p>
<dl class="member">
<dt id="c.PyNumberMethods.nb_coerce">
coercion <code class="descname">PyNumberMethods.nb_coerce</code><a class="headerlink" href="#c.PyNumberMethods.nb_coerce" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="number.html#c.PyNumber_CoerceEx" title="PyNumber_CoerceEx"><code class="xref c c-func docutils literal"><span class="pre">PyNumber_CoerceEx()</span></code></a> から利用され、同じシグネチャを持ちます。最初の引数は定義された型のオブジェクトを指すポインタでなければなりません。共通の &quot;大きな&quot; 型への変換が可能であれば、この関数はポインタを変換後のオブジェクトへの新しい参照へ置き換えて、 <code class="docutils literal"><span class="pre">0</span></code> を返します。変換ができないなら、この関数は <code class="docutils literal"><span class="pre">1</span></code> を返します。エラーが設定荒れた場合は、 <code class="docutils literal"><span class="pre">-1</span></code> を返します。</p>
</dd></dl>

</li>
<li><p class="first"><a class="reference internal" href="#Py_TPFLAGS_CHECKTYPES" title="Py_TPFLAGS_CHECKTYPES"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_CHECKTYPES</span></code></a> フラグがセットされている場合、2引数および 3引数関数はすべてのオペランドの型をチェクし、必要な変換を行わなければなりません。 (少なくとも、オペランドのうち1つは定義している型のものです) これは推奨された方式です。 Python 3 では型強制は完全に取り除かれています。</p>
</li>
</ul>
<p>与えられたオペランドに対して操作が定義されていな場合は、2引数および3引数関数は <code class="docutils literal"><span class="pre">Py_NotImplemented</span></code> を返さなければなりません。その他のエラーが発生した場合は、例外を設定して <code class="docutils literal"><span class="pre">NULL</span></code> を返さなければなりません。</p>
</div>
<div class="section" id="mapping-object-structures">
<span id="mapping-structs"></span><h1>マップ型オブジェクト構造体<a class="headerlink" href="#mapping-object-structures" title="このヘッドラインへのパーマリンク">¶</a></h1>
<dl class="type">
<dt id="c.PyMappingMethods">
<code class="descname">PyMappingMethods</code><a class="headerlink" href="#c.PyMappingMethods" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>拡張型でマップ型プロトコルを実装するために使われる関数群へのポインタを保持するために使われる構造体です。以下の3つのメンバを持っています:</p>
</dd></dl>

<dl class="member">
<dt id="c.PyMappingMethods.mp_length">
lenfunc <code class="descname">PyMappingMethods.mp_length</code><a class="headerlink" href="#c.PyMappingMethods.mp_length" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="mapping.html#c.PyMapping_Length" title="PyMapping_Length"><code class="xref c c-func docutils literal"><span class="pre">PyMapping_Length()</span></code></a> や <a class="reference internal" href="object.html#c.PyObject_Size" title="PyObject_Size"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Size()</span></code></a> から利用され、それらと同じシグネチャを持っています。オブジェクトが定義された長さを持たない場合は、このスロットは <em>NULL</em> に設定されることがあります。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyMappingMethods.mp_subscript">
binaryfunc <code class="descname">PyMappingMethods.mp_subscript</code><a class="headerlink" href="#c.PyMappingMethods.mp_subscript" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="object.html#c.PyObject_GetItem" title="PyObject_GetItem"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GetItem()</span></code></a> から利用され、同じシグネチャを持っています。このスロットは <a class="reference internal" href="mapping.html#c.PyMapping_Check" title="PyMapping_Check"><code class="xref c c-func docutils literal"><span class="pre">PyMapping_Check()</span></code></a> が <code class="docutils literal"><span class="pre">1</span></code> を返すためには必要で、そうでなければ <em>NULL</em> の場合があります。</p>
</dd></dl>

<dl class="member">
<dt id="c.PyMappingMethods.mp_ass_subscript">
objobjargproc <code class="descname">PyMappingMethods.mp_ass_subscript</code><a class="headerlink" href="#c.PyMappingMethods.mp_ass_subscript" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="object.html#c.PyObject_SetItem" title="PyObject_SetItem"><code class="xref c c-func docutils literal"><span class="pre">PyObject_SetItem()</span></code></a> および <a class="reference internal" href="object.html#c.PyObject_DelItem" title="PyObject_DelItem"><code class="xref c c-func docutils literal"><span class="pre">PyObject_DelItem()</span></code></a> から利用されます。
<a class="reference internal" href="object.html#c.PyObject_SetItem" title="PyObject_SetItem"><code class="xref c c-func docutils literal"><span class="pre">PyObject_SetItem()</span></code></a> と同じシグネチャを持ちますが、 <em>v</em> に <em>NULL</em> を設定して要素の削除もできます。このスロットが <em>NULL</em> の場合は、このオブジェクトはアイテムの代入と削除をサポートしません。</p>
</dd></dl>

</div>
<div class="section" id="sequence-object-structures">
<span id="sequence-structs"></span><h1>シーケンスオブジェクト構造体<a class="headerlink" href="#sequence-object-structures" title="このヘッドラインへのパーマリンク">¶</a></h1>
<dl class="type">
<dt id="c.PySequenceMethods">
<code class="descname">PySequenceMethods</code><a class="headerlink" href="#c.PySequenceMethods" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>拡張型でシーケンス型プロトコルを実装するために使われる関数群へのポインタを保持するために使われる構造体です。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_length">
lenfunc <code class="descname">PySequenceMethods.sq_length</code><a class="headerlink" href="#c.PySequenceMethods.sq_length" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="sequence.html#c.PySequence_Size" title="PySequence_Size"><code class="xref c c-func docutils literal"><span class="pre">PySequence_Size()</span></code></a> や <a class="reference internal" href="object.html#c.PyObject_Size" title="PyObject_Size"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Size()</span></code></a> から利用され、それらと同じシグネチャを持っています。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_concat">
binaryfunc <code class="descname">PySequenceMethods.sq_concat</code><a class="headerlink" href="#c.PySequenceMethods.sq_concat" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="sequence.html#c.PySequence_Concat" title="PySequence_Concat"><code class="xref c c-func docutils literal"><span class="pre">PySequence_Concat()</span></code></a> で利用され、同じシグネチャを持っています。また、 <code class="docutils literal"><span class="pre">+</span></code> 演算子でも、 <code class="xref c c-member docutils literal"><span class="pre">nb_add</span></code> スロットによる数値加算を試した後に利用されます。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_repeat">
ssizeargfunc <code class="descname">PySequenceMethods.sq_repeat</code><a class="headerlink" href="#c.PySequenceMethods.sq_repeat" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="sequence.html#c.PySequence_Repeat" title="PySequence_Repeat"><code class="xref c c-func docutils literal"><span class="pre">PySequence_Repeat()</span></code></a> で利用され、同じシグネチャを持っています。また、 <code class="docutils literal"><span class="pre">*</span></code> 演算でも、 <code class="xref c c-member docutils literal"><span class="pre">nb_multiply</span></code> スロットによる数値乗算を試したあとに利用されます。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_item">
ssizeargfunc <code class="descname">PySequenceMethods.sq_item</code><a class="headerlink" href="#c.PySequenceMethods.sq_item" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="sequence.html#c.PySequence_GetItem" title="PySequence_GetItem"><code class="xref c c-func docutils literal"><span class="pre">PySequence_GetItem()</span></code></a> から利用され、同じシグネチャを持っています。このスロットは <a class="reference internal" href="sequence.html#c.PySequence_Check" title="PySequence_Check"><code class="xref c c-func docutils literal"><span class="pre">PySequence_Check()</span></code></a> が <code class="docutils literal"><span class="pre">1</span></code> を返すためには埋めなければならず、それ以外の場合は <em>NULL</em> の可能性があります。</p>
<p>負のインデックスは次のように処理されます: <code class="xref py py-attr docutils literal"><span class="pre">sq_length</span></code> スロットが埋められていれば、それを呼び出してシーケンスの長さから正のインデックスを計算し、 <code class="xref py py-attr docutils literal"><span class="pre">sq_item</span></code> に渡します。 <code class="xref py py-attr docutils literal"><span class="pre">sq_length</span></code> が <em>NULL</em> の場合は、インデックスはそのままこの関数に渡されます。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_ass_item">
ssizeobjargproc <code class="descname">PySequenceMethods.sq_ass_item</code><a class="headerlink" href="#c.PySequenceMethods.sq_ass_item" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="sequence.html#c.PySequence_SetItem" title="PySequence_SetItem"><code class="xref c c-func docutils literal"><span class="pre">PySequence_SetItem()</span></code></a> から利用され、同じシグネチャを持っています。オブジェクトが要素の代入と削除をサポートしていない場合は、このスロットは <em>NULL</em> かもしれません。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_contains">
objobjproc <code class="descname">PySequenceMethods.sq_contains</code><a class="headerlink" href="#c.PySequenceMethods.sq_contains" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="sequence.html#c.PySequence_Contains" title="PySequence_Contains"><code class="xref c c-func docutils literal"><span class="pre">PySequence_Contains()</span></code></a> から利用され、同じシグネチャを持っています。このスロットは <em>NULL</em> の場合があり、その時 <a class="reference internal" href="sequence.html#c.PySequence_Contains" title="PySequence_Contains"><code class="xref c c-func docutils literal"><span class="pre">PySequence_Contains()</span></code></a> はシンプルにマッチするオブジェクトを見つけるまでシーケンスを巡回します。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_inplace_concat">
binaryfunc <code class="descname">PySequenceMethods.sq_inplace_concat</code><a class="headerlink" href="#c.PySequenceMethods.sq_inplace_concat" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="sequence.html#c.PySequence_InPlaceConcat" title="PySequence_InPlaceConcat"><code class="xref c c-func docutils literal"><span class="pre">PySequence_InPlaceConcat()</span></code></a> から利用され、同じシグネチャを持っています。この関数は最初のオペランドを修正してそれを返すべきです。</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_inplace_repeat">
ssizeargfunc <code class="descname">PySequenceMethods.sq_inplace_repeat</code><a class="headerlink" href="#c.PySequenceMethods.sq_inplace_repeat" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="sequence.html#c.PySequence_InPlaceRepeat" title="PySequence_InPlaceRepeat"><code class="xref c c-func docutils literal"><span class="pre">PySequence_InPlaceRepeat()</span></code></a> から利用され、同じシグネチャを持っています。この関数は最初のオペランドを修正してそれを返すべきです。</p>
</dd></dl>

</div>
<div class="section" id="buffer-object-structures">
<span id="buffer-structs"></span><h1>バッファオブジェクト構造体 (buffer object structure)<a class="headerlink" href="#buffer-object-structures" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>バッファインタフェースは、あるオブジェクトの内部データを一連のデータチャンク (chunk) として見せるモデルを外部から利用できるようにします。各チャンクはポインタ/データ長からなるペアで指定します。チャンクはセグメント(<em class="dfn">segment</em>) と呼ばれ、メモリ内に不連続的に配置されるものと想定されています。</p>
<p>バッファインタフェースを利用できるようにしたくないオブジェクトでは、 <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></code></a> 構造体の <a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal"><span class="pre">tp_as_buffer</span></code></a> メンバを <em>NULL</em> にしなくてはなりません。利用できるようにする場合、 <a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal"><span class="pre">tp_as_buffer</span></code></a> は <a class="reference internal" href="#c.PyBufferProcs" title="PyBufferProcs"><code class="xref c c-type docutils literal"><span class="pre">PyBufferProcs</span></code></a> 構造体を指さねばなりません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></code></a> 構造体の <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal"><span class="pre">tp_flags</span></code></a> メンバの値を <code class="docutils literal"><span class="pre">0</span></code> でなく <a class="reference internal" href="#Py_TPFLAGS_DEFAULT" title="Py_TPFLAGS_DEFAULT"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_DEFAULT</span></code></a> にしておくことがとても重要です。この設定は、 <a class="reference internal" href="#c.PyBufferProcs" title="PyBufferProcs"><code class="xref c c-type docutils literal"><span class="pre">PyBufferProcs</span></code></a> 構造体に <code class="xref py py-attr docutils literal"><span class="pre">bf_getcharbuffer</span></code> スロットが入っていることを Python ランタイムに教えます。 Python の古いバージョンには <code class="xref py py-attr docutils literal"><span class="pre">bf_getcharbuffer</span></code> メンバが存在しないので、古い拡張モジュールを使おうとしている新しいバージョンの Python インタプリタは、このメンバがあるかどうかテストしてから使えるようにする必要があるのです。</p>
</div>
<dl class="type">
<dt id="c.PyBufferProcs">
<code class="descname">PyBufferProcs</code><a class="headerlink" href="#c.PyBufferProcs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バッファプロトコルの実装を定義している関数群へのポインタを保持するのに使われる構造体です。</p>
<p>The first slot is <code class="xref py py-attr docutils literal"><span class="pre">bf_getreadbuffer</span></code>, of type <a class="reference internal" href="#c.readbufferproc" title="readbufferproc"><code class="xref c c-type docutils literal"><span class="pre">readbufferproc</span></code></a>.
If this slot is <em>NULL</em>, then the object does not support reading from the
internal data.  This is non-sensical, so implementors should fill this in, but
callers should test that the slot contains a non-<em>NULL</em> value.</p>
<p>The next slot is <code class="xref py py-attr docutils literal"><span class="pre">bf_getwritebuffer</span></code> having type
<a class="reference internal" href="#c.writebufferproc" title="writebufferproc"><code class="xref c c-type docutils literal"><span class="pre">writebufferproc</span></code></a>.  This slot may be <em>NULL</em> if the object does not
allow writing into its returned buffers.</p>
<p>The third slot is <code class="xref py py-attr docutils literal"><span class="pre">bf_getsegcount</span></code>, with type <a class="reference internal" href="#c.segcountproc" title="segcountproc"><code class="xref c c-type docutils literal"><span class="pre">segcountproc</span></code></a>.
This slot must not be <em>NULL</em> and is used to inform the caller how many segments
the object contains.  Simple objects such as <a class="reference internal" href="string.html#c.PyString_Type" title="PyString_Type"><code class="xref c c-type docutils literal"><span class="pre">PyString_Type</span></code></a> and
<a class="reference internal" href="buffer.html#c.PyBuffer_Type" title="PyBuffer_Type"><code class="xref c c-type docutils literal"><span class="pre">PyBuffer_Type</span></code></a> objects contain a single segment.</p>
<p id="index-4">The last slot is <code class="xref py py-attr docutils literal"><span class="pre">bf_getcharbuffer</span></code>, of type <a class="reference internal" href="#c.charbufferproc" title="charbufferproc"><code class="xref c c-type docutils literal"><span class="pre">charbufferproc</span></code></a>.
This slot will only be present if the <a class="reference internal" href="#Py_TPFLAGS_HAVE_GETCHARBUFFER" title="Py_TPFLAGS_HAVE_GETCHARBUFFER"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GETCHARBUFFER</span></code></a>
flag is present in the <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal"><span class="pre">tp_flags</span></code></a> field of the object’s
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></code></a>. Before using this slot, the caller should test whether it
is present by using the <a class="reference internal" href="type.html#c.PyType_HasFeature" title="PyType_HasFeature"><code class="xref c c-func docutils literal"><span class="pre">PyType_HasFeature()</span></code></a> function.  If the flag is
present, <code class="xref py py-attr docutils literal"><span class="pre">bf_getcharbuffer</span></code> may be <em>NULL</em>, indicating that the object’s
contents cannot be used as <em>8-bit characters</em>. The slot function may also raise
an error if the object’s contents cannot be interpreted as 8-bit characters.
For example, if the object is an array which is configured to hold floating
point values, an exception may be raised if a caller attempts to use
<code class="xref py py-attr docutils literal"><span class="pre">bf_getcharbuffer</span></code> to fetch a sequence of 8-bit characters. This notion of
exporting the internal buffers as &quot;text&quot; is used to distinguish between objects
that are binary in nature, and those which have character-based content.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">現在のポリシでは、文字 (character) はマルチバイト文字でもかまわないと決めているように思われます。従って、サイズ <em>N</em> のバッファが <em>N</em> 個のキャラクタからなるとはかぎらないことになります。</p>
</div>
</dd></dl>

<dl class="data">
<dt>
<code class="descname">Py_TPFLAGS_HAVE_GETCHARBUFFER</code></dt>
<dd><p>型構造体中のフラグビットで、 <code class="xref py py-attr docutils literal"><span class="pre">bf_getcharbuffer</span></code> スロットが既知の値になっていることを示します。このフラグビットがセットされていたとしても、オブジェクトがバッファインタフェースをサポートしていることや、 <code class="xref py py-attr docutils literal"><span class="pre">bf_getcharbuffer</span></code> スロットが <em>NULL</em> でないことを示すわけではありません。</p>
</dd></dl>

<dl class="type">
<dt id="c.readbufferproc">
Py_ssize_t <code class="descname">(*readbufferproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*self</em>, Py_ssize_t<em>&nbsp;segment</em>, void<em>&nbsp;**ptrptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.readbufferproc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">*ptrptr</span></code> の中の読み出し可能なバッファセグメントへのポインタを返します。この関数は例外を送出してもよく、送出する場合には <code class="docutils literal"><span class="pre">-1</span></code> を返さねばなりません。 <em>segment</em> に渡す値はゼロまたは正の値で、 <code class="xref py py-attr docutils literal"><span class="pre">bf_getsegcount</span></code> スロット関数が返すセグメント数よりも必ず小さな値でなければなりません。成功すると、セグメントのサイズを返し、 <code class="docutils literal"><span class="pre">*ptrptr</span></code> をそのセグメントを指すポインタ値にセットします。</p>
</dd></dl>

<dl class="type">
<dt id="c.writebufferproc">
Py_ssize_t <code class="descname">(*writebufferproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*self</em>, Py_ssize_t<em>&nbsp;segment</em>, void<em>&nbsp;**ptrptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.writebufferproc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>読み出し可能なバッファセグメントへのポインタを <code class="docutils literal"><span class="pre">*ptrptr</span></code> に返し、セグメントの長さを関数の戻り値として返します。エラーによる例外の場合には <code class="docutils literal"><span class="pre">-1</span></code> を <code class="docutils literal"><span class="pre">-1</span></code> を返さねばなりません。オブジェクトが呼び出し専用バッファしかサポートしていない場合には <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を、 <em>segment</em> が存在しないセグメントを指している場合には <a class="reference internal" href="../library/exceptions.html#exceptions.SystemError" title="exceptions.SystemError"><code class="xref py py-exc docutils literal"><span class="pre">SystemError</span></code></a> を送出しなければなりません。</p>
</dd></dl>

<dl class="type">
<dt id="c.segcountproc">
Py_ssize_t <code class="descname">(*segcountproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*self</em>, Py_ssize_t<em>&nbsp;*lenp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.segcountproc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バッファを構成するメモリセグメントの数を返します。 <em>lenp</em> が <em>NULL</em> でない場合、この関数の実装は全てのセグメントのサイズ (バイト単位) の合計値を <code class="docutils literal"><span class="pre">*lenp</span></code> を介して報告しなければなりません。この関数呼び出しは失敗させられません。</p>
</dd></dl>

<dl class="type">
<dt id="c.charbufferproc">
Py_ssize_t <code class="descname">(*charbufferproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*self</em>, Py_ssize_t<em>&nbsp;segment</em>, char<em>&nbsp;**ptrptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.charbufferproc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>セグメント <em>segment</em> のメモリバッファを <em>ptrptr</em> に入れ、そのサイズを返します。エラーのときに <code class="docutils literal"><span class="pre">-1</span></code> を返します。</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">型オブジェクト</a></li>
<li><a class="reference internal" href="#number-object-structures">数値オブジェクト構造体</a></li>
<li><a class="reference internal" href="#mapping-object-structures">マップ型オブジェクト構造体</a></li>
<li><a class="reference internal" href="#sequence-object-structures">シーケンスオブジェクト構造体</a></li>
<li><a class="reference internal" href="#buffer-object-structures">バッファオブジェクト構造体 (buffer object structure)</a></li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="structures.html"
                        title="前の章へ">共通のオブジェクト構造体 (common object structure)</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="gcsupport.html"
                        title="次の章へ">循環参照ガベージコレクションをサポートする</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">バグ報告</a></li>
  <li><a href="https://github.com/python/cpython/blob/2.7/Doc/c-api/typeobj.rst"
         rel="nofollow">ソースの表示</a>
  </li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="gcsupport.html" title="循環参照ガベージコレクションをサポートする"
             >次へ</a> |</li>
        <li class="right" >
          <a href="structures.html" title="共通のオブジェクト構造体 (common object structure)"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.14</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API リファレンスマニュアル</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="objimpl.html" >オブジェクト実装サポート (object implementation support)</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2018, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト).
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 2018-04-18
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>