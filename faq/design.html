<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>デザインと歴史 FAQ &#8212; Python 2.7.13 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.13',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7.13 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 2.7.13 ドキュメント" href="../contents.html" />
    <link rel="up" title="Python よくある質問" href="index.html" />
    <link rel="next" title="ライブラリと拡張 FAQ" href="library.html" />
    <link rel="prev" title="プログラミング FAQ" href="programming.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/faq/design.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="library.html" title="ライブラリと拡張 FAQ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="programming.html" title="プログラミング FAQ"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.13</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python よくある質問</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="design-and-history-faq">
<h1>デザインと歴史 FAQ<a class="headerlink" href="#design-and-history-faq" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="why-does-python-use-indentation-for-grouping-of-statements">
<h2>Python はなぜ文のグループ化にインデントを使うのですか？<a class="headerlink" href="#why-does-python-use-indentation-for-grouping-of-statements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Guido van Rossum の信じるところによれば、インデントによるグループ化は非常にエレガントで、平均的な Python プログラムを大いに読みやすくします。しばらくすればほとんどの人はこの特徴を気に入るようになります。</p>
<p>開始/終了の括弧がないので、構文解析器と人間の読者の間にグループ化の解釈の違いは起こりえません。時折、C のプログラマはこのようなコード片に出くわします:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">x</span><span class="o">++</span><span class="p">;</span>
        <span class="n">y</span><span class="o">--</span><span class="p">;</span>
<span class="n">z</span><span class="o">++</span><span class="p">;</span>
</pre></div>
</div>
<p>この条件文が真の時のみ実行されるのは <code class="docutils literal"><span class="pre">x++</span></code> 文だけですが、このインデントでは誤解を招きます。経験を積んだ C プログラマでさえ、 <code class="docutils literal"><span class="pre">y</span></code> が <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> の時にもデクリメントされるのはなぜか分からず長いこと立ち止まることがあるでしょう。</p>
<p>開始/終了の括弧がないので、Python はコーディングスタイルの対立が非常に起こりにくくなります。C では多様なカッコの置き方があります。一つのスタイルでのコードの読み書きに慣れてしまうと、他のスタイルを読む (あるいは書く必要がある) ときにむずむずするでしょう。</p>
<p>多くのコーディングスタイルは begin/end の括弧にそれぞれ一行を使います。これではプログラムは冗長になって画面を浪費し、プログラムの見通しが悪くなります。一つの関数は一画面 (例えば 20 から 30 行) に収めるのが理想です。20 行の Python は 20 行の C よりもはるかに多くの作業ができます。これは begin/end の括弧がないからだけではありません &#8211; 宣言が不要なことや高レベルなデータ型もその理由です &#8211; が、インデントに基づく構文は確かに役に立っています。</p>
</div>
<div class="section" id="why-am-i-getting-strange-results-with-simple-arithmetic-operations">
<h2>なぜ単純な算術演算が奇妙な結果になるのですか？<a class="headerlink" href="#why-am-i-getting-strange-results-with-simple-arithmetic-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>次の質問を参照してください。</p>
</div>
<div class="section" id="why-are-floating-point-calculations-so-inaccurate">
<h2>なぜ浮動小数点演算はこれほど不正確なのですか？<a class="headerlink" href="#why-are-floating-point-calculations-so-inaccurate" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このような結果は、よく驚かれたり Python のバグであると考えられたりします:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.2</span> <span class="o">-</span> <span class="mf">1.0</span>
<span class="go">0.19999999999999996</span>
</pre></div>
</div>
<p>でもこれはバグではありません。これは Python ではなく、その基底にある C のプラットフォームによる浮動小数点数の扱い方の問題で、究極には数を固定長の桁に書き下す際に生じたものです。</p>
<p>浮動小数点数の内部表現では一定数の二進数で十進数を示します。二進数では正確に表せない十進数もあり、僅かな丸め誤差を生じます。</p>
<p>十進数演算では、1/3 = 0.3333333333....... など、固定長の十進数では表せない数がたくさんあります。</p>
<p>基数が 2 のとき、1/2 = 0.1、1/4 = 0.01、1/8 = 0.001、などになります。 .2 は 2/10 と等しく、1/5 と等しいので、二進数の分数で 0.001100110011001... になります。</p>
<p>浮動小数点数には 32 か 64 ビットの精度しかないので、ある桁で切り捨てられ、十進数表示で 0.2 ではなく 0.199999999999999996 となります。</p>
<p>浮動小数点数の <code class="docutils literal"><span class="pre">repr()</span></code> 関数はすべての浮動小数点数 f に対して <code class="docutils literal"><span class="pre">eval(repr(f))</span> <span class="pre">==</span> <span class="pre">f</span></code> が真となるのに必要なだけの桁を表示します。 <code class="docutils literal"><span class="pre">str()</span></code> 関数はそれより少ない桁を表示するので、より意図を汲んだ感覚的な数を得やすいです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.1</span> <span class="o">-</span> <span class="mf">0.9</span>
<span class="go">0.20000000000000007</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="mf">1.1</span> <span class="o">-</span> <span class="mf">0.9</span>
<span class="go">0.2</span>
</pre></div>
</div>
<p>その結果、 <code class="docutils literal"><span class="pre">==</span></code> による浮動小数点の演算結果の比較は間違いやすいです。僅かな不正確さだけで <code class="docutils literal"><span class="pre">==</span></code> が間違うこともあります。その代わりに、二つの数間の差があるしきい値よりも小さいことを調べなくてはなりません:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.0000000000001</span>  <span class="c1"># Tiny allowed error</span>
<span class="n">expected_result</span> <span class="o">=</span> <span class="mf">0.4</span>

<span class="k">if</span> <span class="n">expected_result</span><span class="o">-</span><span class="n">epsilon</span> <span class="o">&lt;=</span> <span class="n">computation</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">expected_result</span><span class="o">+</span><span class="n">epsilon</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>詳しくは、Python チュートリアルの <a class="reference internal" href="../tutorial/floatingpoint.html#tut-fp-issues"><span class="std std-ref">floating point arithmetic</span></a> の章を参照してください。</p>
</div>
<div class="section" id="why-are-python-strings-immutable">
<h2>なぜ Python の文字列はイミュータブルなのですか？<a class="headerlink" href="#why-are-python-strings-immutable" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>これにはいくつかの利点があります。</p>
<p>一つはパフォーマンスです。文字列がイミュータブルなら、生成時に領域を割り当てることができるので、必要な記憶域は固定されて、変更されません。これはタプルとリストを区別する理由の一つでもあります。</p>
<p>他の利点は、Python の文字列は数と同じくらい &#8220;基本的&#8221; なものと考えられることです。8 という値を他の何かに変える手段が無いように、文字列 &#8220;eight&#8221; を他の何かに変える手段も無いのです。</p>
</div>
<div class="section" id="why-must-self-be-used-explicitly-in-method-definitions-and-calls">
<span id="why-self"></span><h2>なぜメソッドの定義や呼び出しにおいて &#8216;self&#8217; を明示しなければならないのですか？<a class="headerlink" href="#why-must-self-be-used-explicitly-in-method-definitions-and-calls" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このアイデアは Modula-3 から取り入れられました。これは様々な理由からとても便利だと言えます。</p>
<p>まず、ローカル変数ではなく、メソッドやインスタンス属性を扱っていることがより明確になります。 <code class="docutils literal"><span class="pre">self.x</span></code> や <code class="docutils literal"><span class="pre">self.meth()</span></code> と書いてあれば、そのクラスの定義を憶えていなくても、それがインスタンス変数やメソッドであることは明らかです。C++ では、(グローバルが滅多になかったり、簡単に見分けがつくなら) ローカル変数宣言がないことからある程度わかるでしょう。&#8211; しかし Python にはローカル変数宣言がないので、クラス定義を調べて確かめなくてはなりません。C++ や Java のコーディングスタンダードに、インスタンス属性に <code class="docutils literal"><span class="pre">m_</span></code> 接頭辞をつけるものがあるので、この明示性はそれらの言語においても有用です。</p>
<p>第二に、特定のクラスからメソッドを明示的に参照または呼び出ししたい時に、特別な構文が必要なくなります。C++ では、派生クラスでオーバーライドされた基底クラスからメソッドを使うには、 <code class="docutils literal"><span class="pre">::</span></code> 演算子を使わなければなりません。 &#8211; Python では、 <code class="docutils literal"><span class="pre">baseclass.methodname(self,</span> <span class="pre">&lt;argument</span> <span class="pre">list&gt;)</span></code> と書けます。これは特に、 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドに便利ですし、派生クラスのメソッドが、基底クラスにある同じ名前のメソッドを拡張するために、基底クラスのメソッドをどうにかして呼び出したい時にも便利です。</p>
<p>最後に、インスタンス変数に対する、代入の構文の問題を解決できます。Python のローカル変数は、関数の中で (global が明示的に宣言されることなく) 値が代入された変数 (と定義されています！) です。なので、ある代入が意図するのが、ローカル変数へではなくインスタンス変数への代入であると、インタプリタが判断する手段が必要です。そしてそれは構文を見るだけで分かる方が (効率が) 良いのです。C++ ではその区別を宣言時に行いますが、Python では宣言がないので、この方法でしか区別できなかったら残念です。 <code class="docutils literal"><span class="pre">self.var</span></code> を明示すればうまく解決できます。同様に、インスタンス変数を使うのにも <code class="docutils literal"><span class="pre">self.var</span></code> と書かなければならないので、メソッドの中の self が付いていない名前への参照は、そのインスタンスのディレクトリを検索するまでもなくローカル変数とわかります。別の言い方をすれば、ローカル変数とインスタンス変数は二つの異なる名前空間に存在し、Python にどちらの名前空間を使うかを伝えなくてはならないのです。</p>
</div>
<div class="section" id="why-can-t-i-use-an-assignment-in-an-expression">
<h2>式中で代入ができないのはなぜですか？<a class="headerlink" href="#why-can-t-i-use-an-assignment-in-an-expression" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>C や Perl に慣れた多くの人は、C のこの慣用句を使いたいと訴えます:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">line</span> <span class="o">=</span> <span class="n">readline</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// do something with line</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Python ではこう書かなくてはなりません:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="o">...</span>  <span class="c1"># do something with line</span>
</pre></div>
</div>
<p>Python の式中での代入を許さない理由は、この構造によって起こる、他の言語ではありがちで見つけづらいバグです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// error handling</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="c1">// code that only works for nonzero x</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このエラーは単純なタイプミスで、本当にやりたかったのは <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">0</span></code> の比較ですが、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">0</span></code> と書いてしまい、変数 <code class="docutils literal"><span class="pre">x</span></code> に 0 を代入しています。</p>
<p>提案された代替案はたくさんあります。多くの案はタイプ数を少し節約しますが、勝手だったり意味不明だったりする構文や予約語を使い、言語変更の提案の簡潔さの基準を満たしていません。構造の説明をされていない人間の読者に、正しい意味を直感的に示す物であるべきです。</p>
<p>面白いことに、熟練した Python プログラマは <code class="docutils literal"><span class="pre">while</span> <span class="pre">True</span></code> イディオムを受け入れていて、式構造中の代入がなくてもそれほど苦労しないようです。Python にそれを強く求めるのは新人だけです。</p>
<p>以下の方法でもこれを綴ることができて、魅力的そうですが、堅牢さでは &#8220;while True&#8221; を使う方法に劣ることが多いです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="k">while</span> <span class="n">line</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># do something with line...</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</pre></div>
</div>
<p>この方法の問題は、次の行を取得する方法を変えたくなったとき (<code class="docutils literal"><span class="pre">sys.stdin.readline()</span></code> に変更したい時など) にプログラムの二箇所を変えなくてはならないことです &#8211; 二つ目の場所はループの最後に隠れています。</p>
<p>一番いいのはイテレータを使って、 <code class="docutils literal"><span class="pre">for</span></code> 文でオブジェクトを通してループさせることです。例えば、ファイルオブジェクトはイテレータプロトコルをサポートしているので、単純にこう書けます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># do something with line...</span>
</pre></div>
</div>
</div>
<div class="section" id="why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list">
<h2>Python にメソッドを使う機能 (list.index() 等) と関数を使う機能 (len(list) 等) があるのはなぜですか？<a class="headerlink" href="#why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>主な理由は歴史です。複数の型に対しての総称的な操作で、対象のオブジェクトがメソッドを全く持っていなかった (例えば、タプル) としても働くよう意図したものに関数は使われました。Python の関数的機能 (<code class="docutils literal"><span class="pre">map()</span></code> 、<code class="docutils literal"><span class="pre">zip()</span></code> など) を使うときに、型のはっきりしないオブジェクトのコレクションに対して、難なく適用できる関数があるのも便利なことです。</p>
<p>実際、 <code class="docutils literal"><span class="pre">len()</span></code> 、 <code class="docutils literal"><span class="pre">max()</span></code> 、 <code class="docutils literal"><span class="pre">min()</span></code> を組み込み関数として実装することで、それぞれの型のメソッドとして実装するより少ないコードで済みます。個々のケースについては粗探しのしようがありますが、Python の一部であるし、根本的な変更をするには遅すぎます。これらの関数は、大規模なコードの破壊を避けるために残す必要があります。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Python の文字列演算は、外部の関数 (<code class="docutils literal"><span class="pre">string</span></code> モジュール) からメソッドに移行しました。しかし、 <code class="docutils literal"><span class="pre">len()</span></code> は関数のままです。</p>
</div>
</div>
<div class="section" id="why-is-join-a-string-method-instead-of-a-list-or-tuple-method">
<h2>join() がリストやタプルのメソッドではなく文字列のメソッドなのはなぜですか？<a class="headerlink" href="#why-is-join-a-string-method-instead-of-a-list-or-tuple-method" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>文字列は Python 1.6 から他の標準型に大きく近づきました。それ以前は常に string モジュールの関数を使ってできていたことと同等の機能を持つメソッドがこの時に追加されました。その新しいメソッドの多くは広く受け入れられましたが、一部のプログラマに不快を感じさせていると思われるものがこれで:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span> <span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="s1">&#39;16&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>結果はこうなります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;1, 2, 4, 8, 16&quot;</span>
</pre></div>
</div>
<p>この使い方には二つの議論があります。</p>
<p>一つ目は、「文字列リテラル (文字列定数) のメソッドを使うのは醜すぎる」というようなものです。確かにそうかも知れませんが、文字列リテラルは単なる固定された値に過ぎないというのが答えです。文字列に束縛された名前にメソッドが許されるなら、リテラルに使えないようにする論理的な理由はないでしょう。</p>
<p>二つ目の反対理由は、典型的には「私は実際、要素を文字列定数とともに結合させるよう、シーケンスに命じているのだ」というものです。残念ながら、そうではないのです。いくつかの理由から <a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> を文字列のメソッドとしておいた方がはるかに簡単です。これを見ると分かりやすいでしょう</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;1, 2, 4, 8, 16&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>これは文字列リテラルに与えられた分離子 (デフォルトでは空白文字) によって区切られた部分文字列を返すように指示しています。このとき、Unicode 文字列は Unicode 文字列のリストを返し、ASCII 文字列は ASCII 文字列のリストを返すから、みんな幸せです。</p>
<p><a class="reference internal" href="../library/stdtypes.html#str.join" title="str.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> は、セパレータ文字列に、文字列のシーケンスをイテレートして隣り合う要素の間に自身を挿入するように指示しているので、文字列のメソッドです。このメソッドは、独自に定義された新しいクラスを含め、シーケンスの規則を満たすいかなる引数にも使えます。</p>
<p>これは文字列メソッドなので、Unicode 文字列にも通常の ASCII 文字列にも使えます。 <code class="docutils literal"><span class="pre">join()</span></code> がシーケンス型のモジュールだったとしたら、そのシーケンス型はどちらの型の文字列を返すか、セパレータの型によって決めなければなりません。</p>
<p>もしもこれらの論拠のどれにも納得出来ないなら、さしあたり string モジュールの <code class="docutils literal"><span class="pre">join()</span></code> 関数を使い続けてこのように書けるでしょう</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">string</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span> <span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="s1">&#39;16&#39;</span><span class="p">],</span> <span class="s2">&quot;, &quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="how-fast-are-exceptions">
<h2>例外はどれくらい速いのですか？<a class="headerlink" href="#how-fast-are-exceptions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>try/except ブロックは例外が送出されなければ極端に効率的です。実際に例外を捕捉するのは高価です。Python 2.0 より前のバージョンでは、このイディオムを使うのが一般的でした:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
    <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
<p>これは、辞書がほとんどの場合にキーを持っていると予想できるときにのみ意味をなします。そうでなければ、このように書きます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mydict</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Python 2.0 以降では、 <code class="docutils literal"><span class="pre">value</span> <span class="pre">=</span> <span class="pre">mydict.setdefault(key,</span> <span class="pre">getvalue(key))</span></code> のように書くことができます。</p>
</div>
</div>
<div class="section" id="why-isn-t-there-a-switch-or-case-statement-in-python">
<h2>Python に switch や case 文がないのはなぜですか？<a class="headerlink" href="#why-isn-t-there-a-switch-or-case-statement-in-python" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal"><span class="pre">if...</span> <span class="pre">elif...</span> <span class="pre">elif...</span> <span class="pre">else</span></code> の繰り返しで簡単に同じことができます。switch 文の構文に関する提案がいくつかありましたが、範囲判定をするべきか、あるいはどのようにするべきかについての合意は (まだ) 得られていません。現在の状況の完全な詳細は <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0275"><strong>PEP 275</strong></a> を参照してください。</p>
<p>非常に大きな数の選択肢から選ぶとき、値を呼び出す関数に対応づける辞書を作れます。例えば:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">function_1</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">functions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">function_1</span><span class="p">,</span>
             <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="n">function_2</span><span class="p">,</span>
             <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_1</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
<span class="n">func</span><span class="p">()</span>
</pre></div>
</div>
<p>オブジェクトのメソッドを呼び出すには、さらに単純に <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a> 組み込み関数で特定の名前のメソッドを検索できます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">visit_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
<span class="o">...</span>

<span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">method_name</span> <span class="o">=</span> <span class="s1">&#39;visit_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>
    <span class="n">method</span><span class="p">()</span>
</pre></div>
</div>
<p>メソッドの名前にこの例の <code class="docutils literal"><span class="pre">visit_</span></code> のような接頭辞を使うことを勧めます。このような接頭辞がないと、信頼できないソースから値が与えられたときに、オブジェクトの任意のメソッドを呼び出す攻撃をされる可能性があります。</p>
</div>
<div class="section" id="can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation">
<h2>OS 特有のスレッド実装に依らずにインタプリタでスレッドをエミュレートすることはできないのですか？<a class="headerlink" href="#can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>答 1: 残念なことに、インタプリタは Python のスタックフレームごとに少なくとも一つの C のスタックフレームを push します。同様に、拡張もほとんどランダムなときに Python にコールバックすることがあります。よって、完全なスレッド実装には C のスレッドサポートが必要です。</p>
<p>答 2: 幸運なことに、完全に再設計された C スタックを使わないインタプリタループを持つ、 <a class="reference external" href="http://www.stackless.com">Stackless Python</a> があります。</p>
</div>
<div class="section" id="why-can-t-lambda-expressions-contain-statements">
<h2>なぜラムダ式は文を含むことができないのですか?<a class="headerlink" href="#why-can-t-lambda-expressions-contain-statements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のラムダ式が文を含むことができないのは、Python の文法的な枠組みが式の中にネストされた文を扱うことができないからです。しかし、Python では、これは深刻な問題ではありません。他の言語のラムダに機能が追加されているのと違い、Python のラムダは単なる、関数を定義するのが面倒すぎる場合のための簡略な記法に過ぎないのです。</p>
<p>関数は既に Python の第一級オブジェクトで、ローカルスコープ内で宣言できます。従って、ローカルで定義された関数ではなくラムダを使う利点は、関数の名前を考える必要が無いことだけです &#8211; しかし、(ラムダ式が生み出すオブジェクトと厳密に同じ型の) 関数オブジェクトが代入される先はただのローカル変数です！</p>
</div>
<div class="section" id="can-python-be-compiled-to-machine-code-c-or-some-other-language">
<h2>Python は C やその他の言語のように機械語にコンパイルできますか？<a class="headerlink" href="#can-python-be-compiled-to-machine-code-c-or-some-other-language" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>簡単にはできません。Python の高水準データ型、動的な型付け、(<a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> や <code class="xref py py-func docutils literal"><span class="pre">exec()</span></code> を使った) インタプリタの実行時呼び出しがあるということは、「コンパイルされた」Python のプログラムのほとんどが、 <code class="docutils literal"><span class="pre">x+1</span></code> のような一見簡単な演算でさえ、Python のランタイムシステムへの呼び出しで成り立っているであろうことを意味します。</p>
<p>Python ニュースグループや過去の <a class="reference external" href="https://www.python.org/community/workshops/">Python conferences</a> で説明されたいくつかのプロジェクトを見ると、現在の速度の向上は緩やかでしかない (たとえば 2 倍) ですが、このやり方はうまくいきそうです。Jython は Java バイトコードにコンパイルするという同様の方法を使っています。(Jim Hugunin の論証によれば、プログラム全体の解析と組み合わせることで、小さなデモプログラムでは 1000 倍の速度向上が見込めます。詳しくは <a class="reference external" href="http://legacy.python.org/workshops/1997-10/proceedings/">1997 Python conference</a>  の議事録を参照してください。)</p>
<p>内部的には、Python のソースコードはいつもバイトコード表現に翻訳されていて、そのバイトコードが Python の仮想マシンによって実行されます。めったに変更されないモジュールの解析が繰り返されることによるオーバーヘッドを避けるため、このバイトコードはモジュールが解析されるたびに名前が &#8221;.pic&#8221; で終わるファイルに書きこまれます。対応する .py ファイルが変更されたとき、そのファイルは再び解析および翻訳されて .pyc ファイルは書き直されます。</p>
<p>一旦 .pyc ファイルが読み込まれればパフォーマンスの差はなく、 .pyc ファイルから読み込まれたバイトコードも、直接の変換により生成されたバイトコードも全く同じです。唯一の違いは、.pyc ファイルからコードを読み込むのは .py ファイルを解析して翻訳するのよりも速いことなので、予めコンパイルされた .pyc ファイルがあると Python スクリプトの起動時間が改善します。必要なら、 Lib/compileall.py モジュールで、与えられたモジュール群の適切な .pyc ファイルを生成できます。</p>
<p>なお、Python によって実行されるメインスクリプトは、たとえそのファイル名が .py で終わっていても、.pyc ファイルにコンパイルされません。バイトコードには変換されますが、そのバイトコードはファイルに保存されません。たいていメインスクリプトはとても短いので、これでも大きく速度を落とすことにはなりません。</p>
<p>There are also several programs which make it easier to intermingle Python and C
code in various ways to increase performance.  See, for example, <a class="reference external" href="http://cython.org/">Cython</a> , <a class="reference external" href="http://psyco.sourceforge.net/">Psyco</a>, <a class="reference external" href="https://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/">Pyrex</a>, <a class="reference external" href="http://pyinline.sourceforge.net/">PyInline</a>, <a class="reference external" href="http://sourceforge.net/projects/py2cmod/">Py2Cmod</a>, and
<a class="reference external" href="https://docs.scipy.org/doc/scipy-dev/reference/tutorial/weave.html">Weave</a>.</p>
</div>
<div class="section" id="how-does-python-manage-memory">
<h2>Python はメモリをどのように管理するのですか？<a class="headerlink" href="#how-does-python-manage-memory" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のメモリ管理の詳細は実装に依ります。Python の標準の C 実装は参照カウントを使って、アクセスできないオブジェクトを探します。また別のメカニズムも使って参照サイクルを集めます。これはサイクル検出アルゴリズムを定期的に実行し、アクセスできないサイクルを探し、それに含まれるオブジェクトを削除します。 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal"><span class="pre">gc</span></code></a> モジュールの関数で、ガベージコレクションを実行し、デバッグ統計を取得し、コレクタのパラメタを変更できます。</p>
<p>Jython は Java ランタイムに頼るので、JVM のガベージコレクタが使われます。もしもあなたの Python のコードが参照カウントの実装の振る舞いに依存しているならば、この違いが微妙な移植問題を起こすことがあります。</p>
<p>ときどきオブジェクトは一時的にトレースバックに貼り付き、それゆえにあなたが期待するようには解放されません。トレースバックをクリアするにはこうします:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">exc_clear</span><span class="p">()</span>
<span class="n">sys</span><span class="o">.</span><span class="n">exc_traceback</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">last_traceback</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
<p>トレースバックはエラー報告、デバッガの実装やその他関係することに使います。 それらは、例外 (普通は最も最近の例外)のハンドリングで抽出されたプログラムの実行状態の一部を含んでいます。</p>
<p>循環性とトレースバックがなければ、Python プログラムはメモリを明示的に管理する必要はありません。</p>
<p>なぜ Python は伝統的なガベージコレクション体系を使わないのでしょうか？まず、それは C の標準的な機能ではないのでポータブルではありません。 (Boehm GC を例に取りましょう。これには <em>most</em> 有名なプラットフォームのためのアセンブリコードが含まれますが、全てには対応していませんし、ほとんど transparent ですが、完全に transparent ではありません。 Python を対応させるにはパッチが必要です。)</p>
<p>伝統的な GC は Python が他のアプリケーションに実装されるときにも問題となります。スタンドアロンの Python で動く限りでは、標準の malloc() と free() を GC ライブラリから提供されるものに置き換えても問題ありませんが、Python を実装したアプリケーションは Python のものではない <em>独自の</em> 代替品を使おうとするかもしれません。現在のようにすることで、Python は malloc() と free() が適切に実装されている限りどんなものにも対応させられます。</p>
<p>Jython では、以下の (CPython では通る) コードはおそらく、メモリを使い切るより遥かに前にファイルディスクリプタを使い果たすでしょう:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">very_long_list_of_files</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>現在の参照カウントとデストラクタのスキームを使えば、 f への新しい代入ごとに前のファイルは閉じられます。GC を使うのでは、これは保証されません。どんな Python の実装にも適用できるコードを書くには、明示的にファイルを閉じるか、 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文を使いましょう。これは GC に関係なく働きます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">very_long_list_of_files</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="why-isn-t-all-memory-freed-when-python-exits">
<h2>なぜ Python の終了時にすべてのメモリが解放されるわけではないのですか？<a class="headerlink" href="#why-isn-t-all-memory-freed-when-python-exits" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python モジュールのグローバルな名前空間から参照されるオブジェクトは、Python の終了時にメモリの割り当てを解除されるとは限りません。これは、循環参照があるときに起こりえます。解放できない C ライブラリ (例えば、Purify のようなツールなどが当てはまります) によって割り当てられたいくらかのメモリも含まれます。しかし、Python は終了時にメモリをクリーンアップすることには積極的で、全ての単一のオブジェクトを破棄しようとします。</p>
<p>再割り当て時に Python が特定のものを削除するように強制したいときは、 <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal"><span class="pre">atexit</span></code></a> モジュールを使って削除を強制する関数を実行してください。</p>
</div>
<div class="section" id="why-are-there-separate-tuple-and-list-data-types">
<h2>なぜタプルとリストという別のデータ型が用意されているのですか？<a class="headerlink" href="#why-are-there-separate-tuple-and-list-data-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>リストとタプルは、多くの点で似ていますが、一般には本質的に異なる方法で使われます。タプルは、Pascal のレコードや C の構造体と同様なものと考えられます。型が異なっても良い関連するデータの小さな集合で、グループとして演算されます。例えば、デカルト座標は 2 つや 3 つの数のタプルとして適切に表せます。</p>
<p>一方、リストは、もっと他の言語の配列に近いものです。全て同じ型の可変数のオブジェクトを持ち、それらが一つ一つ演算される傾向にあります。例えば、 <code class="docutils literal"><span class="pre">os.listdir('.')</span></code> はカレントディレクトリ内にあるファイルの文字列表現のリストを返します。この出力を演算する関数は一般に、ディレクトリに一つや二つの別のファイルを加えても壊れません。</p>
<p>タプルはイミュータブルなので、一度タプルが生成されたら、そのどの要素も新しい値に置き換えられません。リストはミュータブルなので、リストの要素はいつでも変更できます。イミュータブルな要素だけが辞書のキーとして使えるので、リストではなくタプルだけがキーとして使えます。</p>
</div>
<div class="section" id="how-are-lists-implemented">
<h2>リストはどのように実装されているのですか？<a class="headerlink" href="#how-are-lists-implemented" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のリストは真の可変長配列であり、Lisp スタイルの連結リストではありません。この実装は、他のオブジェクトへの参照の連続した配列を使い、リストの頭部構造にこの配列へのポインタと配列の長さを保持します。</p>
<p>これにより、リストのインデクシング <code class="docutils literal"><span class="pre">a[i]</span></code> は、リストの大きさやインデクスの値に依存しないコストで演算できます。</p>
<p>要素が追加または挿入されるとき、この参照の配列は大きさが変更されます。要素追加の繰り返しのパフォーマンスを上げるために、少し工夫されています。配列が大きくなるとき、次の何回かは実際に大きさを変更する必要がないように、いくらかの追加の領域が割り当てられます。</p>
</div>
<div class="section" id="how-are-dictionaries-implemented">
<h2>辞書はどのように実装されているのですか？<a class="headerlink" href="#how-are-dictionaries-implemented" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python の辞書は大きさを変更できるハッシュテーブルとして実装されています。
B 木と比べて、ほとんどの条件下で (特に一般的な演算である) 探索のパフォーマンスが良いですし、実装も単純です。</p>
<p>辞書は、 <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a> ビルトイン関数で、辞書に保存されているそれぞれのキーに対応するハッシュコードを計算して働きます。このハッシュコードはキーに大きく依存します。例えば、&#8221;Python&#8221; のハッシュ値は -539294296 ですが、ビットが一つ違うだけの文字列 &#8220;python&#8221; のハッシュ値は 1142331976 です。そしてこのハッシュコードは、内部配列での値が保存される位置を計算するために使われます。保存しているキーのハッシュ値が異なるとすれば、一定の時間 - コンピュータサイエンスの記法で言えば O(1) - でキーを検索できることになります。また、キーのいかなる並び順も保たれていないことにもなり、配列を <code class="docutils literal"><span class="pre">.keys()</span></code> や <code class="docutils literal"><span class="pre">.items()</span></code> として横断すると、辞書の内容が任意の混乱した順序で出力されます。</p>
</div>
<div class="section" id="why-must-dictionary-keys-be-immutable">
<h2>なぜ辞書のキーはイミュータブルでなくてはならないのですか？<a class="headerlink" href="#why-must-dictionary-keys-be-immutable" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>辞書のハッシュテーブルの実装は、キーを見つけるために、キー値から計算されたハッシュ値を使います。もしキーがミュータブルなオブジェクトだったら、その値は変えられ、それによりハッシュ値も変わってしまいます。しかし、キーオブジェクトを変更したのが何者であれ、値が辞書のキーとして使われていたと気付けないので、辞書の中のエントリを適切な場所に動かせません。そして、同じオブジェクトを探そうとしても、ハッシュ値が違うため見つかりません。古い値を探そうとしても、そのハッシュバイナリから見つかるオブジェクトの値は異なるでしょうから、これも見つかりません。</p>
<p>リストでインデクシングされた辞書が必要なら、まず単純にリストをタプルに変換してください。関数 <code class="docutils literal"><span class="pre">tuple(L)</span></code> は、リスト <code class="docutils literal"><span class="pre">L</span></code> と同じエントリのタプルを生成します。タプルはイミュータブルなので、辞書のキーとして使えます。</p>
<p>いくつかの受け入れられなかった提案:</p>
<ul>
<li><p class="first">アドレス (オブジェクト ID) のハッシュリスト。これは、同じ値の新しいリストを作っても見つからないので駄目です。例えば:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mydict</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span> <span class="s1">&#39;12&#39;</span><span class="p">}</span>
<span class="nb">print</span> <span class="n">mydict</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
</pre></div>
</div>
<p>は、2 行目の <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2]</span></code> の id が 1 行目のものと違うため、 KeyError 例外を起こします。要するに、辞書のキーは <a class="reference internal" href="../reference/expressions.html#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a> ではなく、 <code class="docutils literal"><span class="pre">==</span></code> で比較されるべきです。</p>
</li>
<li><p class="first">リストをキーとして使うときにコピーを作る。リストはミュータブルなので、自分自身への参照を含むことができ、コードをコピーするときに無限ループにハマる可能性があるので、これは駄目です。</p>
</li>
<li><p class="first">リストをキーとして使うことを認めるが、ユーザにそれを変更させないように伝える。もしユーザが忘れたり、偶然にリストが変更されてしまったりしたら、追跡困難なバグの可能性を生じてしまいます。またこれは、 <code class="docutils literal"><span class="pre">d.keys()</span></code> のすべての値は辞書のキーとして使えるという、辞書の重要な不変性も潰してしまいます。</p>
</li>
<li><p class="first">リストが一旦辞書のキーとして使われたら、読み込み専用のマークを付ける。問題は、値を変えられるのはトップレベルオブジェクトだけではないことです。リストを含むタプルもキーとして使えます。全てを辞書のキーとして導入すると、そこから到達可能な全てのオブジェクトに読み込み専用のマークを付ける必要があります &#8211; そして再び、自己参照オブジェクトが無限ループを引き起こします。</p>
</li>
</ul>
<p>必要ならばこれを回避する方法がありますが、自己責任のもとで行ってください。ミュータブルな構造を、 <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> と <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> メソッドの両方を持つクラスインスタンスに含めることができます。その時、辞書 (またはハッシュに基づく別の構造体) に属するような全てのラッパーオブジェクトのハッシュ値が、そのオブジェクトが辞書 (その他の構造体) 中にある間固定され続けることを確実にしてください。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ListWrapper</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">the_list</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">the_list</span> <span class="o">=</span> <span class="n">the_list</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">the_list</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">the_list</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">the_list</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">98767</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">*</span><span class="mi">555</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="o">%</span> <span class="mi">9999999</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1001</span> <span class="o">+</span> <span class="n">i</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">%</span> <span class="mi">7777777</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">333</span>
        <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>なお、リストのメンバーの中にハッシュ化できないものがある可能性や、算術オーバーフローの可能性から、ハッシュ計算は複雑になります。</p>
<p>さらに、そのオブジェクトが辞書に含まれるか否かにかかわらず、 <code class="docutils literal"><span class="pre">o1</span> <span class="pre">==</span> <span class="pre">o2</span></code> (すなわち <code class="docutils literal"><span class="pre">o1.__eq__(o2)</span> <span class="pre">is</span> <span class="pre">True</span></code>) ならばいつでも <code class="docutils literal"><span class="pre">hash(o1)</span> <span class="pre">==</span> <span class="pre">hash(o2)</span></code> (すなわち <code class="docutils literal"><span class="pre">o1.__hash__()</span> <span class="pre">==</span> <span class="pre">o2.__hash__()</span></code>) でなくてはなりません。その制限に適合できなければ、辞書やその他のハッシュに基づく構造体は間違いを起こします。</p>
<p>この ListWrapper の例では、異常を避けるため、ラッパオブジェクトが辞書内にある限りラップされたリストが変更されてはなりません。この条件と満たせなかった時の結果について知恵を絞る覚悟がない限り、これをしてはいけません。よく考えてください。</p>
</div>
<div class="section" id="why-doesn-t-list-sort-return-the-sorted-list">
<h2>なぜ list.sort() はソートされたリストを返さないのですか？<a class="headerlink" href="#why-doesn-t-list-sort-return-the-sorted-list" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>パフォーマンスが問題となる状況では、ソートするためだけにリストのコピーを作るのは無駄が多いです。そこで、 <code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code> はインプレースにリストをソートします。このことを忘れないため、この関数はソートされたリストを返しません。こうすることで、ソートされたコピーが必要で、ソートされていないものも残しておきたいときに、うっかり上書きしてしまうようなことがなくなります。</p>
<p>Python 2.4 で、新しい関数 &#8211; <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a> &#8211; が追加されました。この関数は、与えられたイテレート可能から新しいリストを生成し、ソートして返します。例えば、辞書のキーをソートされた順序でイテレートする方法は:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mydict</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c1"># do whatever with mydict[key]...</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-you-specify-and-enforce-an-interface-spec-in-python">
<h2>Python ではどのようにインタフェース仕様を特定し適用するのですか？<a class="headerlink" href="#how-do-you-specify-and-enforce-an-interface-spec-in-python" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>C++ や Java のような言語が提供するような、モジュールに対するインタフェース仕様の特定は、モジュールのメソッドや関数の原型を表現します。インタフェースの特定がコンパイル時に適用されることが、大きなプログラムの構成に役立つと、広く感じられています。</p>
<p>Python 2.6 で、 <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to PEP 3119."><code class="xref py py-mod docutils literal"><span class="pre">abc</span></code></a> モジュールが追加され、抽象基底クラス (Abstract Base Classes/ABCs) を定義できるようになりました。これにより、 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> や <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal"><span class="pre">issubclass()</span></code></a> を使って、あるインスタンスやクラスが特定の ABC を実装するかを調べられるようになりました。 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: High-performance datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールによって、 <a class="reference internal" href="../library/collections.html#collections.Iterable" title="collections.Iterable"><code class="xref py py-class docutils literal"><span class="pre">Iterable</span></code></a> 、 <a class="reference internal" href="../library/collections.html#collections.Container" title="collections.Container"><code class="xref py py-class docutils literal"><span class="pre">Container</span></code></a> 、 <a class="reference internal" href="../library/collections.html#collections.MutableMapping" title="collections.MutableMapping"><code class="xref py py-class docutils literal"><span class="pre">MutableMapping</span></code></a> などの役立つ ABC が定義されています。</p>
<p>Python では、コンポーネントの適切なテスト規律によって、インタフェース仕様の多くの強みを活かせます。サブクラス化による問題を見つけるために使えるツール PyChecker もあります。</p>
<p>モジュールのための適切なテストスイートは、回帰テストを提供し、モジュールのインタフェース仕様や用例集としても役立ちます。多くの Python モジュールは、簡単な「自己テスト」を提供するスクリプトとして実行できます。複雑な外部インタフェースを使うモジュールさえ、外部インタフェースの細かい「スタブ」エミュレーションで単独にテストできることが多いです。 <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal"><span class="pre">doctest</span></code></a> や <a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> モジュール、あるいはサードパーティのテストフレームワークで、モジュールのコードの全ての行に及ぶ徹底的なテストスイートを構成できます。</p>
<p>Python で大きくて複雑なアプリケーションを構築するとき、インタフェース仕様と同様に、適切なテスト規律も役立ちます。実際には、インタフェース仕様ではテストできないプログラムの属性もあるので、それ以上にもなりえます。例えば、 <code class="xref py py-meth docutils literal"><span class="pre">append()</span></code> メソッドは新しい要素をある内部リストの終わりに加えます。インタフェース仕様ではこの <code class="xref py py-meth docutils literal"><span class="pre">append()</span></code> の実装が実際にこれを行うかをテストできませんが、テストスイートならこの機能を簡単に確かめられます。</p>
<p>テストスイートを書くことはとても役に立ちますし、テストのしやすさという視点でコードを設計することにもつながります。テスト指向開発は、人気を増しつつある技法で、実際のコードを書き始める前に、最初からテストスイートの部品を書くことを求めます。もちろん、 Python で粗雑にテストケースを全く書かないこともできます。</p>
</div>
<div class="section" id="why-is-there-no-goto">
<h2>なぜ goto が無いのですか？<a class="headerlink" href="#why-is-there-no-goto" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>関数の呼び出しをまたいでも動作する &#8220;構造化された goto&#8221; をまかなうものとして例外を使えます。C、Fortran、その他の言語での &#8220;go&#8221; あるいは &#8220;goto&#8221; 構造の適切な用途は全て、例外で同じようなことををすれば便利であると、広く感じられています。例えば:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">label</span><span class="p">:</span> <span class="k">pass</span>  <span class="c1"># declare a label</span>

<span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">if</span> <span class="n">condition</span><span class="p">:</span> <span class="k">raise</span> <span class="n">label</span><span class="p">()</span>  <span class="c1"># goto label</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="n">label</span><span class="p">:</span>  <span class="c1"># where to goto</span>
    <span class="k">pass</span>
<span class="o">...</span>
</pre></div>
</div>
<p>例外ではループ内へ跳ぶことはできませんが、どちらにしてもそれは goto の乱用と見なされるものです。使うのは控えてください。</p>
</div>
<div class="section" id="why-can-t-raw-strings-r-strings-end-with-a-backslash">
<h2>なぜ raw 文字列 (r-strings) はバックスラッシュで終わってはいけないのですか？<a class="headerlink" href="#why-can-t-raw-strings-r-strings-end-with-a-backslash" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>正確には、奇数個のバックスラッシュで終わってはいけません。終わりの対になっていないバックスラッシュは、閉じ引用文字をエスケープし、終っていない文字列を残してしまいます。</p>
<p>raw 文字列は、独自にバックスラッシュの処理をしようとするプロセッサ (主に正規表現エンジン) への入力を生成しやすいように設計されたものです。このようなプロセッサは、終端の対になっていないバックスラッシュを結局エラーとみなすので、raw 文字列はそれを認めません。その代わりに、バックスラッシュでエスケープすることで、引用文字を文字列として渡すことができます。r-string が意図された目的に使われるときに、この規則が役に立つのです。</p>
<p>Windows のパス名を構築するときには、Windows のシステムコールは普通のスラッシュも受け付けることを憶えておいてください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/mydir/file.txt&quot;</span><span class="p">)</span>  <span class="c1"># works fine!</span>
</pre></div>
</div>
<p>DOS コマンドのパス名を構築するときには、例えばこの中のどれかを試してください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">dir</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\this\is\my\dos\dir&quot;</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span>
<span class="nb">dir</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\this\is\my\dos\dir\ &quot;</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">dir</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">this</span><span class="se">\\</span><span class="s2">is</span><span class="se">\\</span><span class="s2">my</span><span class="se">\\</span><span class="s2">dos</span><span class="se">\\</span><span class="s2">dir</span><span class="se">\\</span><span class="s2">&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="why-doesn-t-python-have-a-with-statement-for-attribute-assignments">
<h2>属性の代入に &#8220;with&#8221; 文が使えないのはなぜですか？<a class="headerlink" href="#why-doesn-t-python-have-a-with-statement-for-attribute-assignments" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python には、ブロックの実行を包む &#8216;with&#8217; 文があり、ブロックに入るときとブロックから出るときに、コードを呼び出します。以下のような構造を持つ言語があります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">obj</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>               <span class="c1"># equivalent to obj.a = 1</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># obj.total = obj.total + 1</span>
</pre></div>
</div>
<p>Python では、このような構造は曖昧になるでしょう。</p>
<p>Object Pascal、Delphi、C++のような他の言語では、静的な型を使うので、曖昧な方法でも、どのメンバに代入されているのか分かります。これが静的型付けの要点です &#8211; コンパイラは <em>いつでも</em> コンパイル時にすべての変数のスコープを知るのです。</p>
<p>Python は動的な型を使います。実行時にどの属性が参照されるか事前に分かりません。動作中にメンバ属性が追加あるいは除去されるかもしれません。これでは、単純に読むだけではどのアトリビュートが参照されているか分かりません。ローカルなのか、グローバルなのか、メンバ属性なのか？</p>
<p>例えば、以下の不完全なコード片を考えましょう:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">a</span><span class="p">:</span>
        <span class="nb">print</span> <span class="n">x</span>
</pre></div>
</div>
<p>このコード片では、&#8221;a&#8221; は &#8220;x&#8221; というメンバ属性を持っていると仮定されています。しかし、Python ではインタプリタにはこの仮定を伝えられる仕組みはありません。 &#8220;a&#8221; が、例えば整数だったら、どうなってしまうでしょうか。 &#8220;x&#8221; という名前のグローバル変数があったら、それが with ブロックの中で使われるのでしょうか。この通り、Python の動的な特質から、このような選択はとても難しい物になっています。</p>
<p>しかし、&#8221;with&#8221; やそれに類する言語の機能の一番の利点 (コード量の削減) は、 Python では代入により簡単に手に入れられます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">63</span>
</pre></div>
</div>
<p>こう書いてください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ref</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
<span class="n">ref</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">ref</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">ref</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">63</span>
</pre></div>
</div>
<p>Python では実行時に名前束縛が解決され、後者はその解決が一度で済むため、これには実行速度をあげる副作用もあります。</p>
</div>
<div class="section" id="why-are-colons-required-for-the-if-while-def-class-statements">
<h2>if/while/def/class 文にコロンが必要なのはなぜですか？<a class="headerlink" href="#why-are-colons-required-for-the-if-while-def-class-statements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>主に可読性を高めるため (実験的な ABC 言語の結果の一つ) に、コロンが必要です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
    <span class="nb">print</span> <span class="n">a</span>
</pre></div>
</div>
<p>と:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
    <span class="nb">print</span> <span class="n">a</span>
</pre></div>
</div>
<p>を考えれば、後者のほうが少し読みやすいでしょう。さらに言えば、この FAQ の解答例は次のようになるでしょう。これは、英語の標準的な用法です。</p>
<p>他の小さな理由は、コロンによってエディタがシンタックスハイライトをしやすくなることです。プログラムテキストの手の込んだ解析をしなくても、コロンを探せばいつインデントを増やすべきかを決められます。</p>
</div>
<div class="section" id="why-does-python-allow-commas-at-the-end-of-lists-and-tuples">
<h2>なぜ Python ではリストやタプルの最後にカンマがあっても良いのですか？<a class="headerlink" href="#why-does-python-allow-commas-at-the-end-of-lists-and-tuples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python では、リスト、タプル、辞書の最後の要素の後端にカンマをつけても良いことになっています:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,]</span>
<span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
    <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>  <span class="c1"># last trailing comma is optional but good style</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これを許すのには、いくつかの理由があります。</p>
<p>リストやタプルや辞書のリテラルが複数行に渡っているときに、前の行にカンマを追加するのを覚えておく必要が無いため、要素を追加するのが楽になります。また、文法エラーを起こすこと無く、行の並べ替えを行うことができます。</p>
<p>間違えてカンマを落としてしまうと、診断しづらいエラーにつながります。例えば:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s2">&quot;fee&quot;</span><span class="p">,</span>
  <span class="s2">&quot;fie&quot;</span>
  <span class="s2">&quot;foo&quot;</span><span class="p">,</span>
  <span class="s2">&quot;fum&quot;</span>
<span class="p">]</span>
</pre></div>
</div>
<p>このリストには4つの要素があるように見えますが、実際には3つしかありません。&#8221;fee、&#8221;fiefoo&#8221;、&#8221;fum&#8221; です。いつもカンマを付けるようにすれば、この種のエラーが避けられます。</p>
<p>後端にカンマをつけても良いことにすれば、プログラムによるコード生成も簡単になります。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">デザインと歴史 FAQ</a><ul>
<li><a class="reference internal" href="#why-does-python-use-indentation-for-grouping-of-statements">Python はなぜ文のグループ化にインデントを使うのですか？</a></li>
<li><a class="reference internal" href="#why-am-i-getting-strange-results-with-simple-arithmetic-operations">なぜ単純な算術演算が奇妙な結果になるのですか？</a></li>
<li><a class="reference internal" href="#why-are-floating-point-calculations-so-inaccurate">なぜ浮動小数点演算はこれほど不正確なのですか？</a></li>
<li><a class="reference internal" href="#why-are-python-strings-immutable">なぜ Python の文字列はイミュータブルなのですか？</a></li>
<li><a class="reference internal" href="#why-must-self-be-used-explicitly-in-method-definitions-and-calls">なぜメソッドの定義や呼び出しにおいて &#8216;self&#8217; を明示しなければならないのですか？</a></li>
<li><a class="reference internal" href="#why-can-t-i-use-an-assignment-in-an-expression">式中で代入ができないのはなぜですか？</a></li>
<li><a class="reference internal" href="#why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list">Python にメソッドを使う機能 (list.index() 等) と関数を使う機能 (len(list) 等) があるのはなぜですか？</a></li>
<li><a class="reference internal" href="#why-is-join-a-string-method-instead-of-a-list-or-tuple-method">join() がリストやタプルのメソッドではなく文字列のメソッドなのはなぜですか？</a></li>
<li><a class="reference internal" href="#how-fast-are-exceptions">例外はどれくらい速いのですか？</a></li>
<li><a class="reference internal" href="#why-isn-t-there-a-switch-or-case-statement-in-python">Python に switch や case 文がないのはなぜですか？</a></li>
<li><a class="reference internal" href="#can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation">OS 特有のスレッド実装に依らずにインタプリタでスレッドをエミュレートすることはできないのですか？</a></li>
<li><a class="reference internal" href="#why-can-t-lambda-expressions-contain-statements">なぜラムダ式は文を含むことができないのですか?</a></li>
<li><a class="reference internal" href="#can-python-be-compiled-to-machine-code-c-or-some-other-language">Python は C やその他の言語のように機械語にコンパイルできますか？</a></li>
<li><a class="reference internal" href="#how-does-python-manage-memory">Python はメモリをどのように管理するのですか？</a></li>
<li><a class="reference internal" href="#why-isn-t-all-memory-freed-when-python-exits">なぜ Python の終了時にすべてのメモリが解放されるわけではないのですか？</a></li>
<li><a class="reference internal" href="#why-are-there-separate-tuple-and-list-data-types">なぜタプルとリストという別のデータ型が用意されているのですか？</a></li>
<li><a class="reference internal" href="#how-are-lists-implemented">リストはどのように実装されているのですか？</a></li>
<li><a class="reference internal" href="#how-are-dictionaries-implemented">辞書はどのように実装されているのですか？</a></li>
<li><a class="reference internal" href="#why-must-dictionary-keys-be-immutable">なぜ辞書のキーはイミュータブルでなくてはならないのですか？</a></li>
<li><a class="reference internal" href="#why-doesn-t-list-sort-return-the-sorted-list">なぜ list.sort() はソートされたリストを返さないのですか？</a></li>
<li><a class="reference internal" href="#how-do-you-specify-and-enforce-an-interface-spec-in-python">Python ではどのようにインタフェース仕様を特定し適用するのですか？</a></li>
<li><a class="reference internal" href="#why-is-there-no-goto">なぜ goto が無いのですか？</a></li>
<li><a class="reference internal" href="#why-can-t-raw-strings-r-strings-end-with-a-backslash">なぜ raw 文字列 (r-strings) はバックスラッシュで終わってはいけないのですか？</a></li>
<li><a class="reference internal" href="#why-doesn-t-python-have-a-with-statement-for-attribute-assignments">属性の代入に &#8220;with&#8221; 文が使えないのはなぜですか？</a></li>
<li><a class="reference internal" href="#why-are-colons-required-for-the-if-while-def-class-statements">if/while/def/class 文にコロンが必要なのはなぜですか？</a></li>
<li><a class="reference internal" href="#why-does-python-allow-commas-at-the-end-of-lists-and-tuples">なぜ Python ではリストやタプルの最後にカンマがあっても良いのですか？</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="programming.html"
                        title="前の章へ">プログラミング FAQ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="library.html"
                        title="次の章へ">ライブラリと拡張 FAQ</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">バグ報告</a></li>
  <li><a href="https://github.com/python/cpython/blob/2.7/Doc/faq/design.rst"
         rel="nofollow">ソースの表示</a>
  </li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="library.html" title="ライブラリと拡張 FAQ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="programming.html" title="プログラミング FAQ"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.13</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python よくある質問</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト).
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    Last updated on 2017-02-26.
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>