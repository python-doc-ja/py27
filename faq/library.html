
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ライブラリと拡張 FAQ &#8212; Python 2.7.14 ドキュメント</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.14',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7.14 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="拡張と埋め込み FAQ" href="extending.html" />
    <link rel="prev" title="デザインと歴史 FAQ" href="design.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/faq/library.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="extending.html" title="拡張と埋め込み FAQ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.14</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python よくある質問</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="library-and-extension-faq">
<h1><a class="toc-backref" href="#id2">ライブラリと拡張 FAQ</a><a class="headerlink" href="#library-and-extension-faq" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="contents topic" id="id1">
<p class="topic-title first">目次</p>
<ul class="simple">
<li><a class="reference internal" href="#library-and-extension-faq" id="id2">ライブラリと拡張 FAQ</a><ul>
<li><a class="reference internal" href="#general-library-questions" id="id3">ライブラリ一般の質問</a><ul>
<li><a class="reference internal" href="#how-do-i-find-a-module-or-application-to-perform-task-x" id="id4">作業 X を行うためのモジュールやアプリケーションを探すにはどうしますか？</a></li>
<li><a class="reference internal" href="#where-is-the-math-py-socket-py-regex-py-etc-source-file" id="id5">math.py (socket.py, regex.py, etc.) のソースファイルはどこにありますか？</a></li>
<li><a class="reference internal" href="#how-do-i-make-a-python-script-executable-on-unix" id="id6">Python のスクリプトを Unix で実行可能にするにはどうしますか？</a></li>
<li><a class="reference internal" href="#is-there-a-curses-termcap-package-for-python" id="id7">Python には curses/termcap パッケージはありますか？</a></li>
<li><a class="reference internal" href="#is-there-an-equivalent-to-c-s-onexit-in-python" id="id8">Python には C の onexit() に相当するものはありますか？</a></li>
<li><a class="reference internal" href="#why-don-t-my-signal-handlers-work" id="id9">シグナルハンドラが動かないのですがなぜですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-tasks" id="id10">よくある作業</a><ul>
<li><a class="reference internal" href="#how-do-i-test-a-python-program-or-component" id="id11">Python のプログラムやコンポーネントをテストするにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-create-documentation-from-doc-strings" id="id12">Python のドキュメント文字列からドキュメントを生成するにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-get-a-single-keypress-at-a-time" id="id13">一度に一つの押鍵を取得するにはどうしますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#threads" id="id14">スレッド</a><ul>
<li><a class="reference internal" href="#how-do-i-program-using-threads" id="id15">スレッドを使ったプログラムを書くにはどうしますか？</a></li>
<li><a class="reference internal" href="#none-of-my-threads-seem-to-run-why" id="id16">スレッドが一つも実行されていないようです。なぜですか？</a></li>
<li><a class="reference internal" href="#how-do-i-parcel-out-work-among-a-bunch-of-worker-threads" id="id17">たくさんのワーカースレッドに作業を割り振るにはどうしますか？</a></li>
<li><a class="reference internal" href="#what-kinds-of-global-value-mutation-are-thread-safe" id="id18">グローバルな値のどんな種類の変更がスレッドセーフになるのですか？</a></li>
<li><a class="reference internal" href="#can-t-we-get-rid-of-the-global-interpreter-lock" id="id19">グローバルインタプリタロック (Global Interpreter Lock) を取り除くことはできないのですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#input-and-output" id="id20">入力と出力</a><ul>
<li><a class="reference internal" href="#how-do-i-delete-a-file-and-other-file-questions" id="id21">ファイルを削除するにはどうしますか？ (その他、ファイルに関する質問…)</a></li>
<li><a class="reference internal" href="#how-do-i-copy-a-file" id="id22">ファイルをコピーするにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-read-or-write-binary-data" id="id23">バイナリデータを読み書きするにはどうしますか？</a></li>
<li><a class="reference internal" href="#i-can-t-seem-to-use-os-read-on-a-pipe-created-with-os-popen-why" id="id24">os.popen() によって作られたパイプで os.read() が使われていないようです。なぜですか？</a></li>
<li><a class="reference internal" href="#how-do-i-run-a-subprocess-with-pipes-connected-to-both-input-and-output" id="id25">パイプを入力と出力の両方に接続してサブプロセスを動かすにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-access-the-serial-rs232-port" id="id26">シリアル (RS232) ポートにアクセスするにはどうしますか？</a></li>
<li><a class="reference internal" href="#why-doesn-t-closing-sys-stdout-stdin-stderr-really-close-it" id="id27">sys.stdout (stdin, stderr) を閉じようとしても実際に閉じられないのはなぜですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#network-internet-programming" id="id28">ネットワーク/インターネットプログラミング</a><ul>
<li><a class="reference internal" href="#what-www-tools-are-there-for-python" id="id29">Python の WWW ツールには何がありますか？</a></li>
<li><a class="reference internal" href="#how-can-i-mimic-cgi-form-submission-method-post" id="id30">CGI フォームの発信 (METHOD=POST) を模倣するにはどうしますか？</a></li>
<li><a class="reference internal" href="#what-module-should-i-use-to-help-with-generating-html" id="id31">どのモジュールが HTML の生成の役に立ちますか？</a></li>
<li><a class="reference internal" href="#how-do-i-send-mail-from-a-python-script" id="id32">Python のスクリプトからメールを送るにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-avoid-blocking-in-the-connect-method-of-a-socket" id="id33">ソケットの connect() メソッドでブロッキングされなくするにはどうしますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#databases" id="id34">データベース</a><ul>
<li><a class="reference internal" href="#are-there-any-interfaces-to-database-packages-in-python" id="id35">Python にはデータベースパッケージへのインタフェースはありますか？</a></li>
<li><a class="reference internal" href="#how-do-you-implement-persistent-objects-in-python" id="id36">Python で永続的なオブジェクトを実装するにはどうしますか？</a></li>
<li><a class="reference internal" href="#why-is-cpickle-so-slow" id="id37">なぜ cPickle はこんなに遅いのですか？</a></li>
<li><a class="reference internal" href="#if-my-program-crashes-with-a-bsddb-or-anydbm-database-open-it-gets-corrupted-how-come" id="id38">bsddb (or anydbm) データベースが開かれたままプログラムがクラッシュすると、だめになってしまいます。なぜですか？</a></li>
<li><a class="reference internal" href="#i-tried-to-open-berkeley-db-file-but-bsddb-produces-bsddb-error-22-invalid-argument-help-how-can-i-restore-my-data" id="id39">Berkeley DB ファイルを開こうとしましたが、bsddb が bsddb.error: (22, 'Invalid argument') を生じます。助けてください！データを復元するにはどうしたら良いですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mathematics-and-numerics" id="id40">数学と数</a><ul>
<li><a class="reference internal" href="#how-do-i-generate-random-numbers-in-python" id="id41">Python でランダムな数を生成するにはどうしますか？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="general-library-questions">
<h2><a class="toc-backref" href="#id3">ライブラリ一般の質問</a><a class="headerlink" href="#general-library-questions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-find-a-module-or-application-to-perform-task-x">
<h3><a class="toc-backref" href="#id4">作業 X を行うためのモジュールやアプリケーションを探すにはどうしますか？</a><a class="headerlink" href="#how-do-i-find-a-module-or-application-to-perform-task-x" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/index.html#library-index"><span class="std std-ref">ライブラリリファンレス</span></a> から関係がありそうな標準ライブラリモジュールがあるかどうか調べてください。 (標準ライブラリに何があるかが分かるようになると、この段階をスキップすることができます。)</p>
<p>For third-party packages, search the <a class="reference external" href="https://pypi.python.org/pypi">Python Package Index</a> or try <a class="reference external" href="https://www.google.com">Google</a> or
another Web search engine.  Searching for &quot;Python&quot; plus a keyword or two for
your topic of interest will usually find something helpful.</p>
</div>
<div class="section" id="where-is-the-math-py-socket-py-regex-py-etc-source-file">
<h3><a class="toc-backref" href="#id5">math.py (socket.py, regex.py, etc.) のソースファイルはどこにありますか？</a><a class="headerlink" href="#where-is-the-math-py-socket-py-regex-py-etc-source-file" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールのソースファイルが見付けられない場合は、それは C 、 C++ かもしくは別のコンパイル言語で実装された、ビルトインもしくは動的に読み込まれるモジュールかもしれません。この場合、ソースは手に入らないかもしれませんし、 <code class="file docutils literal"><span class="pre">mathmodule.c</span></code> のようなものが (Python の読み込みパスに無い) C ソースディレクトリのどこかにあるかもしれません。</p>
<p>Python のモジュールには、(少なくとも) 3 種類あります:</p>
<ol class="arabic">
<li><p class="first">Python で書かれたモジュール (.py)。</p>
</li>
<li><p class="first">C で書かれ、動的にロードされるモジュール (.dll, .pyd, .so, .sl, etc)。</p>
</li>
<li><p class="first">C で書かれ、インタプリタにリンクされているモジュール。このリストを得るには、こうタイプしてください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="nb">print</span> <span class="n">sys</span><span class="o">.</span><span class="n">builtin_module_names</span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="how-do-i-make-a-python-script-executable-on-unix">
<h3><a class="toc-backref" href="#id6">Python のスクリプトを Unix で実行可能にするにはどうしますか？</a><a class="headerlink" href="#how-do-i-make-a-python-script-executable-on-unix" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>二つの条件があります :スクリプトファイルのモードが実行可能で、最初の行が <code class="docutils literal"><span class="pre">#!</span></code> で始まり Python インタプリタのパスが続いていなければなりません。</p>
<p>前者は、<code class="docutils literal"><span class="pre">chmod</span> <span class="pre">+x</span> <span class="pre">scriptfile</span></code> 、場合によっては <code class="docutils literal"><span class="pre">chmod</span> <span class="pre">755</span> <span class="pre">scriptfile</span></code> を実行すればできます。</p>
<p>後者は、いくつかの方法でできます。最も直接的な方法はこのように</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="ch">#!/usr/local/bin/python</span>
</pre></div>
</div>
<p>のようにファイルの一番最初の行に、プラットフォーム上の Python がインストールされているパス名を書くことです。</p>
<p>スクリプトを Python インタプリタの場所に依存させたくない場合は、 <strong class="program">env</strong> プログラムが使えます。 Python インタプリタがユーザの <span class="target" id="index-4"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code> のディレクトリにあることを前提とすれば、ほとんど全ての Unix 系 OS では次の書き方をサポートしています:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
</pre></div>
</div>
<p>CGI スクリプトでこれをやっては <em>いけません</em> 。 CGI スクリプトの <span class="target" id="index-5"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code> 変数はたいてい最小限のものになっているので、実際のインタプリタの絶対パスを使う必要があります。</p>
<p>ときおり、ユーザ環境に余裕が無く <strong class="program">/usr/bin/env</strong> プログラムが失敗することがあります; もしくは、 env プログラム自体が無いことがあります。そのような場合は、次の (Alex Rezinsky による) ハックが試せます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="ch">#! /bin/sh</span>
<span class="sd">&quot;&quot;&quot;:&quot;</span>
<span class="sd">exec python $0 ${1+&quot;$@&quot;}</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>これには、スクリプトの __doc__ 文字列を定義するというちょっとした欠点があります。しかし、これを付け足せば直せます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;...Whatever...&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="is-there-a-curses-termcap-package-for-python">
<h3><a class="toc-backref" href="#id7">Python には curses/termcap パッケージはありますか？</a><a class="headerlink" href="#is-there-a-curses-termcap-package-for-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Unix 系では、標準の Python ソース配布には、 <a class="reference external" href="https://github.com/python/cpython/tree/2.7/Modules">Modules</a> サブディレクトリに curses モジュールが同梱されていますが、デフォルトではコンパイルされていません (なお、Windows ディストリビューションでは使えません – Windows 用の curses モジュールはありません)</p>
<p><a class="reference internal" href="../library/curses.html#module-curses" title="curses: An interface to the curses library, providing portable terminal handling. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">curses</span></code></a> モジュールは基本的な curses の機能や、色付きの表示、別の文字集合サポート、パッド、マウスサポートなどの ncurses や SYSV curses の多くの機能をサポートしています。このことは、モジュールが BSD curses だけしか持っていない OS とは互換性が無いことを意味しますが、現在メンテナンスされている OS でそういう類のものは無さそうです。</p>
<p>Windows では: <a class="reference external" href="http://effbot.org/zone/console-index.htm">the consolelib module</a> を使ってください。</p>
</div>
<div class="section" id="is-there-an-equivalent-to-c-s-onexit-in-python">
<h3><a class="toc-backref" href="#id8">Python には C の onexit() に相当するものはありますか？</a><a class="headerlink" href="#is-there-an-equivalent-to-c-s-onexit-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal"><span class="pre">atexit</span></code></a> モジュールは、 C の <code class="xref c c-func docutils literal"><span class="pre">onexit()</span></code> と同じような関数登録を提供します。</p>
</div>
<div class="section" id="why-don-t-my-signal-handlers-work">
<h3><a class="toc-backref" href="#id9">シグナルハンドラが動かないのですがなぜですか？</a><a class="headerlink" href="#why-don-t-my-signal-handlers-work" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>最もありがちな問題は、シグナルハンドラが間違った引数リストで宣言されていることです。これは次のように呼び出されます</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
</pre></div>
</div>
<p>だから、これは二つの引数で宣言されるべきです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="common-tasks">
<h2><a class="toc-backref" href="#id10">よくある作業</a><a class="headerlink" href="#common-tasks" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-test-a-python-program-or-component">
<h3><a class="toc-backref" href="#id11">Python のプログラムやコンポーネントをテストするにはどうしますか？</a><a class="headerlink" href="#how-do-i-test-a-python-program-or-component" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python には二つのテストフレームワークがついています。<a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal"><span class="pre">doctest</span></code></a> モジュールは、モジュールの docstring から使用例を見つけてそれらを実行し、出力を docstring によって与えられた望まれる出力と比較します。</p>
<p><a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> モジュールは、Java や Smalltalk のテストフレームワークを模した装飾されたテストフレームワークです。</p>
<p>テスト作業を簡単にするために、プログラムにおいてモジュール性の良い設計を使うべきです。プログラムでは、ほぼ全ての処理を関数やクラスのメソッドで包むべきです – こうすることで、プログラムが速くなるという驚くような愉快な効果がときおり得られることがあります (というのも、ローカル変数へのアクセスはグローバルなアクセスよりも速いからです)。さらに言うと、テストを行うのがより難しくなってしまうため、プログラムは可変なグローバル変数に依存するのを避けるべきです。</p>
<p>プログラムの &quot;global main logic&quot; は</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main_logic</span><span class="p">()</span>
</pre></div>
</div>
<p>のように main モジュールの最後に出来る限りシンプルなものを書くのが良いでしょう。</p>
<p>プログラムが整理され、関数やクラスの動作が追いやすい状態になったら、その動作を試すテスト関数を書くべきです。一連のテストを自動化するテストスイートは、それぞれのモジュールに関連付けることができます。これは手間が掛かりそうに思えますが、Python は簡素で融通が効くので、驚くほど簡単です。&quot;製品コード (production code)&quot; と並行でテスト関数を書くことで、バグや設計の不備でさえも早い段階で簡単に見付かるようになるので、コーディング作業をより心地良く楽しいものにできます。</p>
<p>プログラムのメインモジュールとして設計されたのではない &quot;補助モジュール&quot; には、モジュールの自己テストを含めるといいでしょう。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">self_test</span><span class="p">()</span>
</pre></div>
</div>
<p>複雑な外部インタフェースと作用し合うプログラムでさえ、外部インタフェースが使えない時でも、Python で実装された &quot;fake&quot; インタフェースを使ってテストできます。</p>
</div>
<div class="section" id="how-do-i-create-documentation-from-doc-strings">
<h3><a class="toc-backref" href="#id12">Python のドキュメント文字列からドキュメントを生成するにはどうしますか？</a><a class="headerlink" href="#how-do-i-create-documentation-from-doc-strings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal"><span class="pre">pydoc</span></code></a> モジュールで Python ソースコード内のドキュメント文字列から HTML を生成できます。純粋に docstring から API ドキュメントを生成するには、他に <a class="reference external" href="http://epydoc.sourceforge.net/">epydoc</a> という選択肢もあります。 <a class="reference external" href="http://sphinx-doc.org">Sphinx</a> も docstring の内容を含めることができます。</p>
</div>
<div class="section" id="how-do-i-get-a-single-keypress-at-a-time">
<h3><a class="toc-backref" href="#id13">一度に一つの押鍵を取得するにはどうしますか？</a><a class="headerlink" href="#how-do-i-get-a-single-keypress-at-a-time" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Unix 系では、いくつかの方法があります。curses を使えば簡単ですが、 curses はかなり大きいモジュールなので習得するのが難しいです。ここに curses を使わない解決策を挙げます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">termios</span><span class="o">,</span> <span class="nn">fcntl</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
<span class="n">fd</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

<span class="n">oldterm</span> <span class="o">=</span> <span class="n">termios</span><span class="o">.</span><span class="n">tcgetattr</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
<span class="n">newattr</span> <span class="o">=</span> <span class="n">termios</span><span class="o">.</span><span class="n">tcgetattr</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
<span class="n">newattr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">newattr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">termios</span><span class="o">.</span><span class="n">ICANON</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">termios</span><span class="o">.</span><span class="n">ECHO</span>
<span class="n">termios</span><span class="o">.</span><span class="n">tcsetattr</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">termios</span><span class="o">.</span><span class="n">TCSANOW</span><span class="p">,</span> <span class="n">newattr</span><span class="p">)</span>

<span class="n">oldflags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">F_GETFL</span><span class="p">)</span>
<span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">F_SETFL</span><span class="p">,</span> <span class="n">oldflags</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">O_NONBLOCK</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="nb">print</span> <span class="s2">&quot;Got character&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span> <span class="k">pass</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">termios</span><span class="o">.</span><span class="n">tcsetattr</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">termios</span><span class="o">.</span><span class="n">TCSAFLUSH</span><span class="p">,</span> <span class="n">oldterm</span><span class="p">)</span>
    <span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">F_SETFL</span><span class="p">,</span> <span class="n">oldflags</span><span class="p">)</span>
</pre></div>
</div>
<p>これを動かすためには、<a class="reference internal" href="../library/termios.html#module-termios" title="termios: POSIX style tty control. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">termios</span></code></a> と <a class="reference internal" href="../library/fcntl.html#module-fcntl" title="fcntl: The fcntl() and ioctl() system calls. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">fcntl</span></code></a> モジュールが必要です。また、多分他でも動きますが、Linux でしかこれを試していません。このコードでは、文字は一文字づつ読みこまれ、印字されます。</p>
<p><a class="reference internal" href="../library/termios.html#termios.tcsetattr" title="termios.tcsetattr"><code class="xref py py-func docutils literal"><span class="pre">termios.tcsetattr()</span></code></a> は stdin の反響を止め、標準モードを使えなくします。 <code class="xref py py-func docutils literal"><span class="pre">fcntl.fnctl()</span></code> は、stdin のファイルディスクリプタフラグを取得し、それらをノンブロッキングモードに変えるのに使われます。stdin が空の時に読み込むのは <a class="reference internal" href="../library/exceptions.html#exceptions.IOError" title="exceptions.IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a> になるので、このエラーは補足され、無視されます。</p>
</div>
</div>
<div class="section" id="threads">
<h2><a class="toc-backref" href="#id14">スレッド</a><a class="headerlink" href="#threads" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-program-using-threads">
<h3><a class="toc-backref" href="#id15">スレッドを使ったプログラムを書くにはどうしますか？</a><a class="headerlink" href="#how-do-i-program-using-threads" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/thread.html#module-thread" title="thread: Create multiple threads of control within one interpreter."><code class="xref py py-mod docutils literal"><span class="pre">thread</span></code></a> モジュールではなく、必ず <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Higher-level threading interface."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールを使ってください。<a class="reference internal" href="../library/threading.html#module-threading" title="threading: Higher-level threading interface."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールは、<a class="reference internal" href="../library/thread.html#module-thread" title="thread: Create multiple threads of control within one interpreter."><code class="xref py py-mod docutils literal"><span class="pre">thread</span></code></a> モジュールで提供される低レベルな基本要素の、便利な抽象化を構成します。</p>
<p>Aahz は、役立つスレッディングのチュートリアルから成るスライドを揃えています。 <a class="reference external" href="http://www.pythoncraft.com/OSCON2001/">http://www.pythoncraft.com/OSCON2001/</a> を参照してください。</p>
</div>
<div class="section" id="none-of-my-threads-seem-to-run-why">
<h3><a class="toc-backref" href="#id16">スレッドが一つも実行されていないようです。なぜですか？</a><a class="headerlink" href="#none-of-my-threads-seem-to-run-why" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>メインスレッドが終了するとともに、全てのスレッドは終了されます。メインスレッドは速く働きすぎるので、スレッドには何をする時間も与えられません。</p>
<p>簡単な解決策は、プログラムの終わりに、スレッドが完了するのに十分な時間のスリープを加えることです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span><span class="o">,</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">thread_task</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="nb">print</span> <span class="n">name</span><span class="p">,</span> <span class="n">i</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_task</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
    <span class="n">T</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># &lt;----------------------------!</span>
</pre></div>
</div>
<p>しかし、実際は (ほとんどのプラットフォームでは) スレッドは並行して実行されるのではなく、一つづつ実行されるのです！なぜなら、OS のスレッドスケジューラは、前のスレッドがブロックされるまで新しいスレッドを開始しないからです。</p>
<p>簡単に直すには、関数の実行の最初にちょっとスリープを加えることです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">thread_task</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span> <span class="c1"># &lt;---------------------!</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="nb">print</span> <span class="n">name</span><span class="p">,</span> <span class="n">i</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_task</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
    <span class="n">T</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/time.html#time.sleep" title="time.sleep"><code class="xref py py-func docutils literal"><span class="pre">time.sleep()</span></code></a> による遅延をどれくらいとれば十分かを考えるより、セマフォ構造を使ったほうがいいです。一つのやり方は、 <a class="reference internal" href="../library/queue.html#module-Queue" title="Queue: A synchronized queue class."><code class="xref py py-mod docutils literal"><span class="pre">Queue</span></code></a> モジュールでキューオブジェクトを作り、それぞれのスレッドが終了するごとにキューにトークンを加えさせ、メインスレッドにスレッドがあるのと同じ数のトークンをキューから読み込ませるようにすることです。</p>
</div>
<div class="section" id="how-do-i-parcel-out-work-among-a-bunch-of-worker-threads">
<h3><a class="toc-backref" href="#id17">たくさんのワーカースレッドに作業を割り振るにはどうしますか？</a><a class="headerlink" href="#how-do-i-parcel-out-work-among-a-bunch-of-worker-threads" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/queue.html#module-Queue" title="Queue: A synchronized queue class."><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a> モジュールで、作業のリストを含むキューを作ってください。<a class="reference internal" href="../library/queue.html#Queue.Queue" title="Queue.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a> クラスはオブジェクトのリストを保持し、 <code class="docutils literal"><span class="pre">.put(obj)</span></code> で要素を加え、<code class="docutils literal"><span class="pre">.get()</span></code> で要素を返すことができます。ロッキングを引き受けるクラスは、全ての作業がちょうど一回づつ行われることを確実にしなければなりません。</p>
<p>ここにちょっとした例があります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span><span class="o">,</span> <span class="nn">Queue</span><span class="o">,</span> <span class="nn">time</span>

<span class="c1"># The worker thread gets jobs off the queue.  When the queue is empty, it</span>
<span class="c1"># assumes there will be no more work and exits.</span>
<span class="c1"># (Realistically workers will run until terminated.)</span>
<span class="k">def</span> <span class="nf">worker</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s1">&#39;Running worker&#39;</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">Queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Worker&#39;</span><span class="p">,</span> <span class="n">threading</span><span class="o">.</span><span class="n">currentThread</span><span class="p">(),</span>
            <span class="nb">print</span> <span class="s1">&#39;queue empty&#39;</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Worker&#39;</span><span class="p">,</span> <span class="n">threading</span><span class="o">.</span><span class="n">currentThread</span><span class="p">(),</span>
            <span class="nb">print</span> <span class="s1">&#39;running with argument&#39;</span><span class="p">,</span> <span class="n">arg</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Create queue</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>

<span class="c1"># Start a pool of 5 workers</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;worker </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># Begin adding work to the queue</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="c1"># Give threads time to run</span>
<span class="nb">print</span> <span class="s1">&#39;Main thread sleeping&#39;</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>実行時には、以下のように出力されます:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>Running worker
Running worker
Running worker
Running worker
Running worker
Main thread sleeping
Worker &lt;Thread(worker 1, started)&gt; running with argument 0
Worker &lt;Thread(worker 2, started)&gt; running with argument 1
Worker &lt;Thread(worker 3, started)&gt; running with argument 2
Worker &lt;Thread(worker 4, started)&gt; running with argument 3
Worker &lt;Thread(worker 5, started)&gt; running with argument 4
Worker &lt;Thread(worker 1, started)&gt; running with argument 5
...
</pre></div>
</div>
<p>詳細はモジュールのドキュメントを参照してください。 <a class="reference internal" href="../library/queue.html#Queue.Queue" title="Queue.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a> クラスで多機能なインタフェースを使えます。</p>
</div>
<div class="section" id="what-kinds-of-global-value-mutation-are-thread-safe">
<h3><a class="toc-backref" href="#id18">グローバルな値のどんな種類の変更がスレッドセーフになるのですか？</a><a class="headerlink" href="#what-kinds-of-global-value-mutation-are-thread-safe" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>グローバルインタプリタロック (<a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>) が内部で使われ、Python VM で一度に一つだけのスレッドが実行されることが保証されています。一般に、Python ではスレッド間の切り替えをバイトコード命令の間でのみ行います。切り替えの周期は、 <a class="reference internal" href="../library/sys.html#sys.setcheckinterval" title="sys.setcheckinterval"><code class="xref py py-func docutils literal"><span class="pre">sys.setcheckinterval()</span></code></a> で設定できます。したがって、それぞれのバイトコード命令、そしてそれぞれの命令が届く全ての C 実装コードは、 Python プログラムの観点からは、アトミックです。</p>
<p>このことから、理論上は、正確な勘定のためには PVM バイトコードの実装を理解することが必要です。実際上は、組み込みデータ型(整数、リスト、辞書、等)の、変数を共有する&quot;アトミックそうな&quot;演算は、実際にアトミックです。</p>
<p>例えば、以下の演算は全てアトミックです (L、L1、L2 はリスト、 D、D1、D2 は辞書、x、y はオブジェクト、i、j は整数です):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">L1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">L2</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">L1</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">L2</span>
<span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">x</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">D1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">D2</span><span class="p">)</span>
<span class="n">D</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
<p>これらは、アトミックではありません:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
<span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>他のオブジェクトを置き換えるような演算は、そのオブジェクトの参照カウントがゼロになったときに <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドを呼び出すことがあり、これが影響を及ぼすかもしれません。これは特に、辞書やリストの大規模な更新に当てはまります。疑わしければ、mutex を使ってください！</p>
</div>
<div class="section" id="can-t-we-get-rid-of-the-global-interpreter-lock">
<h3><a class="toc-backref" href="#id19">グローバルインタプリタロック (Global Interpreter Lock) を取り除くことはできないのですか？</a><a class="headerlink" href="#can-t-we-get-rid-of-the-global-interpreter-lock" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>マルチスレッド Python プログラムは事実上一つの CPU しか使えず、 (ほとんど) 全ての Python コードがグローバルインタプリタロック (<a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>) が保持されている間しか作動しなくなるということで、GIL は、 Python をハイエンドなマルチプロセッササーバマシン上に配備する上で邪魔であると見なされがちです。</p>
<p>Python 1.5 の時代に、Greg Stein は GIL をきめ細かいロッキングで置き換える総合パッチ (&quot;free threading&quot; パッチ) セットを実装しました。残念ながら、(ロックがとても効率的な) Windows でさえ、標準的な Python コードが、GIL を使ったインタプリタの 2 倍くらい遅くなりました。 Linux では、pthread ロックが効率的でないので、パフォーマンスの損失が更に酷いです。</p>
<p>その後、GIL を取り除くという案はたまに出てきますが、だれも予期される減速に対処する方法を見つけられず、スレッドを使わないユーザはこーどが半分の速度でしか動作しないのでは幸せではありません。Greg の free threading パッチは、以降の Python バージョンには更新されていません。</p>
<p>これは、Python をマルチ CPU マシンで使いこなせないことを意味しません！作業を複数の <em>スレッド</em> ではなく、複数の <em>プロセッサ</em> に分けることを考えればいいのです。 C 拡張をうまく使うことも役に立ちます。C 拡張を使ってに時間のかかる作業を行わせれば、その実行のスレッドが C のコードにある間その拡張は GIL を解放でき、他のスレッドに作業させることができます。</p>
<p>GIL を本当にグローバルにするより、インタプリタ状態ごとのロックにするべきという提案もあります。そして、インタプリタはオブジェクトを共有するべきではないということです。残念ながら、どちらも実現しないでしょう。多くのオブジェクトの実装は現在、グローバル状態を持っているので、実現はたいへんな大仕事になりそうです。例えば、小さな整数と短い文字列はキャッシュされます。このキャッシュはインタプリタ状態に動かされなくてはなりません。他のオブジェクト型は自身の自由変数リストを持っています。これらの自由変数リストはインタプリタ状態に動かされなくてはなりません。等々。</p>
<p>それどころか、その作業が終わる時が来るかもわかりません。なぜなら、サードパーティ拡張にも問題があるからです。サードパーティ拡張が書かれるペースは、インタプリタ状態にすべてのグローバル状態を格納するように変換できるペースよりも速いことでしょう。</p>
<p>そして最後に、一旦複数のインタプリタを状態を全く共有しないようにしたとして、それぞれのインタプリタを独立したプロセス上で動かしてなにが得られるというのでしょうか？</p>
</div>
</div>
<div class="section" id="input-and-output">
<h2><a class="toc-backref" href="#id20">入力と出力</a><a class="headerlink" href="#input-and-output" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-delete-a-file-and-other-file-questions">
<h3><a class="toc-backref" href="#id21">ファイルを削除するにはどうしますか？ (その他、ファイルに関する質問…)</a><a class="headerlink" href="#how-do-i-delete-a-file-and-other-file-questions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">os.remove(filename)</span></code> または <code class="docutils literal"><span class="pre">os.unlink(filename)</span></code> を使ってください。ドキュメントは、<a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> モジュールを参照してください。この二つの関数は同じものです。<code class="xref py py-func docutils literal"><span class="pre">unlink()</span></code> は単に、この関数の Unix システムコールの名称です。</p>
<p>ディレクトリを削除するには、<a class="reference internal" href="../library/os.html#os.rmdir" title="os.rmdir"><code class="xref py py-func docutils literal"><span class="pre">os.rmdir()</span></code></a> を使ってください。作成には <a class="reference internal" href="../library/os.html#os.mkdir" title="os.mkdir"><code class="xref py py-func docutils literal"><span class="pre">os.mkdir()</span></code></a> を使ってください。<code class="docutils literal"><span class="pre">os.makedirs(path)</span></code> は <code class="docutils literal"><span class="pre">path</span></code> の中間のディレクトリの、存在しないものを作成します。<code class="docutils literal"><span class="pre">os.removedirs(path)</span></code> は中間のディレクトリが空である限り、それらを削除します。ディレクトリツリー全体とその中身全てを削除したいなら、<a class="reference internal" href="../library/shutil.html#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal"><span class="pre">shutil.rmtree()</span></code></a> を使ってください。</p>
<p>ファイルの名前を変更するには、<code class="docutils literal"><span class="pre">os.rename(old_path,</span> <span class="pre">new_path)</span></code> を使ってください。</p>
<p>ファイルを切り詰めるには、<code class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">open(filename,</span> <span class="pre">&quot;r+&quot;)</span></code> でファイルを開いてから、 <code class="docutils literal"><span class="pre">f.truncate(offset)</span></code> を使ってください。offset はデフォルトでは現在のシーク位置です。<a class="reference internal" href="../library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a> で開かれたファイルのために、 <code class="docutils literal"><span class="pre">os.ftruncate(fd,</span> <span class="pre">offset)</span></code> もあります。 <em>fd</em> はファイルディスクリプタ (小さな整数) です。</p>
<p><a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal"><span class="pre">shutil</span></code></a> モジュールにも、<a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal"><span class="pre">copyfile()</span></code></a>、 <a class="reference internal" href="../library/shutil.html#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal"><span class="pre">copytree()</span></code></a>、<a class="reference internal" href="../library/shutil.html#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal"><span class="pre">rmtree()</span></code></a> 等、ファイルに作用する関数がいくつか含まれます。</p>
</div>
<div class="section" id="how-do-i-copy-a-file">
<h3><a class="toc-backref" href="#id22">ファイルをコピーするにはどうしますか？</a><a class="headerlink" href="#how-do-i-copy-a-file" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal"><span class="pre">shutil</span></code></a> モジュールには <a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal"><span class="pre">copyfile()</span></code></a> 関数があります。なお、MacOS 9 ではリソースフォークやファインダー情報をコピーしません。</p>
</div>
<div class="section" id="how-do-i-read-or-write-binary-data">
<h3><a class="toc-backref" href="#id23">バイナリデータを読み書きするにはどうしますか？</a><a class="headerlink" href="#how-do-i-read-or-write-binary-data" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>複雑なバイナリデータ形式の読み書きには、<a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret strings as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> モジュールを使うのが一番です。これでバイナリデータ (通常は数) を含む文字列を取って、 Python オブジェクトに変換することができますし、その逆もできます。</p>
<p>例えば、以下のコードはファイルから 2 バイトの整数 2 個と 4 バイトの整数 1 個をビッグエンディアンフォーマットで読み込みます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">struct</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>  <span class="c1"># Open in binary mode for portability</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;hhl&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>フォーマット中の '&gt;' はデータを強制的にビッグエンディアンにします。ファイルから、文字 'h' は一つの&quot;整数&quot;(2 バイト)を読み込み、文字 'l' は一つの&quot;long 整数&quot;を読み込みます。</p>
<p>より規則的なデータ (例えば、整数や浮動小数点数の中身の型が揃ったリスト) に対しては、 <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal"><span class="pre">array</span></code></a> モジュールを使うこともできます。</p>
</div>
<div class="section" id="i-can-t-seem-to-use-os-read-on-a-pipe-created-with-os-popen-why">
<h3><a class="toc-backref" href="#id24">os.popen() によって作られたパイプで os.read() が使われていないようです。なぜですか？</a><a class="headerlink" href="#i-can-t-seem-to-use-os-read-on-a-pipe-created-with-os-popen-why" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/os.html#os.read" title="os.read"><code class="xref py py-func docutils literal"><span class="pre">os.read()</span></code></a> は、開かれたファイルを表す小さな整数、ファイルディスクリプタを引数に取る、低レベルの関数です。 <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">os.popen()</span></code></a> は、組み込みの <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> 関数の返り値と同じ型の、高レベルなファイルオブジェクトを作成します。従って、 <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">os.popen()</span></code></a> によって作成されたパイプ <em>p</em> から <em>n</em> バイト分だけ読み取るには、 <code class="docutils literal"><span class="pre">p.read(n)</span></code> を使う必要があります。</p>
</div>
<div class="section" id="how-do-i-run-a-subprocess-with-pipes-connected-to-both-input-and-output">
<h3><a class="toc-backref" href="#id25">パイプを入力と出力の両方に接続してサブプロセスを動かすにはどうしますか？</a><a class="headerlink" href="#how-do-i-run-a-subprocess-with-pipes-connected-to-both-input-and-output" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/popen2.html#module-popen2" title="popen2: Subprocesses with accessible standard I/O streams. (非推奨)"><code class="xref py py-mod docutils literal"><span class="pre">popen2</span></code></a> モジュールを使ってください。例えば:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">popen2</span>
<span class="n">fromchild</span><span class="p">,</span> <span class="n">tochild</span> <span class="o">=</span> <span class="n">popen2</span><span class="o">.</span><span class="n">popen2</span><span class="p">(</span><span class="s2">&quot;command&quot;</span><span class="p">)</span>
<span class="n">tochild</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;input</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">tochild</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">fromchild</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</pre></div>
</div>
<p>警告: 一般的に、これをするのは賢くありません。子があなたからの入力を待ってブロックされている間、プロセスが子からの入力を待ってブロックされているというようなデッドロックを引き起こしやすいからです。これは、親が子がそれよりも多くのテキストを出力することを期待することにより、あるいはデータが書きださされないことで標準入出力バッファがスタックにあることにより起こります。Python の親はもちろん子に送るデータを出力を読み込む前に明示的に書きだすことができますが、子が素朴な C プログラムであると、それが対話的なものであってさえ、書き出しが通常自動的なものであるがゆえ、明示的に出力を書き出さないように書かれていることがあります。</p>
<p>なお、デッドロックは <code class="xref py py-func docutils literal"><span class="pre">popen3()</span></code> を使って標準出力や標準エラー出力を読み込むときにも起こりえます。これらのどちらかが内部バッファにとって大きすぎる (バッファサイズを増やしても役に立ちません) とき、もう片方を先に <code class="docutils literal"><span class="pre">read()</span></code> すると、同じくデッドロックが起こります。</p>
<p>popen2 におけるバグの注釈: プログラムが <code class="docutils literal"><span class="pre">wait()</span></code> や <code class="docutils literal"><span class="pre">waitpid()</span></code> を呼び出さないかぎり、終了されていない子プロセスは取り除かれることがなく、いずれ popen2 を呼び出すときに、子プロセス数の制限のために失敗することがあります。<a class="reference internal" href="../library/os.html#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">os.waitpid()</span></code></a> を <a class="reference internal" href="../library/os.html#os.WNOHANG" title="os.WNOHANG"><code class="xref py py-data docutils literal"><span class="pre">os.WNOHANG</span></code></a> オプションをつけて呼び出すことで、これを防げます。このような呼び出しをする場所は、 <code class="docutils literal"><span class="pre">popen2</span></code> を再び呼びだす前がいいです。</p>
<p>多くの場合、本当にやるべきことは、コマンドを通して少しのデータを実行し、結果を戻させることだけです。データの量がとても多いのでない限り、最も簡単な方法は、それを一時ファイルに書きこみ、一時ファイルと入力としてコマンドを実行することです。標準モジュール <a class="reference internal" href="../library/tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal"><span class="pre">tempfile</span></code></a> は、一意の一時ファイル名を生成する <a class="reference internal" href="../library/tempfile.html#tempfile.mktemp" title="tempfile.mktemp"><code class="xref py py-func docutils literal"><span class="pre">mktemp()</span></code></a> 関数をエクスポートします:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">class</span> <span class="nc">Popen3</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a deadlock-safe version of popen that returns</span>
<span class="sd">    an object with errorlevel, out (a string) and err (a string).</span>
<span class="sd">    (capturestderr may not work under windows.)</span>
<span class="sd">    Example: print Popen3(&#39;grep spam&#39;,&#39;\n\nhere spam\n\n&#39;).out</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">command</span><span class="p">,</span><span class="nb">input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">capturestderr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">outfile</span><span class="o">=</span><span class="n">tempfile</span><span class="o">.</span><span class="n">mktemp</span><span class="p">()</span>
        <span class="n">command</span><span class="o">=</span><span class="s2">&quot;( </span><span class="si">%s</span><span class="s2"> ) &gt; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">command</span><span class="p">,</span><span class="n">outfile</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">input</span><span class="p">:</span>
            <span class="n">infile</span><span class="o">=</span><span class="n">tempfile</span><span class="o">.</span><span class="n">mktemp</span><span class="p">()</span>
            <span class="nb">open</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
            <span class="n">command</span><span class="o">=</span><span class="n">command</span><span class="o">+</span><span class="s2">&quot; &lt;&quot;</span><span class="o">+</span><span class="n">infile</span>
        <span class="k">if</span> <span class="n">capturestderr</span><span class="p">:</span>
            <span class="n">errfile</span><span class="o">=</span><span class="n">tempfile</span><span class="o">.</span><span class="n">mktemp</span><span class="p">()</span>
            <span class="n">command</span><span class="o">=</span><span class="n">command</span><span class="o">+</span><span class="s2">&quot; 2&gt;&quot;</span><span class="o">+</span><span class="n">errfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errorlevel</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">command</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">input</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">capturestderr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">err</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">errfile</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">errfile</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that many interactive programs (e.g. vi) don’t work well with pipes
substituted for standard input and output.  You will have to use pseudo ttys
(&quot;ptys&quot;) instead of pipes. Or you can use a Python interface to Don Libes'
&quot;expect&quot; library.  A Python extension that interfaces to expect is called &quot;expy&quot;
and available from <a class="reference external" href="http://expectpy.sourceforge.net">http://expectpy.sourceforge.net</a>.  A pure Python solution that
works like expect is <a class="reference external" href="https://pypi.python.org/pypi/pexpect/">pexpect</a>.</p>
</div>
<div class="section" id="how-do-i-access-the-serial-rs232-port">
<h3><a class="toc-backref" href="#id26">シリアル (RS232) ポートにアクセスするにはどうしますか？</a><a class="headerlink" href="#how-do-i-access-the-serial-rs232-port" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Win32、POSIX (Linux、BSD、など)、Jythonでは:</p>
<blockquote>
<div><a class="reference external" href="http://pyserial.sourceforge.net">http://pyserial.sourceforge.net</a></div></blockquote>
<p>Unix では、Mitch Chapman による Usenet の投稿を参照してください:</p>
<blockquote>
<div><a class="reference external" href="https://groups.google.com/groups?selm=34A04430.CF9&#64;ohioee.com">https://groups.google.com/groups?selm=34A04430.CF9&#64;ohioee.com</a></div></blockquote>
</div>
<div class="section" id="why-doesn-t-closing-sys-stdout-stdin-stderr-really-close-it">
<h3><a class="toc-backref" href="#id27">sys.stdout (stdin, stderr) を閉じようとしても実際に閉じられないのはなぜですか？</a><a class="headerlink" href="#why-doesn-t-closing-sys-stdout-stdin-stderr-really-close-it" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python のファイルオブジェクトは、 (ここで説明する中では) 低レベルな C ファイルディスクリプタの上にある、中レベルな抽象のレイヤである C ストリームのそのまた上にある、高レベルな抽象のレイヤです。</p>
<p>組み込みの <code class="docutils literal"><span class="pre">open</span></code> 関数によって生成されたほとんどのファイルオブジェクトでは、<code class="docutils literal"><span class="pre">f.close()</span></code> は Python ファイルオブジェクトが Python の視点からは閉じられているものとする印をつけ、その下にある C ファイルディスクリプタを閉じるように手配します。これは、<code class="docutils literal"><span class="pre">f</span></code> がガベージとなったときにも、<code class="docutils literal"><span class="pre">f</span></code> のデストラクタで自動的に起こります。</p>
<p>しかし、stdin、stdout、stderr は C で特別な立場が与えられていることから、 Python でも同様に特別に扱われます。<code class="docutils literal"><span class="pre">sys.stdout.close()</span></code> を実行すると、 Python レベルのファイルオブジェクトには閉じられているものとする印がつけられますが、C ファイルディスクリプタは <em>閉じられません</em>。</p>
<p>下にある C ファイルディスクリプタのうち、この三つのどれかを閉じるには、まず本当に閉じる必要があることを確かめるべきです (例えば、拡張モジュールの I/O を混乱させてしまうかもしれません)。本当に必要ならば、 <code class="docutils literal"><span class="pre">os.close</span></code> を使ってください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># close C&#39;s stdin stream</span>
<span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># close C&#39;s stdout stream</span>
<span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="c1"># close C&#39;s stderr stream</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="network-internet-programming">
<h2><a class="toc-backref" href="#id28">ネットワーク/インターネットプログラミング</a><a class="headerlink" href="#network-internet-programming" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="what-www-tools-are-there-for-python">
<h3><a class="toc-backref" href="#id29">Python の WWW ツールには何がありますか？</a><a class="headerlink" href="#what-www-tools-are-there-for-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ライブラリリファレンスマニュアルの <a class="reference internal" href="../library/internet.html#internet"><span class="std std-ref">インターネットプロトコルとサポート</span></a> と <a class="reference internal" href="../library/netdata.html#netdata"><span class="std std-ref">インターネット上のデータの操作</span></a> という章を参照してください。Python には、サーバーサイドとクライアントサイドの web システムを構築するのに便利な多くのモジュールがあります。</p>
<p>利用可能なフレームワークの概要は Paul Boddie によって、<a class="reference external" href="https://wiki.python.org/moin/WebProgramming">https://wiki.python.org/moin/WebProgramming</a> でメンテナンスされています。</p>
<p>Cameron Laird は、<a class="reference external" href="http://phaseit.net/claird/comp.lang.python/web_python">http://phaseit.net/claird/comp.lang.python/web_python</a> で Python のウェブ技術に関する便利なページ群を整備しています。</p>
</div>
<div class="section" id="how-can-i-mimic-cgi-form-submission-method-post">
<h3><a class="toc-backref" href="#id30">CGI フォームの発信 (METHOD=POST) を模倣するにはどうしますか？</a><a class="headerlink" href="#how-can-i-mimic-cgi-form-submission-method-post" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>フォームを POST した結果のウェブページを取得したいです。簡単に取得するためのコードはあるでしょうか？</p>
<p>あります。これは urllib.request を利用した簡単な例です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="ch">#!/usr/local/bin/python</span>

<span class="kn">import</span> <span class="nn">httplib</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">time</span>

<span class="c1"># build the query string</span>
<span class="n">qs</span> <span class="o">=</span> <span class="s2">&quot;First=Josephine&amp;MI=Q&amp;Last=Public&quot;</span>

<span class="c1"># connect and send the server a path</span>
<span class="n">httpobj</span> <span class="o">=</span> <span class="n">httplib</span><span class="o">.</span><span class="n">HTTP</span><span class="p">(</span><span class="s1">&#39;www.some-server.out-there&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">putrequest</span><span class="p">(</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;/cgi-bin/some-cgi-script&#39;</span><span class="p">)</span>
<span class="c1"># now generate the rest of the HTTP headers...</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">putheader</span><span class="p">(</span><span class="s1">&#39;Accept&#39;</span><span class="p">,</span> <span class="s1">&#39;*/*&#39;</span><span class="p">)</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">putheader</span><span class="p">(</span><span class="s1">&#39;Connection&#39;</span><span class="p">,</span> <span class="s1">&#39;Keep-Alive&#39;</span><span class="p">)</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">putheader</span><span class="p">(</span><span class="s1">&#39;Content-type&#39;</span><span class="p">,</span> <span class="s1">&#39;application/x-www-form-urlencoded&#39;</span><span class="p">)</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">putheader</span><span class="p">(</span><span class="s1">&#39;Content-length&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">qs</span><span class="p">))</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">endheaders</span><span class="p">()</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">qs</span><span class="p">)</span>
<span class="c1"># find out what the server said in response...</span>
<span class="n">reply</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">hdrs</span> <span class="o">=</span> <span class="n">httpobj</span><span class="o">.</span><span class="n">getreply</span><span class="p">()</span>
<span class="k">if</span> <span class="n">reply</span> <span class="o">!=</span> <span class="mi">200</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">httpobj</span><span class="o">.</span><span class="n">getfile</span><span class="p">()</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</pre></div>
</div>
<p>なお、一般にパーセントエンコードされた POST 演算では、クエリ文字列は必ず <a class="reference internal" href="../library/urllib.html#urllib.urlencode" title="urllib.urlencode"><code class="xref py py-func docutils literal"><span class="pre">urllib.urlencode()</span></code></a> で引用されなくてはなりません。例えば name <code class="docutils literal"><span class="pre">Guy</span> <span class="pre">Steele,</span> <span class="pre">Jr.</span></code> を送信するには:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urllib</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Guy Steele, Jr.&#39;</span><span class="p">})</span>
<span class="go">&#39;name=Guy+Steele%2C+Jr.&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="what-module-should-i-use-to-help-with-generating-html">
<h3><a class="toc-backref" href="#id31">どのモジュールが HTML の生成の役に立ちますか？</a><a class="headerlink" href="#what-module-should-i-use-to-help-with-generating-html" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference external" href="https://wiki.python.org/moin/WebProgramming">Web Programming についての wiki のページ</a> から役に立つリンクが見付けられます。</p>
</div>
<div class="section" id="how-do-i-send-mail-from-a-python-script">
<h3><a class="toc-backref" href="#id32">Python のスクリプトからメールを送るにはどうしますか？</a><a class="headerlink" href="#how-do-i-send-mail-from-a-python-script" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>標準ライブラリモジュール <a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">smtplib</span></code></a> を使ってください。</p>
<p>以下に示すのが、これを使ったごく単純な対話型のメール送信器です。このメソッドは SMTP リスナをサポートするホストならどこででも作動します。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">smtplib</span>

<span class="n">fromaddr</span> <span class="o">=</span> <span class="n">raw_input</span><span class="p">(</span><span class="s2">&quot;From: &quot;</span><span class="p">)</span>
<span class="n">toaddrs</span>  <span class="o">=</span> <span class="n">raw_input</span><span class="p">(</span><span class="s2">&quot;To: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="s2">&quot;Enter message, end with ^D:&quot;</span>
<span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="n">line</span>

<span class="c1"># The actual mail send</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">sendmail</span><span class="p">(</span><span class="n">fromaddr</span><span class="p">,</span> <span class="n">toaddrs</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre></div>
</div>
<p>Unix 限定の代わりの選択肢は sendmail を使うことです。sendmail プログラムの場所はシステムによって様々です; あるときは <code class="docutils literal"><span class="pre">/usr/lib/sendmail</span></code> だったり、あるときは <code class="docutils literal"><span class="pre">/usr/sbin/sendmail</span></code> だったり。sendmail のマニュアルページが助けになるでしょう。サンプルコードはこのようになります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>

<span class="n">SENDMAIL</span> <span class="o">=</span> <span class="s2">&quot;/usr/sbin/sendmail&quot;</span>  <span class="c1"># sendmail location</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> -t -i&quot;</span> <span class="o">%</span> <span class="n">SENDMAIL</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;To: receiver@example.com</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Subject: test</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># blank line separating headers from body</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Some text</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;some more text</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">sts</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">if</span> <span class="n">sts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span> <span class="s2">&quot;Sendmail exit status&quot;</span><span class="p">,</span> <span class="n">sts</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-i-avoid-blocking-in-the-connect-method-of-a-socket">
<h3><a class="toc-backref" href="#id33">ソケットの connect() メソッドでブロッキングされなくするにはどうしますか？</a><a class="headerlink" href="#how-do-i-avoid-blocking-in-the-connect-method-of-a-socket" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>主に select モジュールがソケットの非同期の I/O を扱うのに使われます。</p>
<p>TCP 接続がブロッキングされないようにするために、ソケットをノンブロッキングモードに設定することが出来ます。そして <code class="docutils literal"><span class="pre">connect()</span></code> したときに、即座に接続できるか、エラー番号を <code class="docutils literal"><span class="pre">.errno</span></code> として含む例外を受け取るかのどちらかになります。<code class="docutils literal"><span class="pre">errno.EINPROGRESS</span></code> は、接続が進行中であるが、まだ完了していないということを示します。異なる OS では異なる値が返されるので、あなたのシステムで何が返されるかを確かめておく必要があります。</p>
<p><code class="docutils literal"><span class="pre">connect_ex()</span></code> メソッドを使えば例外を生成しなくて済みます。これは単に errno の値を返すでしょう。ポーリングのためには、後でまた <code class="docutils literal"><span class="pre">connect_ex()</span></code> を呼び出すことができます – 0 または <code class="docutils literal"><span class="pre">errno.EISCONN</span></code> は接続されたことを表します – または、選択するソケットにこれを渡して書き込み可能か調べることができます。</p>
</div>
</div>
<div class="section" id="databases">
<h2><a class="toc-backref" href="#id34">データベース</a><a class="headerlink" href="#databases" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="are-there-any-interfaces-to-database-packages-in-python">
<h3><a class="toc-backref" href="#id35">Python にはデータベースパッケージへのインタフェースはありますか？</a><a class="headerlink" href="#are-there-any-interfaces-to-database-packages-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。</p>
<p><code class="xref py py-mod docutils literal"><span class="pre">DBM</span></code> や <code class="xref py py-mod docutils literal"><span class="pre">GDBM</span></code> のような、ディスクに基づくハッシュへのインタフェースも標準の Python に含まれています。ディスクに基づく軽量なリレーショナルデータベースを提供する <a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal"><span class="pre">sqlite3</span></code></a> モジュールもあります。</p>
<p>ほとんどの相対データベースがサポートされています。詳細は <a class="reference external" href="https://wiki.python.org/moin/DatabaseProgramming">DatabaseProgramming wiki page</a> を参照してください。</p>
</div>
<div class="section" id="how-do-you-implement-persistent-objects-in-python">
<h3><a class="toc-backref" href="#id36">Python で永続的なオブジェクトを実装するにはどうしますか？</a><a class="headerlink" href="#how-do-you-implement-persistent-objects-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a> ライブラリモジュールで、ごく一般的な方法でこれを解決できます (開かれたファイル、ソケット、ウィンドウのようなものを保管することはできませんが)。<a class="reference internal" href="../library/shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal"><span class="pre">shelve</span></code></a> ライブラリモジュールは pickle と (g)dbm を使い、任意の Python オブジェクトを含む永続的なマッピングを生成します。パフォーマンスを良くするために、<a class="reference internal" href="../library/pickle.html#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code class="xref py py-mod docutils literal"><span class="pre">cPickle</span></code></a> モジュールを使うこともできます。</p>
<p>もっと不器用な方法は、pickle の妹分である marshal を使うことです。 <a class="reference internal" href="../library/marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal"><span class="pre">marshal</span></code></a> モジュールは、再帰的でない標準の Python 型を、ファイルや文字列にとても高速に保存したり、元に戻したりする方法を提供します。 marshal では、インスタンスの保存や共有される参照の適切な処理などの派手なことはできませんが、極端に速く動作します。例えば、半メガバイトのデータに 3 分の 1 秒も掛からないでしょう。これは多くの場合、 pickle/shelve で gdbm を使うというような、複雑な一般の方法に勝ります。</p>
</div>
<div class="section" id="why-is-cpickle-so-slow">
<h3><a class="toc-backref" href="#id37">なぜ cPickle はこんなに遅いのですか？</a><a class="headerlink" href="#why-is-cpickle-so-slow" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a> モジュールは後方互換性のために、ちょっと古くて遅いフォーマットをデフォルトで使います。ですが速いほかのプロトコルバージョンを指定出来ます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">largeString</span> <span class="o">=</span> <span class="s1">&#39;z&#39;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
<span class="n">myPickle</span> <span class="o">=</span> <span class="n">cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">largeString</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="if-my-program-crashes-with-a-bsddb-or-anydbm-database-open-it-gets-corrupted-how-come">
<h3><a class="toc-backref" href="#id38">bsddb (or anydbm) データベースが開かれたままプログラムがクラッシュすると、だめになってしまいます。なぜですか？</a><a class="headerlink" href="#if-my-program-crashes-with-a-bsddb-or-anydbm-database-open-it-gets-corrupted-how-come" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>bsddb モジュール (やしばしば anydbm モジュール。優先的に bsddb を使うでしょうから) で書き込みのために開かれたデータベースは、データベースの <code class="docutils literal"><span class="pre">.close()</span></code> メソッドで明示的に閉じられなければなりません。その基礎にあるライブラリは、ディスク上の形式に変換されて書き込まれるべきデータベースの中身を、キャッシュします。</p>
<p>新しい bsddb データベースを初期化したけれどプログラムのクラッシュ時までに何も書き込まれていないとき、長さ 0 のファイルで終わることになり、次にそのファイルが開かれたときに例外に出くわすでしょう。</p>
</div>
<div class="section" id="i-tried-to-open-berkeley-db-file-but-bsddb-produces-bsddb-error-22-invalid-argument-help-how-can-i-restore-my-data">
<h3><a class="toc-backref" href="#id39">Berkeley DB ファイルを開こうとしましたが、bsddb が bsddb.error: (22, 'Invalid argument') を生じます。助けてください！データを復元するにはどうしたら良いですか？</a><a class="headerlink" href="#i-tried-to-open-berkeley-db-file-but-bsddb-produces-bsddb-error-22-invalid-argument-help-how-can-i-restore-my-data" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>慌てないでください！あなたのデータはおそらく無事です。このエラーの一番ありがちな原因は、新しいバージョンの Berkeley DB ライブラリから古い Berkeley DB ファイルを開こうとすることです。</p>
<p>多くの Linux システムで、今では 3 種類全てのバージョンの Berkeley DB が利用できます。バージョン 1 から新しいバージョンに移行するには、 db_dump185 でデータベースのプレーンテキスト版をダンプしてください。バージョン 2 からバージョン 3 に移行するには、db_2dump でデータベースのプレーンテキスト版を生成してください。そのどちらの場合でも、db_load でコンピュータにインストールされている最新バージョンの新しいネイティブデータベースを生成してください。バージョン 3 の Berkeley DB がインストールされているなら、db2_load でネイティブのバージョン 2 のデータベースを生成できるでしょう。</p>
<p>Berkeley DB バージョン 1 のハッシュファイルコードにはデータを破壊する既知のバグがありますから、使うのをやめるべきです。</p>
</div>
</div>
<div class="section" id="mathematics-and-numerics">
<h2><a class="toc-backref" href="#id40">数学と数</a><a class="headerlink" href="#mathematics-and-numerics" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-generate-random-numbers-in-python">
<h3><a class="toc-backref" href="#id41">Python でランダムな数を生成するにはどうしますか？</a><a class="headerlink" href="#how-do-i-generate-random-numbers-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>標準モジュールの <a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal"><span class="pre">random</span></code></a> がランダムな数の生成器を実装しています。使い方は単純です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
</pre></div>
</div>
<p>これは区間 [0, 1) 内のランダムな浮動小数点数を返します。</p>
<p>このモジュールにはその他多くの特化した生成器もあります。例えば:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">randrange(a,</span> <span class="pre">b)</span></code> は区間 [a, b) から整数を選びます。</li>
<li><code class="docutils literal"><span class="pre">uniform(a,</span> <span class="pre">b)</span></code> は区間 [a, b) から浮動小数点数を選びます。</li>
<li><code class="docutils literal"><span class="pre">normalvariate(mean,</span> <span class="pre">sdev)</span></code> は正規(ガウス)分布をサンプリングします。</li>
</ul>
<p>シーケンスに直接作用する高水準な関数もあります。例えば:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">choice(S)</span></code> は与えられたシーケンスからランダムな要素を選びます。</li>
<li><code class="docutils literal"><span class="pre">shuffle(L)</span></code> はリストをインプレースにシャッフルします。すなわち、ランダムに並び替えます。</li>
</ul>
<p><code class="docutils literal"><span class="pre">Random</span></code> クラスのインスタンスを生成して、複数の独立なランダムな数の生成器をつくることもできます。</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">ライブラリと拡張 FAQ</a><ul>
<li><a class="reference internal" href="#general-library-questions">ライブラリ一般の質問</a></li>
<li><a class="reference internal" href="#common-tasks">よくある作業</a></li>
<li><a class="reference internal" href="#threads">スレッド</a></li>
<li><a class="reference internal" href="#input-and-output">入力と出力</a></li>
<li><a class="reference internal" href="#network-internet-programming">ネットワーク/インターネットプログラミング</a></li>
<li><a class="reference internal" href="#databases">データベース</a></li>
<li><a class="reference internal" href="#mathematics-and-numerics">数学と数</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="design.html"
                        title="前の章へ">デザインと歴史 FAQ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="extending.html"
                        title="次の章へ">拡張と埋め込み FAQ</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">バグ報告</a></li>
  <li><a href="https://github.com/python/cpython/blob/2.7/Doc/faq/library.rst"
         rel="nofollow">ソースの表示</a>
  </li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="extending.html" title="拡張と埋め込み FAQ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.14</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python よくある質問</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2018, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト).
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 2018-06-05
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>