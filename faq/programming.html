<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>プログラミング FAQ &#8212; Python 2.7.13 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.13',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7.13 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 2.7.13 ドキュメント" href="../contents.html" />
    <link rel="up" title="Python よくある質問" href="index.html" />
    <link rel="next" title="デザインと歴史 FAQ" href="design.html" />
    <link rel="prev" title="一般 Python FAQ" href="general.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/faq/programming.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="general.html" title="一般 Python FAQ"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.13</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python よくある質問</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="programming-faq">
<h1><a class="toc-backref" href="#id1">プログラミング FAQ</a><a class="headerlink" href="#programming-faq" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#programming-faq" id="id1">プログラミング FAQ</a><ul>
<li><a class="reference internal" href="#general-questions" id="id2">一般的な質問</a><ul>
<li><a class="reference internal" href="#is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc" id="id3">ブレークポイントやシングルステップ実行などを備えたソースコードレベルデバッガはありますか？</a></li>
<li><a class="reference internal" href="#is-there-a-tool-to-help-find-bugs-or-perform-static-analysis" id="id4">バグの発見や静的分析に役立つツールはありますか？</a></li>
<li><a class="reference internal" href="#how-can-i-create-a-stand-alone-binary-from-a-python-script" id="id5">どうしたら Python スクリプトからスタンドアロンバイナリを作れますか？</a></li>
<li><a class="reference internal" href="#are-there-coding-standards-or-a-style-guide-for-python-programs" id="id6">Python プログラムのためのコーディングスタンダードやスタイルガイドはありますか？</a></li>
<li><a class="reference internal" href="#my-program-is-too-slow-how-do-i-speed-it-up" id="id7">プログラムが遅すぎます。どうしたら速くなりますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#core-language" id="id8">コア言語</a><ul>
<li><a class="reference internal" href="#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" id="id9">なぜ変数に値があるのに UnboundLocalError が出るのですか？</a></li>
<li><a class="reference internal" href="#what-are-the-rules-for-local-and-global-variables-in-python" id="id10">Python のローカルとグローバル変数のルールは何ですか？</a></li>
<li><a class="reference internal" href="#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" id="id11">ループの中で異なる値で定義されたラムダ式が、同じ値を返すのはなぜですか？</a></li>
<li><a class="reference internal" href="#how-do-i-share-global-variables-across-modules" id="id12">グローバル変数をモジュール間で共有するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#what-are-the-best-practices-for-using-import-in-a-module" id="id13">モジュールで import を使う際の「ベストプラクティス」は何ですか？</a></li>
<li><a class="reference internal" href="#why-are-default-values-shared-between-objects" id="id14">なぜオブジェクト間でデフォルト値が共有されるのですか？</a></li>
<li><a class="reference internal" href="#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another" id="id15">オプションパラメータやキーワードパラメータを関数から関数へ渡すにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#what-is-the-difference-between-arguments-and-parameters" id="id16">実引数と仮引数の違いは何ですか?</a></li>
<li><a class="reference internal" href="#why-did-changing-list-y-also-change-list-x" id="id17">なぜ list &#8216;y&#8217; を変更すると list &#8216;x&#8217; も変更されるのですか?</a></li>
<li><a class="reference internal" href="#how-do-i-write-a-function-with-output-parameters-call-by-reference" id="id18">パラメータを出力する関数 (参照渡し) はどのように書きますか？</a></li>
<li><a class="reference internal" href="#how-do-you-make-a-higher-order-function-in-python" id="id19">Python で高次関数はどのようにつくりますか？</a></li>
<li><a class="reference internal" href="#how-do-i-copy-an-object-in-python" id="id20">Python のオブジェクトはどのようにコピーしますか？</a></li>
<li><a class="reference internal" href="#how-can-i-find-the-methods-or-attributes-of-an-object" id="id21">オブジェクトのメソッドや属性はどのように見つけますか？</a></li>
<li><a class="reference internal" href="#how-can-my-code-discover-the-name-of-an-object" id="id22">コードはどのようにオブジェクトの名前を見つけるのですか？</a></li>
<li><a class="reference internal" href="#what-s-up-with-the-comma-operator-s-precedence" id="id23">カンマ演算子はなぜ優先されるのですか？</a></li>
<li><a class="reference internal" href="#is-there-an-equivalent-of-c-s-ternary-operator" id="id24">C の &#8221;?:&#8221; 三項演算子と等価なものはありますか？</a></li>
<li><a class="reference internal" href="#is-it-possible-to-write-obfuscated-one-liners-in-python" id="id25">Python で解し難いワンライナーを書くことはできますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#numbers-and-strings" id="id26">数と文字列</a><ul>
<li><a class="reference internal" href="#how-do-i-specify-hexadecimal-and-octal-integers" id="id27">十六進数や八進数を指定するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#why-does-22-10-return-3" id="id28">なぜ -22 // 10 は -3 を返すのですか？</a></li>
<li><a class="reference internal" href="#how-do-i-convert-a-string-to-a-number" id="id29">文字列を数に変換するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#how-do-i-convert-a-number-to-a-string" id="id30">数を文字列に変換するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#how-do-i-modify-a-string-in-place" id="id31">文字列をインプレースに変更するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#how-do-i-use-strings-to-call-functions-methods" id="id32">関数やメソッドを呼ぶのに文字列を使うにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings" id="id33">文字列から後端の改行を取り除く Perl の chomp() に相当するものはありますか？</a></li>
<li><a class="reference internal" href="#is-there-a-scanf-or-sscanf-equivalent" id="id34">scanf() や sscanf() と同等なものはありますか？</a></li>
<li><a class="reference internal" href="#what-does-unicodeerror-ascii-decoding-encoding-error-ordinal-not-in-range-128-mean" id="id35">&#8216;UnicodeError: ASCII [decoding,encoding] error: ordinal not in range(128)&#8217; とはどういう意味ですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequences-tuples-lists" id="id36">シーケンス(タプル/リスト)</a><ul>
<li><a class="reference internal" href="#how-do-i-convert-between-tuples-and-lists" id="id37">タプル、リスト間の変更はどのようにするのですか？</a></li>
<li><a class="reference internal" href="#what-s-a-negative-index" id="id38">インデクスが負の場合はどうなりますか？</a></li>
<li><a class="reference internal" href="#how-do-i-iterate-over-a-sequence-in-reverse-order" id="id39">シーケンスを逆順にイテレートするにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#how-do-you-remove-duplicates-from-a-list" id="id40">リストから重複を取り除くにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-you-make-an-array-in-python" id="id41">Python で配列を作るにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-create-a-multidimensional-list" id="id42">多次元のリストを作るにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-apply-a-method-to-a-sequence-of-objects" id="id43">オブジェクトのシーケンスにメソッドを適用するにはどうしますか？</a></li>
<li><a class="reference internal" href="#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works" id="id44">なぜ加算はされるのに a_tuple[i] += [&#8216;item&#8217;] は例外を送出するのですか?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dictionaries" id="id45">辞書</a><ul>
<li><a class="reference internal" href="#how-can-i-get-a-dictionary-to-display-its-keys-in-a-consistent-order" id="id46">一貫した順序でキーを表示する辞書はありますか?</a></li>
<li><a class="reference internal" href="#i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python" id="id47">複雑なソートがしたいのですが、Python でシュワルツ変換はできますか？</a></li>
<li><a class="reference internal" href="#how-can-i-sort-one-list-by-values-from-another-list" id="id48">リストを別のリストの値によってソートするにはどうしますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#objects" id="id49">オブジェクト</a><ul>
<li><a class="reference internal" href="#what-is-a-class" id="id50">クラスとは何ですか？</a></li>
<li><a class="reference internal" href="#what-is-a-method" id="id51">メソッドとは何ですか？</a></li>
<li><a class="reference internal" href="#what-is-self" id="id52">self とは何ですか？</a></li>
<li><a class="reference internal" href="#how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it" id="id53">あるオブジェクトが、与えられたクラスやそのサブクラスのインスタンスであるかを調べるにはどうしますか？</a></li>
<li><a class="reference internal" href="#what-is-delegation" id="id54">委譲とは何ですか？</a></li>
<li><a class="reference internal" href="#how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-overrides-it" id="id55">基底クラスで定義されたメソッドを、そのクラスをオーバーライドした派生クラスから呼び出すにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class" id="id56">基底クラスの名前を変えやすいコードを書くにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-create-static-class-data-and-static-class-methods" id="id57">静的なクラスデータや静的なクラスメソッドを作るにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-can-i-overload-constructors-or-methods-in-python" id="id58">Python でコンストラクタ(やメソッド)をオーバーロードするにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam" id="id59">__spam を使おうとしたら _SomeClassName__spam からエラーがでました。</a></li>
<li><a class="reference internal" href="#my-class-defines-del-but-it-is-not-called-when-i-delete-the-object" id="id60">クラスに __del__ メソッドを定義しているのですが、オブジェクトを削除したときに呼ばれません。</a></li>
<li><a class="reference internal" href="#how-do-i-get-a-list-of-all-instances-of-a-given-class" id="id61">与えられたクラスのすべてのインスタンスのリストを得るにはどうしますか？</a></li>
<li><a class="reference internal" href="#why-does-the-result-of-id-appear-to-be-not-unique" id="id62">なぜ <code class="docutils literal"><span class="pre">id()</span></code> の結果は一意でないように見えるのですか?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modules" id="id63">モジュール</a><ul>
<li><a class="reference internal" href="#how-do-i-create-a-pyc-file" id="id64">.pyc ファイルを作るにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-find-the-current-module-name" id="id65">現在のモジュール名を知るにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-can-i-have-modules-that-mutually-import-each-other" id="id66">相互にインポートしあうモジュールを作るにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#import-x-y-z-returns-module-x-how-do-i-get-z" id="id67">__import__(&#8216;x.y.z&#8217;) は &lt;module &#8216;x&#8217;&gt; を返しますが、z を得るためにはどうしますか？</a></li>
<li><a class="reference internal" href="#when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen" id="id68">インポートされたモジュールを編集してから再インポートしましたが、変化が現れません。なぜですか？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="general-questions">
<h2><a class="toc-backref" href="#id2">一般的な質問</a><a class="headerlink" href="#general-questions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc">
<h3><a class="toc-backref" href="#id3">ブレークポイントやシングルステップ実行などを備えたソースコードレベルデバッガはありますか？</a><a class="headerlink" href="#is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。</p>
<p>pdb モジュールは簡素にして十分な Python のコンソールモードデバッガです。これは Python の標準ライブラリに含まれているもので、 <a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal"><span class="pre">ライブラリリファレンスマニュアルにドキュメントがあります</span></code></a> 。 pdb のコードを手本にして自分用のデバッガを書くこともできます。</p>
<p>Python に同梱されている統合開発環境の IDLE は通常の Python の配布形態の一部 (普通は Tools/scripts/idle から利用可能) であり、グラフィカルなデバッガを含んでいます。</p>
<p>PythonWin は、pdb をベースとした GUI デバッガを含む Python IDE です。Pythonwin デバッガは、ブレークポイントの色付けや非 Pythonwin プログラムのデバッグなどのたくさんの素敵な機能を持っています。Pythonwin は <a class="reference external" href="https://sourceforge.net/projects/pywin32/">Python for Windows Extensions</a> プロジェクトの一部、あるいは ActivePython ディストリビューション (<a class="reference external" href="https://www.activestate.com/activepython">https://www.activestate.com/activepython</a> を参照) の一部として利用可能です。</p>
<p><a class="reference external" href="http://boa-constructor.sourceforge.net/">Boa Constructor</a> は、wxWidgets を使った IDE と GUI ビルダーです。これは視覚フレームの作成と操作、オブジェクト検査、オブジェクトブラウザのような多くのビュー、継承構造、doc string から生成される html ドキュメント、高度なデバッガ、総合ヘルプ、Zope のサポートを提供します。</p>
<p><a class="reference external" href="http://eric-ide.python-projects.org/">Eric</a> は PyQt や Scintilla editing component をもとにした IDE です。</p>
<p>Pydb は標準のデバッガである pdb を人気のグラフィカルデバッガフロントエンドである DDD (Data Display Debugger) とともに使うために改変したものです。Pydb は <a class="reference external" href="http://bashdb.sourceforge.net/pydb/">http://bashdb.sourceforge.net/pydb/</a> に、 DDD は <a class="reference external" href="https://www.gnu.org/software/ddd">https://www.gnu.org/software/ddd</a> にあります。</p>
<p>商業のグラフィカルデバッガ付き Python IDE もあります。例えば:</p>
<ul class="simple">
<li>Wing IDE (<a class="reference external" href="https://wingware.com/">https://wingware.com/</a>)</li>
<li>Komodo IDE (<a class="reference external" href="https://komodoide.com/">https://komodoide.com/</a>)</li>
<li>PyCharm (<a class="reference external" href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a>)</li>
</ul>
</div>
<div class="section" id="is-there-a-tool-to-help-find-bugs-or-perform-static-analysis">
<h3><a class="toc-backref" href="#id4">バグの発見や静的分析に役立つツールはありますか？</a><a class="headerlink" href="#is-there-a-tool-to-help-find-bugs-or-perform-static-analysis" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。</p>
<p>PyChecker は Python ソースコードのバグを発見しコードの複雑さとスタイルについて警告する静的解析ツールです。PyChecker は <a class="reference external" href="http://pychecker.sourceforge.net/">http://pychecker.sourceforge.net/</a> から手に入ります。</p>
<p><a class="reference external" href="https://www.pylint.org/">Pylint</a> も、モジュールがコーディング標準を満たすかを調べ、プラグインを書いてカスタム機能を加えられるようにするツールです。PyChecker が行うバグチェックに加え、 Pylint は行の長さ、変数名が一貫しているか、宣言されたインタフェースが完全に実装されているか、などを確かめる追加の機能を提供します。 <a class="reference external" href="https://docs.pylint.org/">https://docs.pylint.org/</a> で Pylint の機能の一覧を見られます。</p>
</div>
<div class="section" id="how-can-i-create-a-stand-alone-binary-from-a-python-script">
<h3><a class="toc-backref" href="#id5">どうしたら Python スクリプトからスタンドアロンバイナリを作れますか？</a><a class="headerlink" href="#how-can-i-create-a-stand-alone-binary-from-a-python-script" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ユーザがダウンロードや起動のために Python ディストリビューションをインストールしなくてもよいスタンドアロンプログラムのためだけなら、Python を C コードにコンパイルできる必要はありません。プログラムに対して必要なモジュールを選び、そのモジュールを Python バイナリに束縛して一つの実行可能ファイルにまとめる多くのツールがあります。</p>
<p>一つは freeze ツールで、Python ソースツリーに <code class="docutils literal"><span class="pre">Tools/freeze</span></code> として含まれています。これは Python バイトコードを C 配列に変換します。すべてのモジュールを標準 Python モジュールにリンクされる新しいプログラムに埋め込む C コンパイラです。</p>
<p>これはあなたのソースの (両方の形式の) import 文を再帰的にスキャンして、import されたモジュールを標準の Python パスと (組み込みモジュールのある) ソースディレクトリから探します。そして Python で書かれたモジュールのバイトコードを C コード (marshal モジュールでコードオブジェクトに変換できる配列) に変換し、実際にそのプログラム内で使われている組み込みモジュールだけが含まれたカスタムメイドの設定ファイルを作成します。そして生成された C コードをコンパイルして Python インタプリタの残りとリンクし、元のスクリプトと全く同じように動作する自己充足的なバイナリを形成します。</p>
<p>もちろん、凍結には C コンパイラが必要です。C コンパイラを必要としない選択肢もあります。その一つは、Thomas Heller の py2exe (Windows 専用) です</p>
<blockquote>
<div><a class="reference external" href="http://www.py2exe.org/">http://www.py2exe.org/</a></div></blockquote>
<p>他には Anthony Tuininga の <a class="reference external" href="http://cx-freeze.sourceforge.net/">cx_Freeze</a> があります。</p>
</div>
<div class="section" id="are-there-coding-standards-or-a-style-guide-for-python-programs">
<h3><a class="toc-backref" href="#id6">Python プログラムのためのコーディングスタンダードやスタイルガイドはありますか？</a><a class="headerlink" href="#are-there-coding-standards-or-a-style-guide-for-python-programs" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。標準ライブラリモジュールに求められるコーディングスタイルは <span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a> として文書化されています。</p>
</div>
<div class="section" id="my-program-is-too-slow-how-do-i-speed-it-up">
<h3><a class="toc-backref" href="#id7">プログラムが遅すぎます。どうしたら速くなりますか？</a><a class="headerlink" href="#my-program-is-too-slow-how-do-i-speed-it-up" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一般に、それは難しい質問です。Python コードを速くするためには、いろいろな手法があります。最終手段として一部を C で書き直す事も考えてください。</p>
<p>Python を自動的に C や x86 アセンブリ言語に変換できる場合もあります。この場合、速度を上げるためにコードを変更する必要はありません。</p>
<p><a class="reference external" href="http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/">Pyrex</a> はPython コードの少し変化した版を C 拡張にコンパイルでき、多様なプラットフォームで使えます。(訳注： Pyrex は <a class="reference external" href="https://pypi.python.org/pypi/Cython/">Cython</a> に取って代わられています。)</p>
<p><a class="reference external" href="http://psyco.sourceforge.net">Psyco</a> は Python コードを x86 アセンブリ言語に変換する実行時コンパイラです。これを使うことが出来れば、重要な関数を劇的にスピードアップできます。</p>
<p>あとは、Python コードからもう少し速度を搾り出すための様々な手法について議論することになります。コード中の特定の関数が処理が集中するホットスポットで、最適化が必要であると認められない限り、<em>決して</em> いかなる最適化の手法も使わないでください。最適化はたいていコードを分かりづらくするので、分かりづらさのコスト (開発時間の延長とバグの可能性の増大) がそれに見合ったパフォーマンスの向上につながらないのであれば元が取れません。</p>
<p><a class="reference external" href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips">performance tips</a> に関するページが wiki にあります。</p>
<p>Guido van Rossum は <a class="reference external" href="https://www.python.org/doc/essays/list2str">https://www.python.org/doc/essays/list2str</a> で最適化に関する逸話を詳述しています。</p>
<p>なお、関数や(特に)メソッドの呼び出しはかなり高価です。インスタンス変数を get や set したり他のメソッドを呼び出す程度の小さな関数がたくさんある純粋 OO インタフェースをデザインしているなら、インスタンス変数に直接アクセスするようなもっと直接的な方法も考えてみてください。また、どのプログラムが実行時間の大部分を占めているかを見つける標準モジュール <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal"><span class="pre">profile</span></code></a> も参照してください (ちょっと忍耐できればの話ですが - プロファイリングはそれ自体がプログラムを一桁ほど遅くしてしまいます)。</p>
<p>もちろん、他のプログラミングの経験から得られた多くの標準的な最適化の発見的手法は Python にもよく当てはまることが多いです。たとえば、出力装置に出力を送るときに、一度に少なく書くよりもむしろ多く書いたほうが、カーネルのシステムコールのオーバーヘッドを減らすことができて、速くなるでしょう。したがって、CGI スクリプトは &#8220;一発&#8221; ですべて書き出すもののほうが小さなたくさんの出力に分けて書き出すものよりも速くなるでしょう。</p>
<p>また、必ず Python のコアな機能を適切に使ってください。例えば、スライシングなら、リストや他のシーケンスオブジェクトを、高度に最適化された C 実装で、インタプリタのメインループの一刻みで細切れにできます。こうして効果を得ることができる例は:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">L2</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">L2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>こう使えばずっと短く、ずっと速くできます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">L2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">L1</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># &quot;list&quot; is redundant if L1 is a list.</span>
</pre></div>
</div>
<p>関数指向組み込み関数 <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a> や <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a> なども一つのタスクを実行するためのループを加速するのに便利であることに注意してください。例えば、二つのリストの要素を組み合わせるためには:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
</pre></div>
</div>
<p>また、正弦を一度に計算するには:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">[0.841470984808, 0.909297426826, 0.14112000806, -0.756802495308]</span>
</pre></div>
</div>
<p>このような場合には素早く演算が完了します。</p>
<p>その他の例には、 <a class="reference internal" href="../library/stdtypes.html#string-methods"><span class="std std-ref">文字列オブジェクトのメソッド</span></a> <code class="docutils literal"><span class="pre">join()</span></code> 、 <code class="docutils literal"><span class="pre">split()</span></code> などが挙げられます。例えば s1..s7 が大きな (10K+) 文字列の時、 <code class="docutils literal"><span class="pre">&quot;&quot;.join([s1,s2,s3,s4,s5,s6,s7])</span></code> は単純に <code class="docutils literal"><span class="pre">s1+s2+s3+s4+s5+s6+s7</span></code> とするよりもはるかに速くなるでしょう。なぜなら、 <code class="docutils literal"><span class="pre">join()</span></code> はすべてのコピーを一括して行うのに対し、「足し算」が多くの副演算を行うからです。文字列を扱うには、 <a class="reference internal" href="../library/stdtypes.html#string-methods"><span class="std std-ref">文字列オブジェクトのメソッド</span></a> <code class="docutils literal"><span class="pre">replace()</span></code> 、 <code class="docutils literal"><span class="pre">format()</span></code>  を使ってください。正規表現を使うのは、決まった文字列のパターンを使わない時だけにしてください。 <a class="reference internal" href="../library/stdtypes.html#string-formatting"><span class="std std-ref">旧式の % 演算</span></a> <code class="docutils literal"><span class="pre">string</span> <span class="pre">%</span> <span class="pre">tuple</span></code> と <code class="docutils literal"><span class="pre">string</span> <span class="pre">%</span> <span class="pre">dictionary</span></code> も使えます。</p>
<p>ソートには必ずビルトインオブジェクトの <code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code> を使ってください。また、 <a class="reference external" href="https://wiki.python.org/moin/HowTo/Sorting">sorting mini-HOWTO</a> の少し高度な使い方の例を参照してください。 <code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code> は、よほど極端な状況でない限り、他のソートの技術に勝ります。</p>
<p>「ループを関数やメソッドの中に入れ込む」というのも一般的な手法です。例えば、遅いプログラムがあって、Python の <code class="docutils literal"><span class="pre">ff()</span></code> 関数が何度も呼ばれていることがプロファイラで分かったとします。この <code class="docutils literal"><span class="pre">ff()</span></code></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ff</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="o">...</span> <span class="c1"># do something with x computing result...</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>がこのようなループで呼ばれる傾向がある気付いたとして:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">list</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">ff</span><span class="p">,</span> <span class="n">oldlist</span><span class="p">)</span>
</pre></div>
</div>
<p>もしくは:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">ff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="o">...</span> <span class="c1"># do something with value...</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ff()</span></code> を書き換えて:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ffseq</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="n">resultseq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
        <span class="o">...</span> <span class="c1"># do something with x computing result...</span>
        <span class="n">resultseq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resultseq</span>
</pre></div>
</div>
<p>また、上の二つの例を、 <code class="docutils literal"><span class="pre">list</span> <span class="pre">=</span> <span class="pre">ffseq(oldlist)</span></code> と:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">ffseq</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="o">...</span> <span class="c1"># do something with value...</span>
</pre></div>
</div>
<p>のように書き換えることによって、関数を呼ぶためのオーバーヘッドを省けることが多いです。<code class="docutils literal"><span class="pre">ff(x)</span></code> を一回だけ呼ぶ場合、 <code class="docutils literal"><span class="pre">ffseq([x])[0]</span></code> に直してしまうとちょっと不利になります。 もちろん、このテクニックがいつでも適切であるわけではありませんし、解決のための他の方法もあります。</p>
<p>関数やメソッドの探索の結果をローカル変数に明示的に保存すると少しパフォーマンスが良くなります。次のようなループ:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">token</span><span class="p">:</span>
    <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>は、繰り返しのたびに <code class="docutils literal"><span class="pre">dict.get</span></code> を求めています。 このメソッドが変わることがないのなら、少し速い実装は:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">dict_get</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">get</span>  <span class="c1"># look up the method once</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">token</span><span class="p">:</span>
    <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>デフォルト引数は、実行時でなく、コンパイル時に値を一回で決めてしまうのに使えます。これは、プログラムの実行中に変化しない関数やオブジェクト、例えば:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">degree_sin</span><span class="p">(</span><span class="n">deg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">deg</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">)</span>
</pre></div>
</div>
<p>を、次のように置き換えるときにのみ行えます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">degree_sin</span><span class="p">(</span><span class="n">deg</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span><span class="p">,</span> <span class="n">sin</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">deg</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span>
</pre></div>
</div>
<p>この手法はデフォルト引数が変えられないことを前提に使うので、ユーザーが API で混乱するおそれがないときのみ使えます。</p>
</div>
</div>
<div class="section" id="core-language">
<h2><a class="toc-backref" href="#id8">コア言語</a><a class="headerlink" href="#core-language" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value">
<h3><a class="toc-backref" href="#id9">なぜ変数に値があるのに UnboundLocalError が出るのですか？</a><a class="headerlink" href="#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>もともと動いていたコードが、関数の本体のどこかに代入文を加えるという変更をしたら UnboundLocalError を出すのには驚くかもしれません。</p>
<p>このコード:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<p>は動きますが、このコード:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">x</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>は UnboundLocalError になります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">UnboundLocalError</span>: <span class="n">local variable &#39;x&#39; referenced before assignment</span>
</pre></div>
</div>
<p>これは、あるスコープの中で変数に代入を行うとき、その変数はそのスコープに対してローカルになり、外のスコープにある同じ名前の変数を隠すからです。 foo の最後の文が <code class="docutils literal"><span class="pre">x</span></code> に新しい値を代入しているので、コンパイラはこれをローカル変数であると認識します。その結果、先の <code class="docutils literal"><span class="pre">print</span> <span class="pre">x</span></code> が初期化されていないローカル変数を表示しようとして結果はエラーとなります。</p>
<p>上の例では、グローバルであると宣言することで外のスコープにアクセスできます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foobar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">global</span> <span class="n">x</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">x</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foobar</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<p>この明示的な宣言は (表面的には似ているクラスとインスタンス変数の例とは違って) あなたは実際は他のスコープの変数の値を変えようとしているのだ、ということを知らせるのに必要です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">x</span>
<span class="go">11</span>
</pre></div>
</div>
</div>
<div class="section" id="what-are-the-rules-for-local-and-global-variables-in-python">
<h3><a class="toc-backref" href="#id10">Python のローカルとグローバル変数のルールは何ですか？</a><a class="headerlink" href="#what-are-the-rules-for-local-and-global-variables-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python では、関数の中で参照のみされる変数は暗黙のうちにグローバルになります。関数の本体のどこかで値が変数に代入されたなら、それは明示的にグローバルであると宣言されない限り、ローカルであるとみなされます。</p>
<p>最初はちょっと驚くでしょうが、少し考えると納得できます。一方では、代入された変数に <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> を要求することで、意図しない副作用を防げます。他方では、グローバルな参照の度に <code class="docutils literal"><span class="pre">global</span></code> が要求されてしまうと、 <code class="docutils literal"><span class="pre">global</span></code> を使ってばかりになってしまいます。ビルトイン関数やインポートされたモジュールの内容を参照するたびにグローバル宣言をしなければならないのです。その乱雑さは副作用を特定するための <code class="docutils literal"><span class="pre">global</span></code> 宣言の便利さよりも重大です。</p>
</div>
<div class="section" id="why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result">
<h3><a class="toc-backref" href="#id11">ループの中で異なる値で定義されたラムダ式が、同じ値を返すのはなぜですか？</a><a class="headerlink" href="#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>for ループを使って、少しずつ異なるラムダを定義 (もしくは簡単な関数) するとします。例えば:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>これで <code class="docutils literal"><span class="pre">x**2</span></code> を計算する 5 つのラムダのリストが得られます。それらを呼び出したとき、それぞれ <code class="docutils literal"><span class="pre">0</span></code>、<code class="docutils literal"><span class="pre">1</span></code>、<code class="docutils literal"><span class="pre">4</span></code>、<code class="docutils literal"><span class="pre">9</span></code>、<code class="docutils literal"><span class="pre">16</span></code> を返すと予想するかもしれません。しかし実際にやってみると、全て <code class="docutils literal"><span class="pre">16</span></code> が返ってくるのを目にするでしょう:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">4</span><span class="p">]()</span>
<span class="go">16</span>
</pre></div>
</div>
<p>これは、<code class="docutils literal"><span class="pre">x</span></code> がラムダにとってのローカル変数ではなく外側のスコープで定義されていて、ラムダが定義されたときでなく呼び出されたときにアクセスされるために起こります。ループが終わった時点では <code class="docutils literal"><span class="pre">x</span></code> は <code class="docutils literal"><span class="pre">4</span></code> であり、従って、全ての関数は <code class="docutils literal"><span class="pre">4**2</span></code> つまり <code class="docutils literal"><span class="pre">16</span></code> を返します。このことは <code class="docutils literal"><span class="pre">x</span></code> の値を変えてみることで検証でき、ラムダの返り値がどのように変わるのか観察できます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">64</span>
</pre></div>
</div>
<p>これを避けるためには、グローバルの <code class="docutils literal"><span class="pre">x</span></code> の値に依存しないために、ラムダにとってのローカル変数に値を保存する必要があります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="o">=</span><span class="n">x</span><span class="p">:</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで、<code class="docutils literal"><span class="pre">n=x</span></code> は新しいラムダにとってのローカル変数 <code class="docutils literal"><span class="pre">n</span></code> を作成し、ラムダが定義されるときに計算されるので、ループのその時点での <code class="docutils literal"><span class="pre">x</span></code> と同じ値を持っています。これは、1 つ目のラムダでは <code class="docutils literal"><span class="pre">n</span></code> の値は <code class="docutils literal"><span class="pre">0</span></code> になり、2 つ目では <code class="docutils literal"><span class="pre">1</span></code>、3 つ目では <code class="docutils literal"><span class="pre">2</span></code> 以下同様、となることを意味します。従って、それぞれのラムダは今や正しい値を返すようになりました:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">4</span><span class="p">]()</span>
<span class="go">16</span>
</pre></div>
</div>
<p>この動作はラムダに特有なものではなく、通常の関数にも適用されることに注意してください。</p>
</div>
<div class="section" id="how-do-i-share-global-variables-across-modules">
<h3><a class="toc-backref" href="#id12">グローバル変数をモジュール間で共有するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-share-global-variables-across-modules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一つのプログラムのモジュール間で情報を共有する正準な方法は、特別なモジュール (しばしば config や cfg と呼ばれる) を作ることです。単に設定モジュールをアプリケーションのすべてのモジュールにインポートしてください。このモジュールはグローバルな名前として使えます。それぞれのモジュールのただ一つのインスタンスがあるので、設定モジュールオブジェクトに対するいかなる変更も全体に反映されます。例えば:</p>
<p>config.py:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># Default value of the &#39;x&#39; configuration setting</span>
</pre></div>
</div>
<p>mod.py:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">config</span>
<span class="n">config</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>main.py:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">config</span>
<span class="kn">import</span> <span class="nn">mod</span>
<span class="nb">print</span> <span class="n">config</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<p>なお、同じ理由から、モジュールを使うということは、シングルトンデザインパターンを実装することの基礎でもあります。</p>
</div>
<div class="section" id="what-are-the-best-practices-for-using-import-in-a-module">
<h3><a class="toc-backref" href="#id13">モジュールで import を使う際の「ベストプラクティス」は何ですか？</a><a class="headerlink" href="#what-are-the-best-practices-for-using-import-in-a-module" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一般的に <code class="docutils literal"><span class="pre">from</span> <span class="pre">modulename</span> <span class="pre">import</span> <span class="pre">*</span></code> を使ってはいけません。そのようにするとインポータの名前空間は汚染され、linter が未定義の名前を発見することが難しくなります。</p>
<p>モジュールはファイルの先頭でインポートしてください。これによってコードが必要とする他のモジュールが明確になり、モジュール名がスコープに含まれるかどうかに迷わなくなります。行に一つのインポートにすると、モジュールのインポートの追加と削除が容易になりますが、行に複数のインポートにすると画面の領域が少なく済みます。</p>
<p>次の手順でモジュールをインポートするのが、良いプラクティスになります:</p>
<ol class="arabic simple">
<li><p class="first">標準ライブラリモジュール &#8211; 例 <code class="docutils literal"><span class="pre">sys</span></code>、<code class="docutils literal"><span class="pre">os</span></code>、<code class="docutils literal"><span class="pre">getopt</span></code>、<code class="docutils literal"><span class="pre">re</span></code></p>
</li>
<li><p class="first">サードパーティのライブラリモジュール (Python の site-packages ディレクトリにあるもの) &#8211; 例 mx.DateTime、ZODB、PIL.Image、など</p>
</li>
<li><p class="first">自前で開発したモジュール</p>
</li>
</ol>
<p>明示的な相対インポートだけを使ってください。 <code class="docutils literal"><span class="pre">package.sub.m1</span></code> モジュールのコードを書いていて、 <code class="docutils literal"><span class="pre">package.sub.m2</span></code> をインポートしようとするときに <code class="docutils literal"><span class="pre">import</span> <span class="pre">m2</span></code> だけで済ませるのはやめてください。たとえそれが合法でも。代わりに <code class="docutils literal"><span class="pre">from</span> <span class="pre">package.sub</span> <span class="pre">import</span> <span class="pre">m2</span></code> または <code class="docutils literal"><span class="pre">from</span> <span class="pre">.</span> <span class="pre">import</span> <span class="pre">m2</span></code> と書いてください。</p>
<p>循環参照の問題を避けるために、インポートを関数やクラスに移すことが必要なときもあります。Gordon McMillan によれば:</p>
<blockquote>
<div><p>循環参照は両方のモジュールが &#8220;import &lt;module&gt;&#8221; 形式のインポートを使っていれば大丈夫です。二つ目のモジュールが最初のモジュールから名前を確保しようとして (&#8220;from module import name&#8221;)、そのインポートがトップレベルにあると駄目です。最初のモジュールが二つ目のモジュールをインポートするのに忙しくて、最初のモジュールの名前が利用可能になっていないからです。</p>
</div></blockquote>
<p>この状況では、二つ目のモジュールが一つの関数の中でのみ使われているならば、そのインポートは簡単に関数の中に移せます。インポートが呼ばれたとき、最初のモジュールは初期化を完了していて、二つ目のモジュールは自分のインポートをできます。</p>
<p>プラットフォーム依存のモジュールがあるときには、インポートをトップレベルの外に動かすことも必要です。この場合、ファイルの先頭ではすべてのモジュールをインポートすることさえできないかもしれません。この場合は、対応するプラットフォームに合わせたコードで正しいモジュールをインポートすることを選ぶと良いです。</p>
<p>循環参照の問題を避けたりモジュールの初期化にかかる時間を減らしたりしたいなら、単にインポートを関数定義の中などのローカルなスコープに移してください。この手法は多くのインポートがプログラムがどのように実行されるかに依存しなくてよいときに特に有効です。ある関数の中でのみモジュールが使われるのなら、インポートをその関数の中に移すことを考えてもいいでしょう。なお、モジュールを読み込む最初の回はモジュールの初期化の時間のために高価になりえますが、複数回目にモジュールを読み込むのは事実上無料、辞書探索の数回のコストだけで済みます。モジュール名がスコープから外れてさえ、そのモジュールはおそらく <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> から利用できるでしょう。</p>
</div>
<div class="section" id="why-are-default-values-shared-between-objects">
<h3><a class="toc-backref" href="#id14">なぜオブジェクト間でデフォルト値が共有されるのですか？</a><a class="headerlink" href="#why-are-default-values-shared-between-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この種のバグがよく初心者プログラマに噛み付きます。この関数を考えてみてください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="p">{}):</span>  <span class="c1"># Danger: shared reference to one dict for all calls</span>
    <span class="o">...</span> <span class="n">compute</span> <span class="n">something</span> <span class="o">...</span>
    <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">mydict</span>
</pre></div>
</div>
<p>初めてこの関数を呼び出した時、<code class="docutils literal"><span class="pre">mydict</span></code> には一つの要素があります。二回目には、<code class="docutils literal"><span class="pre">foo()</span></code> が実行されるときに <code class="docutils literal"><span class="pre">mydict</span></code> には初めから一つの要素をすでに持っているので、<code class="docutils literal"><span class="pre">mydict</span></code> には二つの要素があります。</p>
<p>関数の呼び出しによって、デフォルトの値に対する新しいオブジェクトが作られるのだと予想しがちです。実はそうなりません。デフォルト値は、関数が定義されたときに一度だけ生成されます。この例の辞書のように、そのオブジェクトが変更されたとき、その後の関数の呼び出しは変更後のオブジェクトを参照します。</p>
<p>定義の時に、数、文字列、タプル、<code class="docutils literal"><span class="pre">None</span></code> など、イミュータブルなオブジェクトを使うと変更される危険がありません。辞書、リスト、クラスインスタンスなどのミュータブルなオブジェクトは混乱のもとです。</p>
<p>この性質から、ミュータブルなオブジェクトをデフォルト値として使わないプログラミング手法がいいです。代わりに、<code class="docutils literal"><span class="pre">None</span></code> をデフォルト値に使い、そのパラメタが <code class="docutils literal"><span class="pre">None</span></code> である時にだけ、関数の内部で新しいリスト/辞書/その他をつくるようにしてください。例えば、こう書かずに:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="p">{}):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>代わりに:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mydict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mydict</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># create a new dict for local namespace</span>
</pre></div>
</div>
<p>この性質が便利なこともあります。時間のかかる計算を行う関数があるときに使われる一般的な技法は、関数が呼び出されるごとにパラメタと結果の値をキャッシュし、再び同じ値が要求されたらキャッシュされた値を返すというものです。これは &#8220;memoizing&#8221; と呼ばれ、このように実装されます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Callers will never provide a third parameter for this function.</span>
<span class="k">def</span> <span class="nf">expensive</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">_cache</span><span class="o">=</span><span class="p">{}):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_cache</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cache</span><span class="p">[(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)]</span>

    <span class="c1"># Calculate the value</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">...</span> <span class="n">expensive</span> <span class="n">computation</span> <span class="o">...</span>
    <span class="n">_cache</span><span class="p">[(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>           <span class="c1"># Store result in the cache</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>デフォルト値の代わりに、辞書を含むグローバル変数も使えます。これは好みの問題です。</p>
</div>
<div class="section" id="how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another">
<h3><a class="toc-backref" href="#id15">オプションパラメータやキーワードパラメータを関数から関数へ渡すにはどうしたらいいですか？</a><a class="headerlink" href="#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>関数のパラメータリストに引数を <code class="docutils literal"><span class="pre">*</span></code> と <code class="docutils literal"><span class="pre">**</span></code> 指定子 (specifier) で集めてください。そうすれば、固定引数をタプルとして、キーワード引数を辞書として得られます。これで、他の関数を呼び出すときに <code class="docutils literal"><span class="pre">*</span></code> と <code class="docutils literal"><span class="pre">**</span></code> を使ってそれらの引数を渡せます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;14.3c&#39;</span>
    <span class="o">...</span>
    <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>あまりありませんが、Python の 2.0 以前のバージョンを考慮するときは、代わりに <a class="reference internal" href="../library/functions.html#apply" title="apply"><code class="xref py py-func docutils literal"><span class="pre">apply()</span></code></a> を使ってください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;14.3c&#39;</span>
    <span class="o">...</span>
    <span class="n">apply</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="what-is-the-difference-between-arguments-and-parameters">
<span id="faq-argument-vs-parameter"></span><span id="index-1"></span><h3><a class="toc-backref" href="#id16">実引数と仮引数の違いは何ですか?</a><a class="headerlink" href="#what-is-the-difference-between-arguments-and-parameters" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">仮引数 (parameter)</span></a> は関数定義に表れる名前で定義されるのに対し、 <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">実引数 (argument)</span></a> は関数を呼び出すときに実際に渡す値のことです。仮引数は関数が受け取ることの出来る実引数の型を定義します。例えば、以下のような関数定義があったとして:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p><em>foo</em>、<em>bar</em>、<em>kwargs</em> は <code class="docutils literal"><span class="pre">func</span></code> の仮引数です。一方、<code class="docutils literal"><span class="pre">func</span></code> を呼び出すときには、例えば:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">func</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">314</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">somevar</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">42</span></code>、<code class="docutils literal"><span class="pre">314</span></code>、<code class="docutils literal"><span class="pre">somevar</span></code> という値は実引数です。</p>
</div>
<div class="section" id="why-did-changing-list-y-also-change-list-x">
<h3><a class="toc-backref" href="#id17">なぜ list &#8216;y&#8217; を変更すると list &#8216;x&#8217; も変更されるのですか?</a><a class="headerlink" href="#why-did-changing-list-y-also-change-list-x" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>次のようなコードを書いたとします:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">[10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">[10]</span>
</pre></div>
</div>
<p>どうして <code class="docutils literal"><span class="pre">y</span></code> への要素の追加が <code class="docutils literal"><span class="pre">x</span></code> も変更してしまうのか疑問に思うかもしれません。</p>
<p>このような結果になる2つの要因があります:</p>
<ol class="arabic simple">
<li><p class="first">変数とは、単にオブジェクトを参照するための名前に過ぎません。 <code class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span></code> とすることは、リストのコピーを作りません &#8211; それは <code class="docutils literal"><span class="pre">x</span></code> が参照するのと同じオブジェクトを参照する新しい変数 <code class="docutils literal"><span class="pre">y</span></code> を作ります。つまり、あるのは一つのオブジェクト(この場合リスト)だけであって、 <code class="docutils literal"><span class="pre">x</span></code> と <code class="docutils literal"><span class="pre">y</span></code> の両方がそれを参照しているのです。</p>
</li>
<li><p class="first">リストは <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> です。内容を変更出来る、ということです。</p>
</li>
</ol>
<p><code class="xref py py-meth docutils literal"><span class="pre">append()</span></code> 呼び出しの後、ミュータブルオブジェクトの内容が <code class="docutils literal"><span class="pre">[]</span></code> から <code class="docutils literal"><span class="pre">[10]</span></code> に変わります。 変数が同じオブジェクトを参照しているので、どちらの名前であっても変更された値 <code class="docutils literal"><span class="pre">[10]</span></code> にアクセスします。</p>
<p>代わりに <code class="docutils literal"><span class="pre">x</span></code> にイミュータブルを代入すると:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># ints are immutable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 5 can&#39;t be mutated, we are creating a new object here</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">5</span>
</pre></div>
</div>
<p>この場合ご覧の通り <code class="docutils literal"><span class="pre">x</span></code> と <code class="docutils literal"><span class="pre">y</span></code> はまったく同じではありませんね。これは整数が <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">immutable</span></a> だからで、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> は整数の <code class="docutils literal"><span class="pre">5</span></code> の値を変更しているのではありません; 代わりに新しいオブジェクト(整数 <code class="docutils literal"><span class="pre">6</span></code>)を作って <code class="docutils literal"><span class="pre">x</span></code> に代入しています (つまり <code class="docutils literal"><span class="pre">x</span></code> が参照するオブジェクトが変わります)。この代入の後では私たちは 2 つのオブジェクト(整数の <code class="docutils literal"><span class="pre">6</span></code> と <code class="docutils literal"><span class="pre">5</span></code>)を持っていて、2 つの変数はそれらを参照しています(<code class="docutils literal"><span class="pre">x</span></code> はいまや <code class="docutils literal"><span class="pre">6</span></code> を参照していますが <code class="docutils literal"><span class="pre">y</span></code> は <code class="docutils literal"><span class="pre">5</span></code> を参照したままです)。</p>
<p>ある演算 (たとえば <code class="docutils literal"><span class="pre">y.append(10)</span></code>, <code class="docutils literal"><span class="pre">y.sort()</span></code>) がオブジェクトを変更する一方で、外見上は似た演算 (たとえば <code class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">[10]</span></code>, <code class="docutils literal"><span class="pre">sorted(y)</span></code>) は新しいオブジェクトを作ります。Python では一般に (そして標準ライブラリの全てのケースで)、このような 2 つのタイプの演算にまつわる混乱を避けるために、オブジェクトを変更するメソッドは <code class="docutils literal"><span class="pre">None</span></code> を返します。ですからもしあなたが誤って <code class="docutils literal"><span class="pre">y</span></code> の複製の並び替えをするつもりで <code class="docutils literal"><span class="pre">y.sort()</span></code> と書いた場合に結果手にするのは <code class="docutils literal"><span class="pre">None</span></code> でしょうから、あなたのプログラムは簡単に診断出来るエラーを起こすでしょう。</p>
<p>しかしながら、同じ操作が型ごとに異なる振る舞いをする演算の種類が一つあります: 累算代入演算です。例えば <code class="docutils literal"><span class="pre">+=</span></code> はリストを変更しますが、タプルや整数は変更しません(<code class="docutils literal"><span class="pre">a_list</span> <span class="pre">+=</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> は <code class="docutils literal"><span class="pre">a_list.extend([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code> と同じ意味で、そして <code class="docutils literal"><span class="pre">a_list</span></code> を変更しますが、 <code class="docutils literal"><span class="pre">some_tuple</span> <span class="pre">+=</span> <span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code> と <code class="docutils literal"><span class="pre">some_int</span> <span class="pre">+=</span> <span class="pre">1</span></code> は新しいオブジェクトを作ります)。</p>
<p>言い換えると:</p>
<ul class="simple">
<li><p class="first">ミュータブルなオブジェクト(<a class="reference internal" href="../library/functions.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, 等)を持っている場合、私たちはその内容を変更するある種の演算を使うことが出来、それを参照している全ての変数はその変化を見ることになるでしょう。</p>
</li>
<li><p class="first">イミュータブルなオブジェクト(<a class="reference internal" href="../library/functions.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/functions.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>, 等)を持っている場合、それを参照している全ての変数は同じ値を参照しているでしょうが、持っている値を新しい値に変換する演算はいつでも新しいオブジェクトを返します。</p>
</li>
</ul>
<p>2つの変数が同じオブジェクトを参照しているかどうかが知りたければ、 <a class="reference internal" href="../reference/expressions.html#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a> オペレータまたは組み込み関数 <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal"><span class="pre">id()</span></code></a> が使えます。</p>
</div>
<div class="section" id="how-do-i-write-a-function-with-output-parameters-call-by-reference">
<h3><a class="toc-backref" href="#id18">パラメータを出力する関数 (参照渡し) はどのように書きますか？</a><a class="headerlink" href="#how-do-i-write-a-function-with-output-parameters-call-by-reference" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>前提として、Python では引数は代入によって渡されます。代入はオブジェクトへの参照を作るだけなので、呼び出し元と呼び出し先にある引数名の間にエイリアスはありませんし、参照渡しそれ自体はありません。望む効果を得るためには幾つかの方法があります。</p>
<ol class="arabic">
<li><p class="first">結果のタプルを返すことによって:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>        <span class="c1"># a and b are local names</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>              <span class="c1"># assigned to new objects</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>            <span class="c1"># return new values</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="mi">99</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">func2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>                 <span class="c1"># output: new-value 100</span>
</pre></div>
</div>
<p>これはたいてい一番明確な方法です。</p>
</li>
<li><p class="first">グローバル変数を使って。これはスレッドセーフでないので、推奨されません。</p>
</li>
<li><p class="first">ミュータブルな (インプレースに変更可能な) オブジェクトを渡すことによって:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func1</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>     <span class="c1"># &#39;a&#39; references a mutable list</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>        <span class="c1"># changes a shared object</span>

<span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
<span class="n">func1</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>     <span class="c1"># output: new-value 100</span>
</pre></div>
</div>
</li>
<li><p class="first">変更される辞書に渡すことによって:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func3</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">args</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>     <span class="c1"># args is a mutable dictionary</span>
    <span class="n">args</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># change it in-place</span>

<span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">99</span><span class="p">}</span>
<span class="n">func3</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first">または、クラスインスタンスに値を同梱することによって:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">callByRef</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func4</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">args</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>        <span class="c1"># args is a mutable callByRef</span>
    <span class="n">args</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>         <span class="c1"># change object in-place</span>

<span class="n">args</span> <span class="o">=</span> <span class="n">callByRef</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>
<span class="n">func4</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">args</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">b</span>
</pre></div>
</div>
<p>このような複雑なことをする理由はめったに無いでしょう。</p>
</li>
</ol>
<p>一番の選択は、複数の結果を含むタプルを返すことです。</p>
</div>
<div class="section" id="how-do-you-make-a-higher-order-function-in-python">
<h3><a class="toc-backref" href="#id19">Python で高次関数はどのようにつくりますか？</a><a class="headerlink" href="#how-do-you-make-a-higher-order-function-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>二つの方法があります: ネストされたスコープを使う方法と、呼び出し可能オブジェクトを使う方法です。例えば、<code class="docutils literal"><span class="pre">a*x+b</span></code> の値を計算する <code class="docutils literal"><span class="pre">f(x)</span></code> 関数を返す <code class="docutils literal"><span class="pre">linear(a,b)</span></code> を定義したいとします。ネストされたスコープを使うと:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">linear</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>また、呼び出し可能オブジェクトを使うと:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">linear</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
</pre></div>
</div>
<p>どちらの場合でも、</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">taxes</span> <span class="o">=</span> <span class="n">linear</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>とすれば、<code class="docutils literal"><span class="pre">taxes(10e6)</span> <span class="pre">==</span> <span class="pre">0.3</span> <span class="pre">*</span> <span class="pre">10e6</span> <span class="pre">+</span> <span class="pre">2</span></code> となるような呼び出し可能オブジェクトを得られます。</p>
<p>呼び出し可能オブジェクトを使う方法は、少し遅くなり、わずかにコードが長くなるという短所があります。ですが、継承を使ってコーラブル同士で記号を共有することもできます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">exponential</span><span class="p">(</span><span class="n">linear</span><span class="p">):</span>
    <span class="c1"># __init__ inherited</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>オブジェクトはいくつかのメソッドに状態をカプセル化できます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">counter</span><span class="p">:</span>

    <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">down</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">count</span> <span class="o">=</span> <span class="n">counter</span><span class="p">()</span>
<span class="n">inc</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">reset</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="n">up</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">down</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">set</span>
</pre></div>
</div>
<p>ここで、<code class="docutils literal"><span class="pre">inc()</span></code>、<code class="docutils literal"><span class="pre">dec()</span></code>、<code class="docutils literal"><span class="pre">reset()</span></code> は同じカウント変数を共有する関数のようにふるまいます。</p>
</div>
<div class="section" id="how-do-i-copy-an-object-in-python">
<h3><a class="toc-backref" href="#id20">Python のオブジェクトはどのようにコピーしますか？</a><a class="headerlink" href="#how-do-i-copy-an-object-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一般的に、普通は <a class="reference internal" href="../library/copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal"><span class="pre">copy.copy()</span></code></a> や <a class="reference internal" href="../library/copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal"><span class="pre">copy.deepcopy()</span></code></a> を試してください。何でもコピーできるとは限りませんが、たいていはできます。</p>
<p>もっと簡単にコピーできるオブジェクトもあります。辞書には <a class="reference internal" href="../library/stdtypes.html#dict.copy" title="dict.copy"><code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code></a> メソッドがあります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">newdict</span> <span class="o">=</span> <span class="n">olddict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<p>シーケンスはスライシングでコピーできます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">new_l</span> <span class="o">=</span> <span class="n">l</span><span class="p">[:]</span>
</pre></div>
</div>
</div>
<div class="section" id="how-can-i-find-the-methods-or-attributes-of-an-object">
<h3><a class="toc-backref" href="#id21">オブジェクトのメソッドや属性はどのように見つけますか？</a><a class="headerlink" href="#how-can-i-find-the-methods-or-attributes-of-an-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ユーザー定義クラスのインスタンス x で、<code class="docutils literal"><span class="pre">dir(x)</span></code> はインスタンス属性とそのクラスで定義されたメソッドや属性を含む名前のアルファベット順リストを返します。</p>
</div>
<div class="section" id="how-can-my-code-discover-the-name-of-an-object">
<h3><a class="toc-backref" href="#id22">コードはどのようにオブジェクトの名前を見つけるのですか？</a><a class="headerlink" href="#how-can-my-code-discover-the-name-of-an-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>概して、オブジェクトは本当は名前を持たないので、見つけることはできません。本質的には、代入とはいつも値に名前を束縛することです。<code class="docutils literal"><span class="pre">def</span></code> と <code class="docutils literal"><span class="pre">class</span></code> 文も同じですが、この場合は値はコーラブルです。以下のコードを考えてみましょう:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">b</span>
<span class="go">&lt;__main__.A instance at 0x16D07CC&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">a</span>
<span class="go">&lt;__main__.A instance at 0x16D07CC&gt;</span>
</pre></div>
</div>
<p>おそらく、このクラスには名前があります。このクラスは二つの名前に縛られて、名前 B を通して呼び出されますが、それでもクラス A のインスタンスとして報告されるのです。しかし、両方の名前が同じ値に束縛されている以上、このインスタンスの名前が a か b か決めることはできないのです。</p>
<p>概して、コードにとってある値の「名前を知っている」事は重要ではありません。あなたがわざと内省的なコードを書いているのでない限り、方針を変えた方がいいかもしれないということになるでしょう。</p>
<p>comp.lang.python で、Fredrik Lundh はこの問題の答えとして素晴らしい喩えをしてくれました:</p>
<blockquote>
<div><p>玄関にいた猫の名前を知るのと同じ方法です: その猫 (オブジェクト) 自体はその名前を言うことができないし、それは実は問題ではありません &#8211; その猫が何と呼ばれているかを知る唯一の方法は、すべての隣人 (名前空間) にその猫 (オブジェクト) が何と呼ばれているかを聞くことです。</p>
<p>……そして、その猫が沢山の名前で知られていたり、逆に全く名前が無かったりしても驚かないでください！</p>
</div></blockquote>
</div>
<div class="section" id="what-s-up-with-the-comma-operator-s-precedence">
<h3><a class="toc-backref" href="#id23">カンマ演算子はなぜ優先されるのですか？</a><a class="headerlink" href="#what-s-up-with-the-comma-operator-s-precedence" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>カンマは Python では演算子ではありません。このセッションを考えてください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span>
<span class="go">(False, &#39;a&#39;)</span>
</pre></div>
</div>
<p>カンマは演算子ではなく、式の分離子なので、上の式は次の式と同じように評価されます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="s2">&quot;a&quot;</span>
</pre></div>
</div>
<p>こうではありません:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>他のさまざまな演算子(<code class="docutils literal"><span class="pre">=</span></code>、<code class="docutils literal"><span class="pre">+=</span></code> など)も同じです。これらは真の演算子ではありませんが、代入文の構文上のデリミタです。</p>
</div>
<div class="section" id="is-there-an-equivalent-of-c-s-ternary-operator">
<h3><a class="toc-backref" href="#id24">C の &#8221;?:&#8221; 三項演算子と等価なものはありますか？</a><a class="headerlink" href="#is-there-an-equivalent-of-c-s-ternary-operator" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい、この機能は Python 2.5 で追加されました。構文は以下のようになります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">on_true</span><span class="p">]</span> <span class="k">if</span> <span class="p">[</span><span class="n">expression</span><span class="p">]</span> <span class="k">else</span> <span class="p">[</span><span class="n">on_false</span><span class="p">]</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span>

<span class="n">small</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>2.5 以前のバージョンについては、これの答えは「いいえ」です。</p>
</div>
<div class="section" id="is-it-possible-to-write-obfuscated-one-liners-in-python">
<h3><a class="toc-backref" href="#id25">Python で解し難いワンライナーを書くことはできますか？</a><a class="headerlink" href="#is-it-possible-to-write-obfuscated-one-liners-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。そういうものはたいてい、 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a> の中に <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a> がネストされています。Ulf Bartelt による下の３つの例を見てください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Primes &lt; 1000</span>
<span class="nb">print</span> <span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">*</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span>
<span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">%</span><span class="n">x</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))),</span><span class="mi">1</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1000</span><span class="p">)))</span>

<span class="c1"># First 10 Fibonacci numbers</span>
<span class="nb">print</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">:(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">f</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">),</span>
<span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

<span class="c1"># Mandelbrot set</span>
<span class="nb">print</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="p">,</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="p">,</span><span class="n">IM</span><span class="p">,</span><span class="n">Sx</span><span class="p">,</span><span class="n">Sy</span><span class="p">:</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">,</span>
<span class="n">Iu</span><span class="o">=</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="o">=</span><span class="n">Io</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span><span class="n">Sy</span><span class="o">=</span><span class="n">Sy</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="k">lambda</span> <span class="n">yc</span><span class="p">,</span><span class="n">Iu</span><span class="o">=</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="o">=</span><span class="n">Io</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">IM</span><span class="p">,</span>
<span class="n">Sx</span><span class="o">=</span><span class="n">Sx</span><span class="p">,</span><span class="n">Sy</span><span class="o">=</span><span class="n">Sy</span><span class="p">:</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">xc</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">yc</span><span class="o">=</span><span class="n">yc</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span>
<span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">Sx</span><span class="o">=</span><span class="n">Sx</span><span class="p">,</span><span class="n">F</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="p">:(</span><span class="n">k</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span><span class="ow">or</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span>
<span class="o">&gt;=</span><span class="mf">4.0</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">xc</span><span class="p">,</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">yc</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">f</span><span class="p">):</span><span class="n">f</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="p">):</span><span class="nb">chr</span><span class="p">(</span>
<span class="mi">64</span><span class="o">+</span><span class="n">F</span><span class="p">(</span><span class="n">Ru</span><span class="o">+</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">Ro</span><span class="o">-</span><span class="n">Ru</span><span class="p">)</span><span class="o">/</span><span class="n">Sx</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)),</span><span class="nb">range</span><span class="p">(</span><span class="n">Sx</span><span class="p">))):</span><span class="n">L</span><span class="p">(</span><span class="n">Iu</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">Io</span><span class="o">-</span><span class="n">Iu</span><span class="p">)</span><span class="o">/</span><span class="n">Sy</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Sy</span>
<span class="p">))))(</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
<span class="c1">#    \___ ___/  \___ ___/  |   |   |__ lines on screen</span>
<span class="c1">#        V          V      |   |______ columns on screen</span>
<span class="c1">#        |          |      |__________ maximum of &quot;iterations&quot;</span>
<span class="c1">#        |          |_________________ range on y axis</span>
<span class="c1">#        |____________________________ range on x axis</span>
</pre></div>
</div>
<p>よい子はまねしないでね！</p>
</div>
</div>
<div class="section" id="numbers-and-strings">
<h2><a class="toc-backref" href="#id26">数と文字列</a><a class="headerlink" href="#numbers-and-strings" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-specify-hexadecimal-and-octal-integers">
<h3><a class="toc-backref" href="#id27">十六進数や八進数を指定するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-specify-hexadecimal-and-octal-integers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>八進数を指定するには、八進数での値の先頭に 0 と &#8220;o&#8221; (小文字または大文字) を加えてください。たとえば、変数 &#8220;a&#8221; に八進数での &#8220;10&#8221; (十進数での&#8221;8&#8221;) を代入するには、こう打ってください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mo">0o10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">8</span>
</pre></div>
</div>
<p>十六進数も簡単です。ただ十六進数での値の先頭に 0 と &#8220;x&#8221; (小文字または大文字) を加えてください。十六進数は小文字でも大文字でも指定できます。たとえば、Python インタプリタで:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mh">0xa5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">165</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mh">0XB2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">178</span>
</pre></div>
</div>
</div>
<div class="section" id="why-does-22-10-return-3">
<h3><a class="toc-backref" href="#id28">なぜ -22 // 10 は -3 を返すのですか？</a><a class="headerlink" href="#why-does-22-10-return-3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code> が <code class="docutils literal"><span class="pre">j</span></code> と同じ符号であってほしいことに基づいています。それに加えて以下のようにもしたいとすると:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<p>整数除算は床を返すことになります。C にも C の一貫性があって、<code class="docutils literal"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code> が <code class="docutils literal"><span class="pre">i</span></code> と同じ符号を持つように <code class="docutils literal"><span class="pre">i</span> <span class="pre">//</span> <span class="pre">j</span></code> を丸めています。</p>
<p><code class="docutils literal"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code> は、<code class="docutils literal"><span class="pre">j</span></code> が負の時には実際にはほとんど使いません。<code class="docutils literal"><span class="pre">j</span></code> が正なら、たくさん使います。その事実上すべての場合、<code class="docutils literal"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code> は <code class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">0</span></code> となる方が便利です。時計が 10 時を指している時、その 200 時間前は何時でしょうか。<code class="docutils literal"><span class="pre">-190</span> <span class="pre">%</span> <span class="pre">12</span> <span class="pre">==</span> <span class="pre">2</span></code> となるのが便利です。<code class="docutils literal"><span class="pre">-190</span> <span class="pre">%</span> <span class="pre">12</span> <span class="pre">==</span> <span class="pre">-10</span></code> は噛み付きかねないバグです。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Python 2 では、  <code class="docutils literal"><span class="pre">__future__.division</span></code> が有効でなければ、<code class="docutils literal"><span class="pre">a</span> <span class="pre">/</span> <span class="pre">b</span></code> は <code class="docutils literal"><span class="pre">a</span> <span class="pre">//</span> <span class="pre">b</span></code> と同じ結果を返します。これは &#8220;古典的な (classic)&#8221; 除算とも呼ばれます。</p>
</div>
</div>
<div class="section" id="how-do-i-convert-a-string-to-a-number">
<h3><a class="toc-backref" href="#id29">文字列を数に変換するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-convert-a-string-to-a-number" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>整数に変換するには、組み込みの <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a> 型コンストラクタを使ってください。例えば、 <code class="docutils literal"><span class="pre">int('144')</span> <span class="pre">==</span> <span class="pre">144</span></code> です。同様に、 <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a> は浮動小数点に変換します。例えば、 <code class="docutils literal"><span class="pre">float('144')</span> <span class="pre">==</span> <span class="pre">144.0</span></code> です。</p>
<p>デフォルトでは、これらは数を十進数として解釈するので、 <code class="docutils literal"><span class="pre">int('0o144')</span></code> や <code class="docutils literal"><span class="pre">int('0x144')</span></code> は <a class="reference internal" href="../library/exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。 <code class="docutils literal"><span class="pre">int(string,</span> <span class="pre">base)</span></code> はオプションの第二引数をとって変換元の基数にします。つまり <code class="docutils literal"><span class="pre">int('0x144',</span> <span class="pre">16)</span> <span class="pre">==</span> <span class="pre">324</span></code> です。基数が 0 と指定された場合、その数は Python の基準によって解釈されます。先頭が &#8216;0o&#8217; なら八進数で、&#8216;0x&#8217; なら十六進数を表します。</p>
<p>文字列を数に変換するだけのために <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> を使わないでください。 <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> は特に遅いですし、セキュリティ上のリスクもあります。求められない副作用を持つような Python の式を渡そうとする人がいるかも知れません。例えば、あなたのホームディレクトリを消去する <code class="docutils literal"><span class="pre">__import__('os').system(&quot;rm</span> <span class="pre">-rf</span> <span class="pre">$HOME&quot;)</span></code> を渡そうとする人がいるかも知れません。</p>
<p><a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> にも数を Python の式として解釈する機能があります。だから例えば、 <code class="docutils literal"><span class="pre">eval('09')</span></code> は構文エラー起こします。Python は &#8216;0&#8217; で始まる数を八進数 (基数 8) とみなすからです。</p>
</div>
<div class="section" id="how-do-i-convert-a-number-to-a-string">
<h3><a class="toc-backref" href="#id30">数を文字列に変換するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-convert-a-number-to-a-string" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>例えば、144 という数を &#8216;144&#8217; という文字列に変換したいなら、組み込みの型コンストラクタ <a class="reference internal" href="../library/functions.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> を使ってください。十六進数や八進数にしたければ、組み込み関数の <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal"><span class="pre">hex()</span></code></a> や <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal"><span class="pre">oct()</span></code></a> を使ってください。装飾された形式にするには、 <a class="reference internal" href="../library/string.html#formatstrings"><span class="std std-ref">書式指定文字列の文法</span></a> の項を参照してください。例えば、 <code class="docutils literal"><span class="pre">&quot;{:04d}&quot;.format(144)</span></code> は <code class="docutils literal"><span class="pre">'0144'</span></code> になり、 <code class="docutils literal"><span class="pre">&quot;{:.3f}&quot;.format(1/3)</span></code> は <code class="docutils literal"><span class="pre">'0.333'</span></code> になります。文字列に <a class="reference internal" href="../library/stdtypes.html#string-formatting"><span class="std std-ref">% 演算子</span></a> を使うこともできます。詳細はライブラリリファレンスの解説を参照してください。</p>
</div>
<div class="section" id="how-do-i-modify-a-string-in-place">
<h3><a class="toc-backref" href="#id31">文字列をインプレースに変更するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-modify-a-string-in-place" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>文字列はイミュータブルなので、変更することはできません。それができるオブジェクトを作るには、その文字列をリストに変換してみるか、array モジュールを使ってください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hello, world&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">a</span>
<span class="go">[&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;,&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s2">&quot;there!&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;Hello, there!&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">a</span>
<span class="go">array(&#39;c&#39;, &#39;Hello, world&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span> <span class="nb">print</span> <span class="n">a</span>
<span class="go">array(&#39;c&#39;, &#39;yello, world&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>
<span class="go">&#39;yello, world&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-i-use-strings-to-call-functions-methods">
<h3><a class="toc-backref" href="#id32">関数やメソッドを呼ぶのに文字列を使うにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-use-strings-to-call-functions-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>様々なテクニックがあります。</p>
<ul>
<li><p class="first">一番いいのは、文字列を関数に対応させる辞書を使うことです。このテクニックの一番の利点は、文字列が関数の名前と同じ必要がないことです。この方法は case 構造をエミュレートするための一番のテクニックでもあります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">a</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="n">dispatch</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;go&#39;</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span> <span class="n">b</span><span class="p">}</span>  <span class="c1"># Note lack of parens for funcs</span>

<span class="n">dispatch</span><span class="p">[</span><span class="n">get_input</span><span class="p">()]()</span>  <span class="c1"># Note trailing parens to call function</span>
</pre></div>
</div>
</li>
<li><p class="first">組み込み関数の <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a> を使う方法:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">foo</span>
<span class="nb">getattr</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)()</span>
</pre></div>
</div>
<p>なお、 <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a> はクラス、クラスインスタンス、モジュールなど、どんなオブジェクトにも使えます。</p>
<p>これは標準ライブラリでも何箇所か使われています。このように:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">do_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">do_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">foo_instance</span><span class="p">,</span> <span class="s1">&#39;do_&#39;</span> <span class="o">+</span> <span class="n">opname</span><span class="p">)</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a> や <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> を使って関数名を決める方法:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">myFunc</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s2">&quot;hello&quot;</span>

<span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;myFunc&quot;</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">fname</span><span class="p">]</span>
<span class="n">f</span><span class="p">()</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>ノート: <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> の使用は遅いし危険です。もしあなたが文字列の内容を絶対的に支配できなければ、任意の関数を実行されるようにする文字列を渡す人がいるかも知れません。</p>
</li>
</ul>
</div>
<div class="section" id="is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings">
<h3><a class="toc-backref" href="#id33">文字列から後端の改行を取り除く Perl の chomp() に相当するものはありますか？</a><a class="headerlink" href="#is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python 2.2 からは、 <code class="docutils literal"><span class="pre">S.rstrip(&quot;\r\n&quot;)</span></code> を使って文字列 <code class="docutils literal"><span class="pre">S</span></code> の終端から他の空白文字を取り除くことなくすべての行末記号を取り除くことができます。文字列 <code class="docutils literal"><span class="pre">S</span></code> が複数行を表し、終端に空行があるとき、そのすべての空行も取り除かれます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;line 1 </span><span class="se">\r\n</span><span class="s2">&quot;</span>
<span class="gp">... </span>         <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span>
<span class="gp">... </span>         <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\r</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&#39;line 1 &#39;</span>
</pre></div>
</div>
<p>これは典型的に一度に一行ずつテキストを読みたい時にのみ使われるので、<code class="docutils literal"><span class="pre">S.rstrip()</span></code> をこの方法で使うとうまくいきます。</p>
<p>古いバージョンの Python では、部分的な代用品が二つあります:</p>
<ul class="simple">
<li><p class="first">すべての終端の空白文字を取り除きたいなら、文字列オブジェクトの <code class="docutils literal"><span class="pre">rstrip()</span></code> メソッドを使ってください。これは改行記号一つだけでなく、すべての終端の空白文字を取り除きます。</p>
</li>
<li><p class="first">そうでなく、文字列 <code class="docutils literal"><span class="pre">S</span></code> に一行しか無いなら、<code class="docutils literal"><span class="pre">S.splitlines()[0]</span></code> を使ってください。</p>
</li>
</ul>
</div>
<div class="section" id="is-there-a-scanf-or-sscanf-equivalent">
<h3><a class="toc-backref" href="#id34">scanf() や sscanf() と同等なものはありますか？</a><a class="headerlink" href="#is-there-a-scanf-or-sscanf-equivalent" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>そのようなものはありません。</p>
<p>簡単な入力解析で、多くの場合に一番簡単な方法は、文字列オブジェクトの <a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> メソッドで行を空白文字で区切られた単語に分け、十進数の文字列を <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a> や <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a> で数値に変換することです。 <code class="docutils literal"><span class="pre">split()</span></code> にはオプションの &#8220;sep&#8221; 変数があり、行に空白文字以外の区切りを使っているときに便利です。</p>
<p>もっと複雑な入力解析をしたいなら、C の <code class="xref c c-func docutils literal"><span class="pre">sscanf()</span></code> よりも正規表現の方が便利ですし、この処理に向いています。</p>
</div>
<div class="section" id="what-does-unicodeerror-ascii-decoding-encoding-error-ordinal-not-in-range-128-mean">
<h3><a class="toc-backref" href="#id35">&#8216;UnicodeError: ASCII [decoding,encoding] error: ordinal not in range(128)&#8217; とはどういう意味ですか？</a><a class="headerlink" href="#what-does-unicodeerror-ascii-decoding-encoding-error-ordinal-not-in-range-128-mean" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このエラーは、あなたの Python インストールが 7-bit ASCII 文字列しか扱えないことを表します。この問題を扱うには二つの方法があります。</p>
<p>あなたのプログラムが、任意の文字セットエンコーディングのデータを扱わなければならないなら、一般に、アプリケーションが起動する環境によってデータのエンコーディングが特定されます。入力をそのエンコーディングを使って Unicode に変換する必要があります。例えば、email や web 入力を扱うプログラムは、概して文字セットエンコーディング情報を Content-Type ヘッダから見つけます。これに使うことで、入力データを Unicode に正しく変換できます。 <code class="docutils literal"><span class="pre">value</span></code> によって参照される文字列が UTF-8 でエンコードされているとすれば:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="o">=</span> <span class="n">unicode</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>は Unicode オブジェクトを返します。データが UTF-8 に正しく変換されないなら、上記の呼び出しは <a class="reference internal" href="../library/exceptions.html#exceptions.UnicodeError" title="exceptions.UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> 例外を送出します。</p>
<p>非 ASCII データを持つ文字列を Unicode に変換すればいいだけなら、まず ASCII エンコーディングを仮定して変換し、失敗したら Unicode オブジェクトを生成すればいいです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">unicode</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;ascii&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">UnicodeError</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">unicode</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># value was valid ASCII data</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>デフォルトのエンコーディングは、Python ライブラリの一部である <code class="docutils literal"><span class="pre">sitecustomize.py</span></code> と呼ばれるファイルで設定できます。しかし、Python 全体におけるデフォルトのエンコーディングを変えてしまうことは、サードパーティ拡張モジュールの失敗につながるのでお勧めできません。</p>
<p>なお、Windows には、 &#8220;mbcs&#8221; として知られるエンコーディングがあり、これはあなたのロケールに依存するエンコーディイングを使います。多くの場合、特に COM で作業をするとき、これが使うのに適したデフォルトのエンコーディングです。</p>
</div>
</div>
<div class="section" id="sequences-tuples-lists">
<h2><a class="toc-backref" href="#id36">シーケンス(タプル/リスト)</a><a class="headerlink" href="#sequences-tuples-lists" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-convert-between-tuples-and-lists">
<h3><a class="toc-backref" href="#id37">タプル、リスト間の変更はどのようにするのですか？</a><a class="headerlink" href="#how-do-i-convert-between-tuples-and-lists" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>型コンストラクタ <code class="docutils literal"><span class="pre">tuple(seq)</span></code> はすべてのシーケンス (実際には、すべてのイテラブル) を同じ要素、同じ順序のタプルに変換します。</p>
<p>例えば、 <code class="docutils literal"><span class="pre">tuple([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code> は <code class="docutils literal"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code> を与え、 <code class="docutils literal"><span class="pre">tuple('abc')</span></code> は <code class="docutils literal"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></code> を与えます。引数がタプルなら、コピーを作らずに引数のオブジェクトそのものを返すので、あるオブジェクトが既にタプルになっているか確信が持てないのなら、 <a class="reference internal" href="../library/functions.html#tuple" title="tuple"><code class="xref py py-func docutils literal"><span class="pre">tuple()</span></code></a> を呼ぶのが手軽です。</p>
<p>型コンストラクタ <code class="docutils literal"><span class="pre">list(seq)</span></code> はすべてのシーケンスあるいはイテラブルを同じ要素、同じ順序のリストに変換します。例えば、<code class="docutils literal"><span class="pre">list((1,</span> <span class="pre">2,</span> <span class="pre">3))</span></code> は <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> を与え、<code class="docutils literal"><span class="pre">list('abc')</span></code> は <code class="docutils literal"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code> を与えます。引数がリストなら、<code class="docutils literal"><span class="pre">seq[:]</span></code> と同様にコピーを作ります。</p>
</div>
<div class="section" id="what-s-a-negative-index">
<h3><a class="toc-backref" href="#id38">インデクスが負の場合はどうなりますか？</a><a class="headerlink" href="#what-s-a-negative-index" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python のシーケンスは正の数と負の数でインデクスされます。正の数では、0 が最初のインデクス、1 が 2 番目のインデクス、以下も同様です。負のインデクスでは、-1 が最後のインデクス、-2 が最後から 2 番目のインデクス、以下も同様です。<code class="docutils literal"><span class="pre">seq[-n]</span></code> は <code class="docutils literal"><span class="pre">seq[len(seq)-n]</span></code> と同じだと考えてください。</p>
<p>負のインデクスを使うと便利なことがあります。例えば、<code class="docutils literal"><span class="pre">S[:-1]</span></code> は文字列の最後以外のすべての文字を表すので、文字列の末尾の改行を取り除くときに便利です。</p>
</div>
<div class="section" id="how-do-i-iterate-over-a-sequence-in-reverse-order">
<h3><a class="toc-backref" href="#id39">シーケンスを逆順にイテレートするにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-iterate-over-a-sequence-in-reverse-order" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python 2.4 で追加された <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal"><span class="pre">reversed()</span></code></a> を使ってください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c1"># do something with x ...</span>
</pre></div>
</div>
<p>これは元のシーケンスをいじるのではなく、逆順の新しいコピーを作ってイテレートさせます。</p>
<p>Python 2.3 では、拡張スライス構文を使います:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="o">...</span>  <span class="c1"># do something with x ...</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-you-remove-duplicates-from-a-list">
<h3><a class="toc-backref" href="#id40">リストから重複を取り除くにはどうしますか？</a><a class="headerlink" href="#how-do-you-remove-duplicates-from-a-list" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python Cookbook の長い議論に多くの方法があるので参照してください:</p>
<blockquote>
<div><a class="reference external" href="https://code.activestate.com/recipes/52560/">https://code.activestate.com/recipes/52560/</a></div></blockquote>
<p>リストを並び替えて構わないのなら、ソートした上でリストの最初から最後までを調べ、次のように重複を削除してください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">mylist</span><span class="p">:</span>
    <span class="n">mylist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">last</span> <span class="o">==</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">del</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>リストのすべての要素が辞書のキーとして使える (つまり、すべての要素が hashable) なら、おそらくこのほうが速いです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">:</span>
    <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">mylist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
</div>
<p>Python 2.5 以上では、以下を代わりに使えます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mylist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mylist</span><span class="p">))</span>
</pre></div>
</div>
<p>リストを集合に変換するときに重複は取り除かれるので、それをリストに戻せばいいのです。</p>
</div>
<div class="section" id="how-do-you-make-an-array-in-python">
<h3><a class="toc-backref" href="#id41">Python で配列を作るにはどうしますか？</a><a class="headerlink" href="#how-do-you-make-an-array-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>リストを使ってください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s2">&quot;this&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="s2">&quot;an&quot;</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>リストの時間計算量は C や Pascal の配列と同じです。大きな違いは、Python のリストは多くの異なる型のオブジェクトを含めることです。</p>
<p><code class="docutils literal"><span class="pre">array</span></code> モジュールにも固定された型を簡潔に表現する配列を作るためのメソッドがありますが、リストよりもインデクスが遅いです。また、Numeric 拡張その他でも、様々な特徴をもつ配列的な構造体が定義されています。</p>
<p>Lisp 方式の連結リストを得るのに、タプルを使ってコンスセルをエミュレートできます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">lisp_list</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;like&quot;</span><span class="p">,</span>  <span class="p">(</span><span class="s2">&quot;this&quot;</span><span class="p">,</span>  <span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>ミュータブルな必要があるなら、タプルではなくリストを使いましょう。lisp の car にあたるものが <code class="docutils literal"><span class="pre">lisp_list[0]</span></code> で、cdr にあたるものが <code class="docutils literal"><span class="pre">lisp_list[1]</span></code> です。本当に必要だと確信できるとき以外はこれはしないでください。たいてい、これは Python のリストを使うよりも非常に遅いですから。</p>
</div>
<div class="section" id="how-do-i-create-a-multidimensional-list">
<span id="faq-multidimensional-list"></span><h3><a class="toc-backref" href="#id42">多次元のリストを作るにはどうしますか？</a><a class="headerlink" href="#how-do-i-create-a-multidimensional-list" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このようにして多次元の配列を作ろうとしてしまったことがあるでしょう:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
</pre></div>
</div>
<p>これを表示したときには問題なさそうに見えます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[[None, None], [None, None], [None, None]]</span>
</pre></div>
</div>
<p>しかし値を代入すると、その値が複数の場所に現れてしまいます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[[5, None], [5, None], [5, None]]</span>
</pre></div>
</div>
<p>これは、<code class="docutils literal"><span class="pre">*</span></code> を使ったリストの複製がコピーを作らず、存在するオブジェクトへの参照を作るだけだからです。この <code class="docutils literal"><span class="pre">*3</span></code> は長さ 2 の同じリストへの参照を含むリストを作ります。一つの列に対する変更はすべての列に現れますが、これが望んだ結果であることはまずないでしょう。</p>
<p>おすすめの方法は、最初に望んだ長さのリストを作り、それから新しく作ったリストでそれぞれの要素を埋めていくことです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
</pre></div>
</div>
<p>これは長さ 2 の異なるリスト 3 つを含むリストを生成します。リスト内包表記も使えます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">)]</span>
</pre></div>
</div>
<p>あるいは、行列データ型を提供している拡張を使用することもできます; <a class="reference external" href="http://www.numpy.org/">NumPy</a> が最もよく知られています。</p>
</div>
<div class="section" id="how-do-i-apply-a-method-to-a-sequence-of-objects">
<h3><a class="toc-backref" href="#id43">オブジェクトのシーケンスにメソッドを適用するにはどうしますか？</a><a class="headerlink" href="#how-do-i-apply-a-method-to-a-sequence-of-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>リスト内包表記を使ってください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">method</span><span class="p">()</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">]</span>
</pre></div>
</div>
<p>もっと一般化したければ、以下の関数を試してみてください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">method_map</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">arguments</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;method_map([a,b], &quot;meth&quot;, (1,2)) gives [a.meth(1,2), b.meth(1,2)]&quot;&quot;&quot;</span>
    <span class="n">nobjects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
    <span class="n">methods</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">getattr</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">*</span><span class="n">nobjects</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">apply</span><span class="p">,</span> <span class="n">methods</span><span class="p">,</span> <span class="p">[</span><span class="n">arguments</span><span class="p">]</span><span class="o">*</span><span class="n">nobjects</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works">
<h3><a class="toc-backref" href="#id44">なぜ加算はされるのに a_tuple[i] += [&#8216;item&#8217;] は例外を送出するのですか?</a><a class="headerlink" href="#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これは、拡張代入演算子は <em>代入</em> 演算子だ、という事実と、Python での可変オブジェクトと不変オブジェクトの違いが組み合わさって起きるのです。</p>
<p>この議論は一般的に、可変オブジェクトを指すタプルの要素に、拡張代入演算子が適用されたときにも適用できますが、例として <code class="docutils literal"><span class="pre">list</span></code> と <code class="docutils literal"><span class="pre">+=</span></code> を使います。</p>
<p>次のように書いたとします:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>例外が送出された理由は明らかです: <code class="docutils literal"><span class="pre">1</span></code> が (<code class="docutils literal"><span class="pre">1</span></code>) を指すオブジェクト <code class="docutils literal"><span class="pre">a_tuple[0]</span></code> に加えられ、結果のオブジェクト <code class="docutils literal"><span class="pre">2</span></code> が生成されますが、計算結果 <code class="docutils literal"><span class="pre">2</span></code> をタプルの第 <code class="docutils literal"><span class="pre">0</span></code> 要素に代入しようとしたときに、エラーが発生します。なぜならば、タプルの要素が何を指すかは変えられないからです。</p>
<p>このような裏事情の元、拡張代入文はだいたい次のようなことをしています:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>タプルは不変なので、例外を生み出しているのは操作の代入部分なのです。</p>
<p>次のように書いたとします:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;foo&#39;</span><span class="p">],</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;item&#39;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>この例外にはちょっと驚きますが、もっと驚くべきことは、エラーがあったとしても追記はきちんと動いている、という事実です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[&#39;foo&#39;, &#39;item&#39;]</span>
</pre></div>
</div>
<p>なぜこれが起きるかを調べるためには、次の 2 点を知っている必要があります。(a) オブジェクトに <code class="docutils literal"><span class="pre">__iadd__</span></code> 特殊メソッドが実装されている場合、拡張代入 <code class="docutils literal"><span class="pre">+=</span></code> が実行されるときにそれが呼び出され、その返り値が代入文で使われます; (b) リストでは、<code class="docutils literal"><span class="pre">__iadd__</span></code> は <code class="docutils literal"><span class="pre">extend</span></code> の呼び出しと等価で、リストを返します。こんな理由で、リストでは <code class="docutils literal"><span class="pre">+=</span></code> は <code class="docutils literal"><span class="pre">list.extend</span></code> の &#8220;略記&#8221; だと言ったのでした:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>これは次のと等価です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_list</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">=</span> <span class="n">result</span>
</pre></div>
</div>
<p>a_list が指していたオブジェクトは更新され、更新されたオブジェクトへのポインタは再度 <code class="docutils literal"><span class="pre">a_list</span></code> に代入されます。代入しているのは、<code class="docutils literal"><span class="pre">a_list</span></code> が更新前まで指していた同じオブジェクトへのポインタなので、代入は最終的には何もしていないのですが、代入処理自体は起きています。</p>
<p>従って、今のタプルの例では、次のと同じことが起きています:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">([</span><span class="s1">&#39;item&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">__iadd__</span></code> は成功し、リストは拡張 (extend) されますが、<code class="docutils literal"><span class="pre">result</span></code> が <code class="docutils literal"><span class="pre">a_tuple[0]</span></code> が既に指しているオブジェクトと同じオブジェクトを指していたとしても、タプルは不変なので、その最後の代入はやはりエラーとなります。</p>
</div>
</div>
<div class="section" id="dictionaries">
<h2><a class="toc-backref" href="#id45">辞書</a><a class="headerlink" href="#dictionaries" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-can-i-get-a-dictionary-to-display-its-keys-in-a-consistent-order">
<h3><a class="toc-backref" href="#id46">一貫した順序でキーを表示する辞書はありますか?</a><a class="headerlink" href="#how-can-i-get-a-dictionary-to-display-its-keys-in-a-consistent-order" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>できません。辞書はキーを予測できない順序で保存しているので、辞書の要素が表示される順序もまた予測できないのです。</p>
<p>ファイルに印字可能なバージョンを保存し、変更を加えてから他の印字された辞書と比較したい時に苛立たしいかもしれません。この場合は、 <code class="docutils literal"><span class="pre">pprint</span></code> モジュールで辞書を整形して表示してください。要素がキーでソートされて表されます。</p>
<p>もっと複雑な解決策は、 <code class="docutils literal"><span class="pre">dict</span></code> のサブクラスとして <code class="docutils literal"><span class="pre">SortedDict</span></code> クラスを作り、それに予測可能な順序で自身を表示させることです。そのようなクラスの単純な実装の一つは:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SortedDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2">: </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;{{</span><span class="si">{}</span><span class="s2">}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="fm">__repr__</span>
</pre></div>
</div>
<p>これは完璧な解法とは程遠いですが、多くの状況でうまく働くでしょう。最大の欠点は、辞書内のどれかの値がまた辞書であった場合に、それらの値はどんな特定の順序でも表示されないことです。</p>
</div>
<div class="section" id="i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python">
<h3><a class="toc-backref" href="#id47">複雑なソートがしたいのですが、Python でシュワルツ変換はできますか？</a><a class="headerlink" href="#i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Perl コミュニティの Randal Schwartz の作とされるこのテクニックは、それぞれの要素に「ソート値」を対応付けるある尺度によって、リストの要素をソートします。
Python では、 <code class="xref py py-func docutils literal"><span class="pre">sort()</span></code> 関数で <code class="docutils literal"><span class="pre">key</span></code> 引数を使ってください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Isorted</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:]</span>
<span class="n">Isorted</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">15</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="section" id="how-can-i-sort-one-list-by-values-from-another-list">
<h3><a class="toc-backref" href="#id48">リストを別のリストの値によってソートするにはどうしますか？</a><a class="headerlink" href="#how-can-i-sort-one-list-by-values-from-another-list" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>二つのリストを混ぜあわせてタプルのリストにしてから、必要な要素を選んでください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">list1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;what&quot;</span><span class="p">,</span> <span class="s2">&quot;I&#39;m&quot;</span><span class="p">,</span> <span class="s2">&quot;sorting&quot;</span><span class="p">,</span> <span class="s2">&quot;by&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">list2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;something&quot;</span><span class="p">,</span> <span class="s2">&quot;else&quot;</span><span class="p">,</span> <span class="s2">&quot;to&quot;</span><span class="p">,</span> <span class="s2">&quot;sort&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span>
<span class="go">[(&#39;what&#39;, &#39;something&#39;), (&quot;I&#39;m&quot;, &#39;else&#39;), (&#39;sorting&#39;, &#39;to&#39;), (&#39;by&#39;, &#39;sort&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">[&#39;else&#39;, &#39;sort&#39;, &#39;to&#39;, &#39;something&#39;]</span>
</pre></div>
</div>
<p>最後の段階の別のやり方は:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>これのほうが読みやすいと、最後のリスト内包表記ではなくこれを使いたくなるかもしれません。しかし、これは長いリストではほぼ二倍の時間がかかります。なぜでしょうか。まず、<code class="docutils literal"><span class="pre">append()</span></code> 演算はメモリを割り当て直す必要があり、それを避けるために毎回ちょっと工夫していますが、それでも避けられないことがあるので、少し時間がかかるのです。二つ目に、&#8221;result.append&#8221; には属性探索が余計に必要で、三つ目に、これらすべての関数を呼ぶ必要があることで速度が落ちてしまいます。</p>
</div>
</div>
<div class="section" id="objects">
<h2><a class="toc-backref" href="#id49">オブジェクト</a><a class="headerlink" href="#objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="what-is-a-class">
<h3><a class="toc-backref" href="#id50">クラスとは何ですか？</a><a class="headerlink" href="#what-is-a-class" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>クラスは、class 文の実行で生成される特殊なオブジェクトです。クラスオブジェクトはインスタンスオブジェクトを生成するためのテンプレートとして使われ、あるデータ型に特有のデータ (attribute/属性) とコード (メソッド) の両方を内蔵しています。</p>
<p>新しいクラスを一つ以上の他のクラス (新しいクラスの基底クラスと呼ばれます) に基づいて作ることもできます。この新しいクラスは、基底クラスから属性とメソッドを継承します。これにより、オブジェクトモデルを継承で連続的に洗練できます。メールボックスへの基本的なアクセサを提供する一般的な <code class="docutils literal"><span class="pre">Mailbox</span></code> クラスを作って、それからいろいろな特定のメールボックスの形式を扱う <code class="docutils literal"><span class="pre">MboxMailbox</span></code>、<code class="docutils literal"><span class="pre">MaildirMailbox</span></code>、<code class="docutils literal"><span class="pre">OutlookMailbox</span></code> のようなサブクラスを作れるのです。</p>
</div>
<div class="section" id="what-is-a-method">
<h3><a class="toc-backref" href="#id51">メソッドとは何ですか？</a><a class="headerlink" href="#what-is-a-method" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>メソッドは、オブジェクト <code class="docutils literal"><span class="pre">x</span></code> が持つ関数で、通常 <code class="docutils literal"><span class="pre">x.name(arguments...)</span></code> として呼び出されるものです。メソッドはクラス定義の中で関数として定義されます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span>
</pre></div>
</div>
</div>
<div class="section" id="what-is-self">
<h3><a class="toc-backref" href="#id52">self とは何ですか？</a><a class="headerlink" href="#what-is-self" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>self はメソッドの第一引数に慣習的につけられる名前にすぎません。<code class="docutils literal"><span class="pre">meth(self,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> として定義されたメソッドは、その定義がなされたクラスのインスタンス <code class="docutils literal"><span class="pre">x</span></code> に対して <code class="docutils literal"><span class="pre">x.meth(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> として呼び出されます。呼び出されたメソッドは、<code class="docutils literal"><span class="pre">meth(x,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> が呼ばれたものと考えます。</p>
<p><a class="reference internal" href="design.html#why-self"><span class="std std-ref">なぜメソッドの定義や呼び出しにおいて &#8216;self&#8217; を明示しなければならないのですか？</span></a> も参照してください。</p>
</div>
<div class="section" id="how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it">
<h3><a class="toc-backref" href="#id53">あるオブジェクトが、与えられたクラスやそのサブクラスのインスタンスであるかを調べるにはどうしますか？</a><a class="headerlink" href="#how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ビルトイン関数 <code class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">cls)</span></code> を使ってください。クラスのタプルを与えて <code class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">(class1,</span> <span class="pre">class2,</span> <span class="pre">...))</span></code> のようにすれば、あるオブジェクトが任意の数のクラスのオブジェクトであるかを調べられますし、 <code class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">str)</span></code> や <code class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">(int,</span> <span class="pre">long,</span> <span class="pre">float,</span> <span class="pre">complex))</span></code> のようにすれば、Python のビルトイン型のオブジェクトであるかも調べられます。</p>
<p>なお、大部分のプログラムでは、 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> をユーザー定義のクラスに何度も使うべきではありません。クラスを自分で開発するときに、適切なオブジェクト指向スタイルは、特定の振る舞いをカプセル化するクラスのメソッドを定義するものであって、オブジェクトのクラスを調べてそのクラスに応じて違うことをするものではありません。例えば、何かをする関数があったとして:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Mailbox</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># code to search a mailbox</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Document</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># code to search a document</span>
    <span class="k">elif</span> <span class="o">...</span>
</pre></div>
</div>
<p>よりよいアプローチは、<code class="docutils literal"><span class="pre">search()</span></code> メソッドをすべてのクラスに定義して、それをただ呼び出すことです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mailbox</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># code to search a mailbox</span>

<span class="k">class</span> <span class="nc">Document</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># code to search a document</span>

<span class="n">obj</span><span class="o">.</span><span class="n">search</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="what-is-delegation">
<h3><a class="toc-backref" href="#id54">委譲とは何ですか？</a><a class="headerlink" href="#what-is-delegation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>委譲 (delegation) とは、オブジェクト指向のテクニック (デザインパターンとも呼ばれる) の一つです。オブジェクト <code class="docutils literal"><span class="pre">x</span></code> があって、そのメソッドのうちただ一つの振る舞いを変えたいとしましょう。新しいクラスを作成し、変えたいメソッドだけを新しく実装し、他のすべてのメソッドを <code class="docutils literal"><span class="pre">x</span></code> の対応するメソッドに委譲する新しいクラスを作れます。</p>
<p>Python プログラマは簡単に委譲を実装できます。例えば、以下のクラスは、ファイルのように振る舞いながらすべての文字を大文字に変換するクラスを実装します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UpperOut</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span> <span class="o">=</span> <span class="n">outfile</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで <code class="docutils literal"><span class="pre">UpperOut</span></code> クラスは <code class="docutils literal"><span class="pre">write()</span></code> メソッドを定義しなおして、引数の文字列を大文字に変換してから基礎となる <code class="docutils literal"><span class="pre">self.__outfile.write()</span></code> メソッドを呼び出すようにします。その他すべてのメソッドは基礎となる <code class="docutils literal"><span class="pre">self.__outfile</span></code> オブジェクトに移譲されます。この委譲は <code class="docutils literal"><span class="pre">__getattr__</span></code> メソッドを通してなされます。属性の制御の詳細は <a class="reference internal" href="../reference/datamodel.html#attribute-access"><span class="std std-ref">言語リファレンス</span></a> を参照してください。</p>
<p>なお、一般的に委譲はトリッキーになりがちです。属性が設定される時には読み出される時と同様に、そのクラスに <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> メソッドを定義する必要があり、それには細心の注意が必要です。 <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> の基本的な実装はおおよそ以下のようになります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>たいてい、 <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> 実装は <code class="docutils literal"><span class="pre">self.__dict__</span></code> を変更して、無限再帰を起こすことなくローカルな状態を保存するようにしなければなりません。</p>
</div>
<div class="section" id="how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-overrides-it">
<h3><a class="toc-backref" href="#id55">基底クラスで定義されたメソッドを、そのクラスをオーバーライドした派生クラスから呼び出すにはどうしますか？</a><a class="headerlink" href="#how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-overrides-it" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>新スタイルのクラスを使っている場合は、組み込みの <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a> 関数を使ってください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Derived</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>
</pre></div>
</div>
<p>旧スタイルクラスを使っているなら: <code class="docutils literal"><span class="pre">class</span> <span class="pre">Derived(Base):</span> <span class="pre">...</span></code> のようなクラス定義で、 <code class="docutils literal"><span class="pre">Base.meth(self,</span> <span class="pre">arguments...)</span></code> とすれば、 <code class="docutils literal"><span class="pre">Base</span></code> (または <code class="docutils literal"><span class="pre">Base</span></code> の基底クラス) で定義された <code class="docutils literal"><span class="pre">meth()</span></code> メソッドを呼び出せます。ここで、 <code class="docutils literal"><span class="pre">Base.meth</span></code> は束縛されていないメソッドなので、 <code class="docutils literal"><span class="pre">self</span></code> 引数を渡す必要があります。</p>
</div>
<div class="section" id="how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class">
<h3><a class="toc-backref" href="#id56">基底クラスの名前を変えやすいコードを書くにはどうしますか？</a><a class="headerlink" href="#how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>基底クラスのエイリアス (alias) を定義し、先にそれに本当の基底クラスを代入しておいてから、クラス定義の中でそのエイリアスを使うといいかもしれません。そうすればエイリアスに代入する値を変えるだけで済みます。ちなみに、この手法は使用する基底クラスを動的に選びたいとき、例えば使えるリソースによって選びたいときなどにも便利です。例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">BaseAlias</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">real</span> <span class="n">base</span> <span class="n">class</span><span class="o">&gt;</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">BaseAlias</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">BaseAlias</span><span class="o">.</span><span class="n">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-i-create-static-class-data-and-static-class-methods">
<h3><a class="toc-backref" href="#id57">静的なクラスデータや静的なクラスメソッドを作るにはどうしますか？</a><a class="headerlink" href="#how-do-i-create-static-class-data-and-static-class-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>(C++ や Java の意味で) 静的なデータも静的なメソッドも Python でサポートされています。</p>
<p>静的なデータを作るには、単純にクラス属性を定義してください。その属性に新しい値を代入するには、代入するクラス名を明示する必要があります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># number of times C.__init__ called</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">getcount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span>  <span class="c1"># or return self.count</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">c</span></code> そのものや <code class="docutils literal"><span class="pre">c.__class__</span></code> から <code class="docutils literal"><span class="pre">C</span></code> にいたるパス探索経路上のクラスによってオーバーライドされない限り、<code class="docutils literal"><span class="pre">c.count</span></code> も <code class="docutils literal"><span class="pre">isinstance(c,</span> <span class="pre">C)</span></code> であるすべての <code class="docutils literal"><span class="pre">c</span></code> に対する <code class="docutils literal"><span class="pre">C.count</span></code> を参照します。</p>
<p>注意: C のメソッド内では、<code class="docutils literal"><span class="pre">self.count</span> <span class="pre">=</span> <span class="pre">42</span></code> のような代入は <code class="docutils literal"><span class="pre">self</span></code> 自身の辞書に &#8220;count&#8221; という名前の新しくて関係ないインスタンスを作ります。クラスの静的なデータの再束縛には、メソッド内であるか否かにかかわらず、いつもクラスを指定しなければなりません:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">314</span>
</pre></div>
</div>
<p>Python 2.2 からは、静的メソッドが使えます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">static</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">):</span>
        <span class="c1"># No &#39;self&#39; parameter!</span>
        <span class="o">...</span>
    <span class="n">static</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">static</span><span class="p">)</span>
</pre></div>
</div>
<p>Python 2.4 のデコレータを使って、以下のようにも書けます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">static</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">):</span>
        <span class="c1"># No &#39;self&#39; parameter!</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>しかし、静的メソッドの効果を得るもっと簡単な方法は、単にモジュールレベル関数を使うことです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">getcount</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span>
</pre></div>
</div>
<p>モジュールあたりに一つのクラスを定義するように (あるいはクラス組織を厳密に関連させるように) コードが構成されているなら、これで必要なカプセル化ができます。</p>
</div>
<div class="section" id="how-can-i-overload-constructors-or-methods-in-python">
<h3><a class="toc-backref" href="#id58">Python でコンストラクタ(やメソッド)をオーバーロードするにはどうしたらいいですか？</a><a class="headerlink" href="#how-can-i-overload-constructors-or-methods-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この質問の答えはすべてのメソッドについて言えることですが、この質問はだいたい以下の構造の文脈から出てきます。</p>
<p>C++ では、このように書けます</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">class</span> <span class="n">C</span> <span class="p">{</span>
    <span class="n">C</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No arguments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Argument is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Python では、一つのコンストラクタでデフォルトの引数を使ってすべての場合に対応するように書かなければなりません。例えば:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;No arguments&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;Argument is&quot;</span><span class="p">,</span> <span class="n">i</span>
</pre></div>
</div>
<p>これで完全に等価とは言えませんが、実用上は十分に近いです。</p>
<p>長さが変えられる引数のリストを試すには、例えば</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>これと同じやり方がすべてのメソッド定義で使えます。</p>
</div>
<div class="section" id="i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam">
<h3><a class="toc-backref" href="#id59">__spam を使おうとしたら _SomeClassName__spam からエラーがでました。</a><a class="headerlink" href="#i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>先頭にアンダースコアが二つ付いた変数名は、クラスのプライベートな変数を、&#8221;マングル化&#8221;という単純かつ効率のいい方法で定義します。<code class="docutils literal"><span class="pre">__spam</span></code> のような形式 (先頭に二つ以上、末尾にもしあっても一つのアンダースコアがある) のすべての識別子は、<code class="docutils literal"><span class="pre">classname</span></code> が先頭のアンダースコアをすべて削除した現在のクラス名とすれば、<code class="docutils literal"><span class="pre">_classname__spam</span></code> のように文字上で置換えられます。</p>
<p>これはプライベートであることを保証するものではありません。これでも外部のユーザが &#8220;_classname__spam&#8221; 属性に直接アクセスできますし、プライベートな変数はオブジェクトの <code class="docutils literal"><span class="pre">__dict__</span></code> から見えます。多くの Python プログラマはわざわざプライベートな変数名を使おうとなど考えません。</p>
</div>
<div class="section" id="my-class-defines-del-but-it-is-not-called-when-i-delete-the-object">
<h3><a class="toc-backref" href="#id60">クラスに __del__ メソッドを定義しているのですが、オブジェクトを削除したときに呼ばれません。</a><a class="headerlink" href="#my-class-defines-del-but-it-is-not-called-when-i-delete-the-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>いくつかの可能性があります。</p>
<p>del 文は必ずしも <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> を呼び出すとは限りません &#8211; これは単純にオブジェクトの参照カウントを減らすもので、カウントがゼロになったときに <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> が呼び出されます。</p>
<p>データ構造が循環リンク (子のそれぞれが親の参照を持ち、親のそれぞれが子のリストを持つツリーなど) を含む場合、その参照カウントは決して 0 にはなりません。時々、Python はこのようなサイクルを検出するアルゴリズムを実行しますが、データ構造への参照がなくなってからこのガベージコレクタが実行されるまでいくらか時間が掛かるかもしれないので、 <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドは不都合な予期できないタイミングで呼び出されるかもしれません。これは問題を再現しようとするときに不便です。さらに悪いことに、オブジェクトの <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドが実行される順序は任意です。 <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref py py-func docutils literal"><span class="pre">gc.collect()</span></code></a> を起動して収集を強制することができますが、オブジェクトが決して回収されないような本当に病的な場合も <em>あります</em> 。</p>
<p>周期的なコレクタにかかわらず、オブジェクトに <code class="docutils literal"><span class="pre">close()</span></code> メソッドを明示的に定義し、使い終わったらいつでも呼び出せるようにするのはいいことです。そうすれば <code class="docutils literal"><span class="pre">close()</span></code> メソッドはサブオブジェクトへの参照をする属性を取り除いてくれます。 <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> を直接呼び出さないでください &#8211; <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> は <code class="docutils literal"><span class="pre">close()</span></code> を呼び出すでしょうし、 <code class="docutils literal"><span class="pre">close()</span></code> なら同じオブジェクトに対して複数回呼ばれてもいいことが保証されているでしょう。</p>
<p>循環参照を避ける他の方法は、 <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> モジュールを使って、参照カウントを増やすことなくオブジェクトを示すことです。例えばツリー構造は、親と (必要なら！) 兄弟に弱参照を使うべきです。</p>
<p>except 節で例外を捕まえた関数内でオブジェクトがローカル変数であったたなら、そのオブジェクトへの参照が関数のスタックフレーム内でスタックトレース内に含まれることで存在する可能性があります。通常、 <a class="reference internal" href="../library/sys.html#sys.exc_clear" title="sys.exc_clear"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_clear()</span></code></a> を呼び出せば、最後に記録された例外を消去することで対処してくれます。</p>
<p>最後に、 <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドが例外を発生させた場合、警告のメッセージが <a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></code></a> に書きこまれます。</p>
</div>
<div class="section" id="how-do-i-get-a-list-of-all-instances-of-a-given-class">
<h3><a class="toc-backref" href="#id61">与えられたクラスのすべてのインスタンスのリストを得るにはどうしますか？</a><a class="headerlink" href="#how-do-i-get-a-list-of-all-instances-of-a-given-class" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python はクラス (やビルトイン型) のすべてのインスタンスをたどりません。クラスのコンストラクタにそれぞれのインスタンスへの弱参照のリストを作らせることですべてのインスタンスをたどらせられます。</p>
</div>
<div class="section" id="why-does-the-result-of-id-appear-to-be-not-unique">
<h3><a class="toc-backref" href="#id62">なぜ <code class="docutils literal"><span class="pre">id()</span></code> の結果は一意でないように見えるのですか?</a><a class="headerlink" href="#why-does-the-result-of-id-appear-to-be-not-unique" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>組み込みの <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal"><span class="pre">id()</span></code></a> は、オブジェクトが生きている間は一意であることが保証されている整数値を返します。 CPython では、それはオブジェクトのメモリアドレスなので、オブジェクトがメモリから削除された後に、次に新しく生成されたオブジェクトはメモリの同じ場所にメモリ領域を確保されていることが、しばしば起きます。この現象を次の例で示しましょう:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="go">13901272</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span>
<span class="go">13901272</span>
</pre></div>
</div>
<p>2 つの同じ値を持つ id は <code class="docutils literal"><span class="pre">id()</span></code> の実行の前に作られてすぐさま削除された異なる整数オブジェクトによるものです。id を調べたいオブジェクトがまだ生きてることを保証したいなら、オブジェクトへの別の参照を作ってください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">13901272</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">13891296</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="modules">
<h2><a class="toc-backref" href="#id63">モジュール</a><a class="headerlink" href="#modules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-create-a-pyc-file">
<h3><a class="toc-backref" href="#id64">.pyc ファイルを作るにはどうしますか？</a><a class="headerlink" href="#how-do-i-create-a-pyc-file" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールが最初にインポートされるとき (またはソースが現在コンパイルされているファイルよりも新しいとき)、コンパイルされたコードを含む <code class="docutils literal"><span class="pre">.pyc</span></code> ファイルが <code class="docutils literal"><span class="pre">.py</span></code> ファイルと同じディレクトリに作られるでしょう。</p>
<p><code class="docutils literal"><span class="pre">.pyc</span></code> ファイルが作られないとしたら、ディレクトリの権限の問題があるかもしれません。たとえばこれは、web サーバなどでテストするときのように、開発のときと違うユーザとして起動するときなどに起こりえます。モジュールをインポートしたときに Python がコンパイルされたモジュールをディレクトリに書き込むための条件 (権限、容量の空き、etc...) が揃っていれば、.pyc ファイルの生成は自動的に行われます。</p>
<p>トップレベルのスクリプトを実行することはインポートとは見做されず、 <code class="docutils literal"><span class="pre">.pyc</span></code> は生成されません。例えば、トップレベルモジュール <code class="docutils literal"><span class="pre">abc.py</span></code> があって、他のモジュール <code class="docutils literal"><span class="pre">xyz.py</span></code> をインポートするようになっているとき、abc を起動すると、xyz のインポート時に <code class="docutils literal"><span class="pre">xyz.pyc</span></code> が生成されますが、 <code class="docutils literal"><span class="pre">abc.py</span></code> はインポートされないので <code class="docutils literal"><span class="pre">abc.pyc</span></code> ファイルは生成されません。</p>
<p>abc.pyc が必要なら &#8211; つまり、インポートされないモジュールの <code class="docutils literal"><span class="pre">.pyc</span></code> ファイルを生成するためには &#8211; <a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Generate byte-code files from Python source files."><code class="xref py py-mod docutils literal"><span class="pre">py_compile</span></code></a> や <a class="reference internal" href="../library/compileall.html#module-compileall" title="compileall: Tools for byte-compiling all Python source files in a directory tree."><code class="xref py py-mod docutils literal"><span class="pre">compileall</span></code></a> モジュールが利用できます。</p>
<p><a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Generate byte-code files from Python source files."><code class="xref py py-mod docutils literal"><span class="pre">py_compile</span></code></a> モジュールは手動で任意のモジュールをコンパイルできます。やり方の一つは、このモジュールの <code class="docutils literal"><span class="pre">compile()</span></code> 関数をインタラクティブに実行することです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_compile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">py_compile</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;foo.py&#39;</span><span class="p">)</span>                 
</pre></div>
</div>
<p>このように実行すると、<code class="docutils literal"><span class="pre">foo.py</span></code> と同じ場所に <code class="docutils literal"><span class="pre">.pyc</span></code> が書き出されます (出力ファイルの位置は、オプション引数 <code class="docutils literal"><span class="pre">cfile</span></code> で上書きすることもできます)。</p>
<p><a class="reference internal" href="../library/compileall.html#module-compileall" title="compileall: Tools for byte-compiling all Python source files in a directory tree."><code class="xref py py-mod docutils literal"><span class="pre">compileall</span></code></a> モジュールを使えば自動的に一つや複数のディレクトリのすべてのファイルをコンパイルできます。シェルプロンプトから <code class="docutils literal"><span class="pre">compileall.py</span></code> を起動して、コンパイルしたいファイルを含むディレクトリのパスを指定してください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">compileall</span> <span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-i-find-the-current-module-name">
<h3><a class="toc-backref" href="#id65">現在のモジュール名を知るにはどうしますか？</a><a class="headerlink" href="#how-do-i-find-the-current-module-name" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールは前もって定義されたグローバル変数 <code class="docutils literal"><span class="pre">__name__</span></code> を検索することで自身の名前を決定できます。この値が <code class="docutils literal"><span class="pre">'__main__'</span></code> であるとき、そのプログラムはスクリプトとして実行されています。インポートされることによって使われる大抵のモジュールはコマンドラインインタフェースや自己テストも提供していて、<code class="docutils literal"><span class="pre">__name__</span></code> をチェックしてからそのコードだけを実行します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s1">&#39;Running test...&#39;</span>
    <span class="o">...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="how-can-i-have-modules-that-mutually-import-each-other">
<h3><a class="toc-backref" href="#id66">相互にインポートしあうモジュールを作るにはどうしたらいいですか？</a><a class="headerlink" href="#how-can-i-have-modules-that-mutually-import-each-other" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のモジュールがあったとしましょう:</p>
<p>foo.py:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bar</span> <span class="k">import</span> <span class="n">bar_var</span>
<span class="n">foo_var</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>bar.py:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">foo</span> <span class="k">import</span> <span class="n">foo_var</span>
<span class="n">bar_var</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>問題はインタプリタが以下の段階を実行することです:</p>
<ul class="simple">
<li><p class="first">main が foo をインポートする</p>
</li>
<li><p class="first">foo の空のグローバルが生成される</p>
</li>
<li><p class="first">foo がコンパイルされ実行を始める</p>
</li>
<li><p class="first">foo が bar をインポートする</p>
</li>
<li><p class="first">bar の空のグローバルが生成される</p>
</li>
<li><p class="first">bar がコンパイルされ実行を始める</p>
</li>
<li><p class="first">bar が foo をインポートする(すでに foo という名前のモジュールがあるので no-op となる)</p>
</li>
<li>bar.foo_var = foo.foo_var</li>
</ul>
<p>この最後の段階は失敗します。Python が <code class="docutils literal"><span class="pre">foo</span></code> を解釈し終わっていなくて、<code class="docutils literal"><span class="pre">foo</span></code> のグローバルなシンボルの辞書はまだ空ですから。</p>
<p><code class="docutils literal"><span class="pre">import</span> <span class="pre">foo</span></code> を使って、グローバルコードの <code class="docutils literal"><span class="pre">foo.foo_var</span></code> にアクセスしようとしたときにも、これと同じことが起こります。</p>
<p>この問題には (少なくとも) 三つの解決策があります。</p>
<p>Guido van Rossum は <code class="docutils literal"><span class="pre">from</span> <span class="pre">&lt;module&gt;</span> <span class="pre">import</span> <span class="pre">...</span></code> を全く使わないで、すべてのコードを関数の中に入れることを勧めています。グローバル変数とクラス変数の初期化は定数とビルトイン関数のみで行われるべきです。これでインポートされたすべてのモジュールは <code class="docutils literal"><span class="pre">&lt;module&gt;.&lt;name&gt;</span></code> として参照されることになります。</p>
<p>Jim Roskind はそれぞれのモジュールに対して以下の順に進めることを提案しています:</p>
<ul class="simple">
<li><p class="first">エクスポート (インポートされた基底クラスを必要としないグローバル、関数、クラス)</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">import</span></code> 文</p>
</li>
<li><p class="first">アクティブなコード (インポートされた値によって初期化されるグローバルを含む)。</p>
</li>
</ul>
<p>インポートが奇妙な場所に現れることから van Rossum はこの方法をそれほど好みませんが、これは有効です。</p>
<p>Matthias Urlichs は第一に再帰インポートが必要ないようにコードを構築しなおすことを推奨しています。</p>
<p>これらの解決策はそれぞれ両立させることもできます。</p>
</div>
<div class="section" id="import-x-y-z-returns-module-x-how-do-i-get-z">
<h3><a class="toc-backref" href="#id67">__import__(&#8216;x.y.z&#8217;) は &lt;module &#8216;x&#8217;&gt; を返しますが、z を得るためにはどうしますか？</a><a class="headerlink" href="#import-x-y-z-returns-module-x-how-do-i-get-z" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>mod:<cite>importlib</cite> に <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">import_module()</span></code></a> という便利な関数があるので、代わりにそちらを使用することを検討してください。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;x.y.z&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen">
<h3><a class="toc-backref" href="#id68">インポートされたモジュールを編集してから再インポートしましたが、変化が現れません。なぜですか？</a><a class="headerlink" href="#when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>効率と一貫性上の理由から、Python はモジュールが最初にインポートされた時にのみモジュールファイルを読み込みます。そうしないと、たくさんのモジュールでできていて、それぞれが同じ基本モジュールをインポートしているようなプログラムでは、その基本モジュールの解析と再解析が繰り返されることになります。変更されさたモジュールの再読込を強制するには、こうしてください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">modname</span>
<span class="n">reload</span><span class="p">(</span><span class="n">modname</span><span class="p">)</span>
</pre></div>
</div>
<p>注意:この手法は 100%安全とは言えません。とりわけ</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">modname</span> <span class="k">import</span> <span class="n">some_objects</span>
</pre></div>
</div>
<p>のような文を含むモジュールは、インポートされたオブジェクトの古いバージョンを使い続けます。そのモジュールにクラス定義が含まれていたら、存在するクラスインスタンスは新しいクラス定義を使うようにアップデート <em>されません</em>。これによって以下の矛盾した振舞いがなされえます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cls</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>                <span class="c1"># Create an instance of C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reload</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
<span class="go">&lt;module &#39;cls&#39; from &#39;cls.pyc&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">C</span><span class="p">)</span>       <span class="c1"># isinstance is false?!?</span>
<span class="go">False</span>
</pre></div>
</div>
<p>この問題の本質は、クラスオブジェクトを印字することで明らかになります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class cls.C at 0x7352a0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">cls</span><span class="o">.</span><span class="n">C</span>
<span class="go">&lt;class cls.C at 0x4198d0&gt;</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">プログラミング FAQ</a><ul>
<li><a class="reference internal" href="#general-questions">一般的な質問</a></li>
<li><a class="reference internal" href="#core-language">コア言語</a></li>
<li><a class="reference internal" href="#numbers-and-strings">数と文字列</a></li>
<li><a class="reference internal" href="#sequences-tuples-lists">シーケンス(タプル/リスト)</a></li>
<li><a class="reference internal" href="#dictionaries">辞書</a></li>
<li><a class="reference internal" href="#objects">オブジェクト</a></li>
<li><a class="reference internal" href="#modules">モジュール</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="general.html"
                        title="前の章へ">一般 Python FAQ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="design.html"
                        title="次の章へ">デザインと歴史 FAQ</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">バグ報告</a></li>
  <li><a href="https://github.com/python/cpython/blob/2.7/Doc/faq/programming.rst"
         rel="nofollow">ソースの表示</a>
  </li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="general.html" title="一般 Python FAQ"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.13</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python よくある質問</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト).
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 2017-09-22
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>