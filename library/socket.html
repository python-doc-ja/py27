
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>17.2. socket — 低レベルネットワークインターフェース &#8212; Python 2.7.14 ドキュメント</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.14',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7.14 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="17.3. ssl — ソケットオブジェクトに対する TLS/SSL ラッパー" href="ssl.html" />
    <link rel="prev" title="17.1. subprocess — サブプロセス管理" href="subprocess.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/socket.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="ssl.html" title="17.3. ssl — ソケットオブジェクトに対する TLS/SSL ラッパー"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="subprocess.html" title="17.1. subprocess — サブプロセス管理"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.14</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" accesskey="U">17. プロセス間通信とネットワーク</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-socket">
<span id="socket-low-level-networking-interface"></span><h1>17.2. <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> — 低レベルネットワークインターフェース<a class="headerlink" href="#module-socket" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>このモジュールは、PythonでBSD <em>ソケット(socket)</em> インターフェースを利用するために使用します。最近のUnixシステム、Windows, Max OS X, BeOS, OS/2など、多くのプラットフォームで利用可能です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">いくつかの振る舞いはプラットフォームに依存します。オペレーティングシステムのソケットAPIを呼び出しているためです。</p>
</div>
<p>C言語によるソケットプログラミングの基礎については、以下の資料を参照してください。 An Introductory 4.3BSD Interprocess Communication Tutorial (Stuart Sechrest), An Advanced 4.3BSD Interprocess Communication Tutorial (Samuel J. Leffler他), UNIX Programmer’s Manual, Supplementary Documents 1(PS1:7章 PS1:8章)。ソケットの詳細については、各プラットフォームのソケット関連システムコールに関するドキュメント(Unix ではマニュアルページ、WindowsではWinSock(またはWinSock2)仕様書)も参照してください。 IPv6対応のAPIについては、 <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3493.html"><strong>RFC 3493</strong></a> &quot;Basic Socket Interface Extensions for IPv6&quot; を参照してください。</p>
<p id="index-1">Pythonインターフェースは、Unixのソケット用システムコールとライブラリを、そのままPythonのオブジェクト指向スタイルに変換したものです。各種ソケット関連のシステムコールは、 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> 関数で生成する <em class="dfn">socket オブジェクト</em> のメソッドとして実装されています。 メソッドのパラメータはCのインターフェースよりも多少高水準で、例えば <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code> や <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> メソッドではファイルオブジェクトと同様、 受信時のバッファ確保や送信時の出力サイズなどは自動的に処理されます。</p>
<p id="host-port">ソケットのアドレスは以下のように指定します:単一の文字列は、 <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">AF_UNIX</span></code></a> アドレスファミリを示します。 <code class="docutils literal"><span class="pre">(host,</span> <span class="pre">port)</span></code> のペアは <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a> アドレスファミリを示し、 <em>host</em> は <code class="docutils literal"><span class="pre">'daring.cwi.nl'</span></code> のようなインターネットドメイン形式または <code class="docutils literal"><span class="pre">'100.50.200.5'</span></code> のようなIPv4アドレスを文字列で、 <em>port</em> はポート番号を整数で指定します。 <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal"><span class="pre">AF_INET6</span></code></a> アドレスファミリは <code class="docutils literal"><span class="pre">(host,</span> <span class="pre">port,</span> <span class="pre">flowinfo,</span> <span class="pre">scopeid)</span></code> の長さ4のタプルで示し、 <em>flowinfo</em> と <em>scopeid</em> にはそれぞれCの <code class="xref py py-const docutils literal"><span class="pre">struct</span> <span class="pre">sockaddr_in6</span></code> における <code class="docutils literal"><span class="pre">sin6_flowinfo</span></code> と <code class="docutils literal"><span class="pre">sin6_scope_id</span></code> の値を指定します。後方互換性のため、 <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> モジュールのメソッドでは <code class="docutils literal"><span class="pre">sin6_flowinfo</span></code> と <code class="docutils literal"><span class="pre">sin6_scope_id</span></code> を省略する事ができますが、 <em>scopeid</em> を省略するとスコープを持ったIPv6アドレスの処理で問題が発生する場合があります。現在サポートされているアドレスファミリは以上です。ソケットオブジェクトで利用する事のできるアドレス形式は、ソケットオブジェクトの作成時に指定したアドレスファミリで決まります。</p>
<p>IPv4アドレスのホストアドレスが空文字列の場合、 <code class="xref py py-const docutils literal"><span class="pre">INADDR_ANY</span></code> として処理されます。また、 <code class="docutils literal"><span class="pre">'&lt;broadcast&gt;'</span></code> の場合は <code class="xref py py-const docutils literal"><span class="pre">INADDR_BROADCAST</span></code> として処理されます。 IPv6では後方互換性のためこの機能は用意されていませんので、IPv6をサポートするPythonプログラムでは利用しないで下さい。</p>
<p>IPv4/v6ソケットの <em>host</em> 部にホスト名を指定すると、処理結果が一定ではない場合があります。これはPythonはDNSから取得したアドレスのうち最初のアドレスを使用するので、 DNSの処理やホストの設定によって異なるIPv4/6アドレスを取得する場合があるためです。常に同じ結果が必要であれば、 <em>host</em> に数値のアドレスを指定してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加: </span>AF_NETLINK ソケットが <code class="docutils literal"><span class="pre">pid,</span> <span class="pre">groups</span></code> のペアで表現されます.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加: </span>Linuxのみ、 <code class="xref py py-const docutils literal"><span class="pre">AF_TIPC</span></code> アドレスファミリを使って TIPC を利用することができます。 TIPCはオープンで、IPベースではないクラスターコンピューター環境向けのネットワークプロトコルです。アドレスはタプルで表現され、その中身はアドレスタイプに依存します。一般的なタプルの形は <code class="docutils literal"><span class="pre">(addr_type,</span> <span class="pre">v1,</span> <span class="pre">v2,</span> <span class="pre">v3</span> <span class="pre">[,</span> <span class="pre">scope])</span></code> で、</p>
<ul>
<li><p class="first"><em>addr_type</em> は <code class="xref py py-const docutils literal"><span class="pre">TIPC_ADDR_NAMESEQ</span></code>, <code class="xref py py-const docutils literal"><span class="pre">TIPC_ADDR_NAME</span></code>, <code class="xref py py-const docutils literal"><span class="pre">TIPC_ADDR_ID</span></code> の1つ。</p>
</li>
<li><p class="first"><em>scope</em> は <code class="xref py py-const docutils literal"><span class="pre">TIPC_ZONE_SCOPE</span></code>, <code class="xref py py-const docutils literal"><span class="pre">TIPC_CLUSTER_SCOPE</span></code>, <code class="xref py py-const docutils literal"><span class="pre">TIPC_NODE_SCOPE</span></code> の1つ。</p>
</li>
<li><p class="first"><em>addr_type</em> が <code class="xref py py-const docutils literal"><span class="pre">TIPC_ADDR_NAME</span></code> の場合、 <em>v1</em> はサーバータイプ、 <em>v2</em> はポートID (the port identifier)、そして <em>v3</em> は 0 であるべきです。</p>
<p><em>addr_type</em> が <code class="xref py py-const docutils literal"><span class="pre">TIPC_ADDR_NAMESEQ</span></code> の場合、 <em>v1</em> はサーバータイプ、 <em>v2</em> はポート番号下位(lower port number)、 <em>v3</em> はポート番号上位(upper port number) です。</p>
<p><em>addr_type</em> が <code class="xref py py-const docutils literal"><span class="pre">TIPC_ADDR_ID</span></code> の場合、 <em>v1</em> はノード、 <em>v2</em> は参照、 <em>v3</em> は0であるべきです。</p>
</li>
</ul>
</div>
<p>エラー時には例外が発生します。引数型のエラーやメモリ不足の場合には通常の例外が発生し、ソケットやアドレス関連のエラーの場合は <a class="reference internal" href="#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">socket.error</span></code></a> が発生します。</p>
<p><a class="reference internal" href="#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal"><span class="pre">setblocking()</span></code></a> メソッドで、非ブロッキングモードを使用することができます。また、より汎用的に <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></code></a> メソッドでタイムアウトを指定する事ができます。</p>
<p><a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> モジュールでは、以下の定数と関数を提供しています:</p>
<dl class="exception">
<dt id="socket.error">
<em class="property">exception </em><code class="descclassname">socket.</code><code class="descname">error</code><a class="headerlink" href="#socket.error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-2">この例外は、ソケット関連のエラーが発生した場合に送出されます。例外の値は障害の内容を示す文字列か、または <a class="reference internal" href="os.html#os.error" title="os.error"><code class="xref py py-exc docutils literal"><span class="pre">os.error</span></code></a> と同様な <code class="docutils literal"><span class="pre">(errno,</span> <span class="pre">string)</span></code> のペアとなります。オペレーティングシステムで定義されているエラーコードについては <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-mod docutils literal"><span class="pre">errno</span></code></a> を参照してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span><a class="reference internal" href="#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">socket.error</span></code></a> は <a class="reference internal" href="exceptions.html#exceptions.IOError" title="exceptions.IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a> の子クラスになりました。</p>
</div>
</dd></dl>

<dl class="exception">
<dt id="socket.herror">
<em class="property">exception </em><code class="descclassname">socket.</code><code class="descname">herror</code><a class="headerlink" href="#socket.herror" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この例外は、C APIの <a class="reference internal" href="#socket.gethostbyname_ex" title="socket.gethostbyname_ex"><code class="xref py py-func docutils literal"><span class="pre">gethostbyname_ex()</span></code></a> や <a class="reference internal" href="#socket.gethostbyaddr" title="socket.gethostbyaddr"><code class="xref py py-func docutils literal"><span class="pre">gethostbyaddr()</span></code></a> などで、 <em>h_errno</em> のようなアドレス関連のエラーが発生した場合に送出されます。</p>
<p>例外の値は <code class="docutils literal"><span class="pre">(h_errno,</span> <span class="pre">string)</span></code> のペアで、ライブラリの呼び出し結果を返します。 <em>string</em> はC関数 <code class="xref c c-func docutils literal"><span class="pre">hstrerror()</span></code> で取得した、 <em>h_errno</em> の意味を示す文字列です。</p>
</dd></dl>

<dl class="exception">
<dt id="socket.gaierror">
<em class="property">exception </em><code class="descclassname">socket.</code><code class="descname">gaierror</code><a class="headerlink" href="#socket.gaierror" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この例外は <a class="reference internal" href="#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-func docutils literal"><span class="pre">getaddrinfo()</span></code></a> と <a class="reference internal" href="#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-func docutils literal"><span class="pre">getnameinfo()</span></code></a> でアドレス関連のエラーが発生した場合に送出されます。例外の値は <code class="docutils literal"><span class="pre">(error,</span> <span class="pre">string)</span></code> のペアで、ライブラリの呼び出し結果を返します。 <em>string</em> はC関数 <code class="xref c c-func docutils literal"><span class="pre">gai_strerror()</span></code> で取得した、 <em>h_errno</em> の意味を示す文字列です。 <em>error</em> の値は、このモジュールで定義される <code class="xref py py-const docutils literal"><span class="pre">EAI_*</span></code> 定数の何れかとなります。</p>
</dd></dl>

<dl class="exception">
<dt id="socket.timeout">
<em class="property">exception </em><code class="descclassname">socket.</code><code class="descname">timeout</code><a class="headerlink" href="#socket.timeout" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この例外は、あらかじめ <code class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></code> を呼び出してタイムアウトを有効にしてあるソケットでタイムアウトが生じた際に送出されます。例外に付属する値は文字列で、その内容は現状では常に &quot;timed out&quot; となります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="socket.AF_UNIX">
<code class="descclassname">socket.</code><code class="descname">AF_UNIX</code><a class="headerlink" href="#socket.AF_UNIX" title="この定義へのパーマリンク">¶</a></dt>
<dt id="socket.AF_INET">
<code class="descclassname">socket.</code><code class="descname">AF_INET</code><a class="headerlink" href="#socket.AF_INET" title="この定義へのパーマリンク">¶</a></dt>
<dt id="socket.AF_INET6">
<code class="descclassname">socket.</code><code class="descname">AF_INET6</code><a class="headerlink" href="#socket.AF_INET6" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アドレス (およびプロトコル) ファミリーを示す定数で、 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> の 最初の引数に指定することができます。 <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">AF_UNIX</span></code></a> ファミリーをサポート しないプラットフォームでは、 <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">AF_UNIX</span></code></a> は未定義となります。</p>
</dd></dl>

<dl class="data">
<dt id="socket.SOCK_STREAM">
<code class="descclassname">socket.</code><code class="descname">SOCK_STREAM</code><a class="headerlink" href="#socket.SOCK_STREAM" title="この定義へのパーマリンク">¶</a></dt>
<dt id="socket.SOCK_DGRAM">
<code class="descclassname">socket.</code><code class="descname">SOCK_DGRAM</code><a class="headerlink" href="#socket.SOCK_DGRAM" title="この定義へのパーマリンク">¶</a></dt>
<dt id="socket.SOCK_RAW">
<code class="descclassname">socket.</code><code class="descname">SOCK_RAW</code><a class="headerlink" href="#socket.SOCK_RAW" title="この定義へのパーマリンク">¶</a></dt>
<dt id="socket.SOCK_RDM">
<code class="descclassname">socket.</code><code class="descname">SOCK_RDM</code><a class="headerlink" href="#socket.SOCK_RDM" title="この定義へのパーマリンク">¶</a></dt>
<dt id="socket.SOCK_SEQPACKET">
<code class="descclassname">socket.</code><code class="descname">SOCK_SEQPACKET</code><a class="headerlink" href="#socket.SOCK_SEQPACKET" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットタイプを示す定数で、 <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> の2番目の引数に指定することができます。(ほとんどの場合、 <a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">SOCK_STREAM</span></code></a> と <a class="reference internal" href="#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal"><span class="pre">SOCK_DGRAM</span></code></a> 以外は必要ありません。)</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descname">SO_*</code></dt>
<dt id="socket.SOMAXCONN">
<code class="descclassname">socket.</code><code class="descname">SOMAXCONN</code><a class="headerlink" href="#socket.SOMAXCONN" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">MSG_*</code></dt>
<dt>
<code class="descname">SOL_*</code></dt>
<dt>
<code class="descname">IPPROTO_*</code></dt>
<dt>
<code class="descname">IPPORT_*</code></dt>
<dt>
<code class="descname">INADDR_*</code></dt>
<dt>
<code class="descname">IP_*</code></dt>
<dt>
<code class="descname">IPV6_*</code></dt>
<dt>
<code class="descname">EAI_*</code></dt>
<dt>
<code class="descname">AI_*</code></dt>
<dt>
<code class="descname">NI_*</code></dt>
<dt>
<code class="descname">TCP_*</code></dt>
<dd><p>Unixのソケット・IPプロトコルのドキュメントで定義されている各種定数。ソケットオブジェクトの <code class="xref py py-meth docutils literal"><span class="pre">setsockopt()</span></code> や <code class="xref py py-meth docutils literal"><span class="pre">getsockopt()</span></code> で使用します。ほとんどのシンボルはUnixのヘッダファイルに従っています。一部のシンボルには、デフォルト値を定義してあります。</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descname">SIO_*</code></dt>
<dt>
<code class="descname">RCVALL_*</code></dt>
<dd><p>Windows の WSAIoctl() のための定数です。この定数はソケットオブジェクトの <a class="reference internal" href="#socket.socket.ioctl" title="socket.socket.ioctl"><code class="xref py py-meth docutils literal"><span class="pre">ioctl()</span></code></a> メソッドに引数として渡されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt>
<code class="descname">TIPC_*</code></dt>
<dd><p>TIPC 関連の定数で、C のソケットAPIが公開しているものにマッチします。詳しい情報は TIPC のドキュメントを参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="socket.has_ipv6">
<code class="descclassname">socket.</code><code class="descname">has_ipv6</code><a class="headerlink" href="#socket.has_ipv6" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のプラットフォームでIPv6がサポートされているか否かを示す真偽値。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.create_connection">
<code class="descclassname">socket.</code><code class="descname">create_connection</code><span class="sig-paren">(</span><em>address</em><span class="optional">[</span>, <em>timeout</em><span class="optional">[</span>, <em>source_address</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.create_connection" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>address</em> (<code class="docutils literal"><span class="pre">(host,</span> <span class="pre">port)</span></code> ペア) で listen しているTCPサービスに接続し、ソケットオブジェクトを返します。これは <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre">socket.connect()</span></code></a> を高級にした関数です。 <em>host</em> が数値でないホスト名の場合、 <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal"><span class="pre">AF_INET</span></code></a> と <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal"><span class="pre">AF_INET6</span></code></a> の両方で名前解決を試み、得られた全てのアドレスに対して成功するまで接続を試みます。この関数を使って IPv4 と IPv6 に両対応したクライアントを簡単に書くことができます。</p>
<p>オプションの <em>timeout</em> 引数を指定すると、接続を試みる前にソケットオブジェクトのタイムアウトを設定します。 <em>timeout</em> が指定されない場合、 <a class="reference internal" href="#socket.getdefaulttimeout" title="socket.getdefaulttimeout"><code class="xref py py-func docutils literal"><span class="pre">getdefaulttimeout()</span></code></a> が返すデフォルトのタイムアウト設定値を利用します。</p>
<p><em>source_address</em> は接続する前にバインドするソースアドレスを指定するオプション引数で、指定する場合は <code class="docutils literal"><span class="pre">(host,</span> <span class="pre">port)</span></code> の2要素タプルでなければなりません。 host や port が '' か 0 だった場合は、OSのデフォルトの動作になります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span><em>source_address</em> が追加されました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.getaddrinfo">
<code class="descclassname">socket.</code><code class="descname">getaddrinfo</code><span class="sig-paren">(</span><em>host</em>, <em>port</em><span class="optional">[</span>, <em>family</em><span class="optional">[</span>, <em>socktype</em><span class="optional">[</span>, <em>proto</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.getaddrinfo" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>host</em> / <em>port</em> 引数の指すアドレス情報を、そのサービスに接続されたソケットを作成するために必要な全ての引数が入った 5 要素のタプルに変換します。 <em>host</em> はドメイン名、IPv4/v6アドレスの文字列、または <code class="docutils literal"><span class="pre">None</span></code> です。 <em>port</em> は <code class="docutils literal"><span class="pre">'http'</span></code> のようなサービス名文字列、ポート番号を表す数値、または <code class="docutils literal"><span class="pre">None</span></code> です。 <em>host</em> と <em>port</em> に <code class="docutils literal"><span class="pre">None</span></code> を指定すると C APIに <code class="docutils literal"><span class="pre">NULL</span></code> を渡せます。</p>
<p>オプションの <em>family</em> 、 <em>socktype</em> 、 <em>proto</em> 引数を指定すると、返されるアドレスのリストを絞り込むことができます。デフォルトではこれらの値は <code class="docutils literal"><span class="pre">0</span></code> で、絞り込まずに全て取得することを意味します。 <em>flags</em> 引数には <code class="docutils literal"><span class="pre">AI_*</span></code> 定数のうち 1 つ以上が指定でき、結果の取り方を変えることができます。デフォルトではこれは <code class="docutils literal"><span class="pre">0</span></code> です。例えば、 <code class="xref py py-const docutils literal"><span class="pre">AI_NUMERICHOST</span></code> を指定するとドメイン名解決を行わないようにし、 <em>host</em> がドメイン名だった場合には例外を送出します。</p>
<p>この関数は以下の構造をとる 5 要素のタプルのリストを返します:</p>
<p><code class="docutils literal"><span class="pre">(family,</span> <span class="pre">socktype,</span> <span class="pre">proto,</span> <span class="pre">canonname,</span> <span class="pre">sockaddr)</span></code></p>
<p>このタプルにある <em>family</em>, <em>socktype</em>, <em>proto</em> は、 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> 関数を呼び出す際に指定する値と同じ整数です。 <code class="xref py py-const docutils literal"><span class="pre">AI_CANONNAME</span></code> を含んだ <em>flags</em> を指定した場合、 <em>canonname</em> は <em>host</em> の canonical name を示す文字列です。そうでない場合は <em>canonname</em> は空文字列です。 <em>sockaddr</em> は、ソケットアドレスを <em>family</em> に依存した形式で表すタプルで、 (<a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a> の場合は 2 要素のタプル <code class="docutils literal"><span class="pre">(address,</span> <span class="pre">port)</span></code> 、 <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal"><span class="pre">AF_INET6</span></code></a> の場合は 4 要素のタプル <code class="docutils literal"><span class="pre">(address,</span> <span class="pre">port,</span> <span class="pre">flow</span> <span class="pre">info,</span> <span class="pre">scope</span> <span class="pre">id)</span></code>) <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre">socket.connect()</span></code></a> メソッドに渡すためのものです。</p>
<p>次の例では <code class="docutils literal"><span class="pre">example.org</span></code> の 80 番ポートポートへの TCP 接続を得るためのアドレス情報を取得しようとしています。 (結果は IPv6 をサポートしているかどうかで変わります):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="s2">&quot;example.org&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_TCP</span><span class="p">)</span>
<span class="go">[(10, 1, 6, &#39;&#39;, (&#39;2606:2800:220:1:248:1893:25c8:1946&#39;, 80, 0, 0)),</span>
<span class="go"> (2, 1, 6, &#39;&#39;, (&#39;93.184.216.34&#39;, 80))]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.getfqdn">
<code class="descclassname">socket.</code><code class="descname">getfqdn</code><span class="sig-paren">(</span><span class="optional">[</span><em>name</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.getfqdn" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>name</em> の完全修飾ドメイン名を返します。 <em>name</em> が空または省略された場合、ローカルホストを指定したとみなします。完全修飾ドメイン名の取得にはまず <a class="reference internal" href="#socket.gethostbyaddr" title="socket.gethostbyaddr"><code class="xref py py-func docutils literal"><span class="pre">gethostbyaddr()</span></code></a> でチェックし、次に可能であればエイリアスを調べ、名前にピリオドを含む最初の名前を値として返します。完全修飾ドメイン名を取得できない場合、 <a class="reference internal" href="#socket.gethostname" title="socket.gethostname"><code class="xref py py-func docutils literal"><span class="pre">gethostname()</span></code></a> で返されるホスト名を返します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.0 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.gethostbyname">
<code class="descclassname">socket.</code><code class="descname">gethostbyname</code><span class="sig-paren">(</span><em>hostname</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.gethostbyname" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ホスト名を <code class="docutils literal"><span class="pre">'100.50.200.5'</span></code> のようなIPv4形式のアドレスに変換します。ホスト名としてIPv4アドレスを指定した場合、その値は変換せずにそのまま返ります。 <a class="reference internal" href="#socket.gethostbyname" title="socket.gethostbyname"><code class="xref py py-func docutils literal"><span class="pre">gethostbyname()</span></code></a> APIへのより完全なインターフェースが必要であれば、 <a class="reference internal" href="#socket.gethostbyname_ex" title="socket.gethostbyname_ex"><code class="xref py py-func docutils literal"><span class="pre">gethostbyname_ex()</span></code></a> を参照してください。 <a class="reference internal" href="#socket.gethostbyname" title="socket.gethostbyname"><code class="xref py py-func docutils literal"><span class="pre">gethostbyname()</span></code></a> は、IPv6名前解決をサポートしていません。IPv4/ v6のデュアルスタックをサポートする場合は <a class="reference internal" href="#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-func docutils literal"><span class="pre">getaddrinfo()</span></code></a> を使用します。</p>
</dd></dl>

<dl class="function">
<dt id="socket.gethostbyname_ex">
<code class="descclassname">socket.</code><code class="descname">gethostbyname_ex</code><span class="sig-paren">(</span><em>hostname</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.gethostbyname_ex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ホスト名から、IPv4形式の各種アドレス情報を取得します。戻り値は <code class="docutils literal"><span class="pre">(hostname,</span> <span class="pre">aliaslist,</span> <span class="pre">ipaddrlist)</span></code> のタプルで、 <em>hostname</em> は <em>ip_address</em> で指定したホストの正式名、 <em>aliaslist</em> は同じアドレスの別名のリスト(空の場合もある)、 <em>ipaddrlist</em> は同じホスト上の同一インターフェースのIPv4アドレスのリスト(ほとんどの場合は単一のアドレスのみ) を示します。 <a class="reference internal" href="#socket.gethostbyname_ex" title="socket.gethostbyname_ex"><code class="xref py py-func docutils literal"><span class="pre">gethostbyname_ex()</span></code></a> は、IPv6名前解決をサポートしていません。IPv4/v6のデュアルスタックをサポートする場合は <a class="reference internal" href="#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-func docutils literal"><span class="pre">getaddrinfo()</span></code></a> を使用します。</p>
</dd></dl>

<dl class="function">
<dt id="socket.gethostname">
<code class="descclassname">socket.</code><code class="descname">gethostname</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.gethostname" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Pythonインタープリタを現在実行中のマシンのホスト名を示す文字列を取得します。</p>
<p>実行中マシンのIPアドレスが必要であれば、 <code class="docutils literal"><span class="pre">gethostbyname(gethostname())</span></code> を使用してください。この処理は実行中ホストのアドレス-ホスト名変換が可能であることを前提としていますが、常に変換可能であるとは限りません。</p>
<p>注意: <a class="reference internal" href="#socket.gethostname" title="socket.gethostname"><code class="xref py py-func docutils literal"><span class="pre">gethostname()</span></code></a> は完全修飾ドメイン名を返すとは限りません。完全修飾ドメイン名が必要であれば、 <code class="docutils literal"><span class="pre">gethostbyaddr(gethostname())</span></code> としてください(下記参照)。</p>
</dd></dl>

<dl class="function">
<dt id="socket.gethostbyaddr">
<code class="descclassname">socket.</code><code class="descname">gethostbyaddr</code><span class="sig-paren">(</span><em>ip_address</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.gethostbyaddr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">(hostname,</span> <span class="pre">aliaslist,</span> <span class="pre">ipaddrlist)</span></code> のタプルを返し、 <em>hostname</em> は <em>ip_address</em> で指定したホストの正式名、 <em>aliaslist</em> は同じアドレスの別名のリスト(空の場合もある)、 <em>ipaddrlist</em> は同じホスト上の同一インターフェースのIPv4アドレスのリスト(ほとんどの場合は単一のアドレスのみ)を示します。完全修飾ドメイン名が必要であれば、 <a class="reference internal" href="#socket.getfqdn" title="socket.getfqdn"><code class="xref py py-func docutils literal"><span class="pre">getfqdn()</span></code></a> を使用してください。 <a class="reference internal" href="#socket.gethostbyaddr" title="socket.gethostbyaddr"><code class="xref py py-func docutils literal"><span class="pre">gethostbyaddr()</span></code></a> は、IPv4/IPv6の両方をサポートしています。</p>
</dd></dl>

<dl class="function">
<dt id="socket.getnameinfo">
<code class="descclassname">socket.</code><code class="descname">getnameinfo</code><span class="sig-paren">(</span><em>sockaddr</em>, <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.getnameinfo" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットアドレス <em>sockaddr</em> から、 <code class="docutils literal"><span class="pre">(host,</span> <span class="pre">port)</span></code> のタプルを取得します。 <em>flags</em> の設定に従い、 <em>host</em> は完全修飾ドメイン名または数値形式アドレスとなります。同様に、 <em>port</em> は文字列のポート名または数値のポート番号となります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.getprotobyname">
<code class="descclassname">socket.</code><code class="descname">getprotobyname</code><span class="sig-paren">(</span><em>protocolname</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.getprotobyname" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>(<code class="docutils literal"><span class="pre">'icmp'</span></code> のような) インターネットプロトコル名を、 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> の 第三引数として指定する事ができる定数に変換します。これは主にソケットを &quot;raw&quot; モード(<a class="reference internal" href="#socket.SOCK_RAW" title="socket.SOCK_RAW"><code class="xref py py-const docutils literal"><span class="pre">SOCK_RAW</span></code></a>)でオープンする場合には必要ですが、通常の ソケットモードでは第三引数に0を指定するか省略すれば正しいプロトコルが自動的に選択されます。</p>
</dd></dl>

<dl class="function">
<dt id="socket.getservbyname">
<code class="descclassname">socket.</code><code class="descname">getservbyname</code><span class="sig-paren">(</span><em>servicename</em><span class="optional">[</span>, <em>protocolname</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.getservbyname" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インターネットサービス名とプロトコルから、そのサービスのポート番号を取得します。省略可能なプロトコル名として、 <code class="docutils literal"><span class="pre">'tcp'</span></code> か <code class="docutils literal"><span class="pre">'udp'</span></code> のどちらかを指定することができます。指定がなければどちらのプロトコルにもマッチします。</p>
</dd></dl>

<dl class="function">
<dt id="socket.getservbyport">
<code class="descclassname">socket.</code><code class="descname">getservbyport</code><span class="sig-paren">(</span><em>port</em><span class="optional">[</span>, <em>protocolname</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.getservbyport" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インターネットポート番号とプロトコル名から、サービス名を取得します。省略可能なプロトコル名として、 <code class="docutils literal"><span class="pre">'tcp'</span></code> か <code class="docutils literal"><span class="pre">'udp'</span></code> のどちらかを指定することができます。指定がなければどちらのプロトコルにもマッチします。</p>
</dd></dl>

<dl class="function">
<dt id="socket.socket">
<code class="descclassname">socket.</code><code class="descname">socket</code><span class="sig-paren">(</span><span class="optional">[</span><em>family</em><span class="optional">[</span>, <em>type</em><span class="optional">[</span>, <em>proto</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アドレスファミリ、ソケットタイプ、プロトコル番号を指定してソケットを作成します。アドレスファミリには <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a> (デフォルト値)・ <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal"><span class="pre">AF_INET6</span></code></a> ・ <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">AF_UNIX</span></code></a> を指定することができます。ソケットタイプには <a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">SOCK_STREAM</span></code></a> (デフォルト値)・ <a class="reference internal" href="#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal"><span class="pre">SOCK_DGRAM</span></code></a> ・または他の <code class="docutils literal"><span class="pre">SOCK_</span></code> 定数の何れかを指定します。プロトコル番号は通常省略するか、または0を指定します。</p>
</dd></dl>

<dl class="function">
<dt id="socket.socketpair">
<code class="descclassname">socket.</code><code class="descname">socketpair</code><span class="sig-paren">(</span><span class="optional">[</span><em>family</em><span class="optional">[</span>, <em>type</em><span class="optional">[</span>, <em>proto</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socketpair" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたアドレスファミリー、ソケットタイプ、プロトコル番号から、接続されたソケットのペアを作成します。アドレスファミリー、ソケットタイプ、プロトコル番号は <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> 関数と同様に指定します。デフォルトのアドレスファミリは、プラットフォームで定義されていれば <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">AF_UNIX</span></code></a>, そうでなければ <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a> が使われます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.fromfd">
<code class="descclassname">socket.</code><code class="descname">fromfd</code><span class="sig-paren">(</span><em>fd</em>, <em>family</em>, <em>type</em><span class="optional">[</span>, <em>proto</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.fromfd" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイル記述子 (ファイルオブジェクトの <code class="xref py py-meth docutils literal"><span class="pre">fileno()</span></code> メソッドが返す整数) <em>fd</em> を複製して、ソケットオブジェクトを構築します。アドレスファミリとプロトコル番号は <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> と同様に指定します。ファイル記述子 はソケットを指していなければなりませんが、実際にソケットであるかどうかのチェックは行っていません。このため、ソケット以外のファイル記述子 を指定するとその後の処理が失敗する場合があります。この関数が必要な事はあまりありませんが、 (Unixのinetデーモンに起動されるプログラムのように) ソケットを標準入力や標準出力として使用するプログラムでソケットオプションの取得や設定を行うために使われます。この関数で使用するソケットは、ブロッキングモードと想定しています。 利用可能: Unix</p>
</dd></dl>

<dl class="function">
<dt id="socket.ntohl">
<code class="descclassname">socket.</code><code class="descname">ntohl</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.ntohl" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>32ビットの正の整数のバイトオーダを、ネットワークバイトオーダからホストバイトオーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致するマシンでは、この関数は何もしません。それ以外の場合は4バイトのスワップを行います。</p>
</dd></dl>

<dl class="function">
<dt id="socket.ntohs">
<code class="descclassname">socket.</code><code class="descname">ntohs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.ntohs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>16ビットの正の整数のバイトオーダを、ネットワークバイトオーダからホストバイトオーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致するマシンでは、この関数は何もしません。それ以外の場合は2バイトのスワップを行います。</p>
</dd></dl>

<dl class="function">
<dt id="socket.htonl">
<code class="descclassname">socket.</code><code class="descname">htonl</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.htonl" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>32ビットの正の整数のバイトオーダを、ホストバイトオーダからネットワークバイトオーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致するマシンでは、この関数は何もしません。それ以外の場合は4バイトのスワップを行います。</p>
</dd></dl>

<dl class="function">
<dt id="socket.htons">
<code class="descclassname">socket.</code><code class="descname">htons</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.htons" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>16ビットの正の整数のバイトオーダを、ホストバイトオーダからネットワークバイトオーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致するマシンでは、この関数は何もしません。それ以外の場合は2バイトのスワップを行います。</p>
</dd></dl>

<dl class="function">
<dt id="socket.inet_aton">
<code class="descclassname">socket.</code><code class="descname">inet_aton</code><span class="sig-paren">(</span><em>ip_string</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.inet_aton" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ドット記法によるIPv4アドレス(<code class="docutils literal"><span class="pre">'123.45.67.89'</span></code> など)を32ビットにパックしたバイナリ形式に変換し、長さ4の文字列オブジェクトとして返します。この関数が返す値は、標準Cライブラリの <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">in_addr</span></code> 型を使用する関数に渡す事ができます。</p>
<p><a class="reference internal" href="#socket.inet_aton" title="socket.inet_aton"><code class="xref py py-func docutils literal"><span class="pre">inet_aton()</span></code></a> はドットが 3 個以下の文字列も受け取ります; 詳細については Unix のマニュアル <em class="manpage">inet(3)</em> を参照してください。</p>
<p>IPv4アドレス文字列が不正であれば、 <a class="reference internal" href="#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">socket.error</span></code></a> が発生します。このチェックは、この関数で使用しているCの実装 <code class="xref c c-func docutils literal"><span class="pre">inet_aton()</span></code> で行われます。</p>
<p><a class="reference internal" href="#socket.inet_aton" title="socket.inet_aton"><code class="xref py py-func docutils literal"><span class="pre">inet_aton()</span></code></a> は、IPv6をサポートしません。IPv4/v6のデュアルスタックをサポートする場合は <a class="reference internal" href="#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal"><span class="pre">inet_pton()</span></code></a> を使用します。</p>
</dd></dl>

<dl class="function">
<dt id="socket.inet_ntoa">
<code class="descclassname">socket.</code><code class="descname">inet_ntoa</code><span class="sig-paren">(</span><em>packed_ip</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.inet_ntoa" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>32ビットにパックしたバイナリ形式のIPv4アドレスを、ドット記法による文字列 (<code class="docutils literal"><span class="pre">'123.45.67.89'</span></code> など)に変換します。この関数が返す値は、標準Cライブラリの <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">in_addr</span></code> 型を使用する関数に渡す事ができます。</p>
<p>この関数に渡す文字列の長さが4バイト以外であれば、 <a class="reference internal" href="#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">socket.error</span></code></a> が発生します。 <a class="reference internal" href="#socket.inet_ntoa" title="socket.inet_ntoa"><code class="xref py py-func docutils literal"><span class="pre">inet_ntoa()</span></code></a> は、IPv6をサポートしません。IPv4/v6のデュアルスタックをサポートする場合は <a class="reference internal" href="#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal"><span class="pre">inet_pton()</span></code></a> を使用します。</p>
</dd></dl>

<dl class="function">
<dt id="socket.inet_pton">
<code class="descclassname">socket.</code><code class="descname">inet_pton</code><span class="sig-paren">(</span><em>address_family</em>, <em>ip_string</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.inet_pton" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>IPアドレスを、アドレスファミリ固有の文字列からパックしたバイナリ形式に変換します。 <a class="reference internal" href="#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal"><span class="pre">inet_pton()</span></code></a> は、 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">in_addr</span></code> 型 (<a class="reference internal" href="#socket.inet_aton" title="socket.inet_aton"><code class="xref py py-func docutils literal"><span class="pre">inet_aton()</span></code></a> と同様)や <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">in6_addr</span></code> を使用するライブラリやネットワークプロトコルを呼び出す際に使用することができます。</p>
<p>現在サポートされている <em>address_family</em> は、 <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a> と <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal"><span class="pre">AF_INET6</span></code></a> です。 <em>ip_string</em> に不正なIPアドレス文字列を指定すると、 <a class="reference internal" href="#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">socket.error</span></code></a> が発生します。有効な <em>ip_string</em> は、 <em>address_family</em> と <code class="xref c c-func docutils literal"><span class="pre">inet_pton()</span></code> の実装によって異なります。</p>
<p>利用可能: Unix (サポートしていないプラットフォームもあります)。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.inet_ntop">
<code class="descclassname">socket.</code><code class="descname">inet_ntop</code><span class="sig-paren">(</span><em>address_family</em>, <em>packed_ip</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.inet_ntop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>パックしたIPアドレス(数文字の文字列オブジェクト)を、 <code class="docutils literal"><span class="pre">'7.10.0.5'</span></code> や <code class="docutils literal"><span class="pre">'5aef:2b::8'</span></code> などの標準的な、アドレスファミリ固有の文字列形式に変換します。 <a class="reference internal" href="#socket.inet_ntop" title="socket.inet_ntop"><code class="xref py py-func docutils literal"><span class="pre">inet_ntop()</span></code></a> は(<a class="reference internal" href="#socket.inet_ntoa" title="socket.inet_ntoa"><code class="xref py py-func docutils literal"><span class="pre">inet_ntoa()</span></code></a> と同様に) <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">in_addr</span></code> 型や <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">in6_addr</span></code> 型のオブジェクトを返すライブラリやネットワークプロトコル等で使用することができます。</p>
<p>現在サポートされている <em>address_family</em> は、 <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a> と <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal"><span class="pre">AF_INET6</span></code></a> です。 <em>packed_ip</em> の長さが指定したアドレスファミリで適切な長さでなければ、 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が発生します。 <a class="reference internal" href="#socket.inet_ntop" title="socket.inet_ntop"><code class="xref py py-func docutils literal"><span class="pre">inet_ntop()</span></code></a> でエラーとなると、 <a class="reference internal" href="#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">socket.error</span></code></a> が発生します。</p>
<p>利用可能: Unix (サポートしていないプラットフォームもあります)。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.getdefaulttimeout">
<code class="descclassname">socket.</code><code class="descname">getdefaulttimeout</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.getdefaulttimeout" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新規に生成されたソケットオブジェクトの、デフォルトのタイムアウト値を浮動小数点形式の秒数で返します。タイムアウトを使用しない場合には <code class="docutils literal"><span class="pre">None</span></code> を返します。最初に socket モジュールがインポートされた時の初期値は <code class="docutils literal"><span class="pre">None</span></code> です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.setdefaulttimeout">
<code class="descclassname">socket.</code><code class="descname">setdefaulttimeout</code><span class="sig-paren">(</span><em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.setdefaulttimeout" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新規に生成されたソケットオブジェクトの、デフォルトのタイムアウト値を浮動小数点形式の秒数で指定します。タイムアウトを使用しない場合には <code class="docutils literal"><span class="pre">None</span></code> を指定します。最初に socket モジュールがインポートされた時の初期値は <code class="docutils literal"><span class="pre">None</span></code> です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="socket.SocketType">
<code class="descclassname">socket.</code><code class="descname">SocketType</code><a class="headerlink" href="#socket.SocketType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットオブジェクトの型を示す型オブジェクト。 <code class="docutils literal"><span class="pre">type(socket(...))</span></code> と同じです。</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference internal" href="socketserver.html#module-SocketServer" title="SocketServer: A framework for network servers."><code class="xref py py-mod docutils literal"><span class="pre">SocketServer</span></code></a> モジュール</dt>
<dd>ネットワークサーバの開発を省力化するためのクラス群。</dd>
<dt>Module <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal"><span class="pre">ssl</span></code></a></dt>
<dd>ソケットオブジェクトに対する TLS/SSL ラッパー.</dd>
</dl>
</div>
<div class="section" id="socket-objects">
<span id="id1"></span><h2>17.2.1. socket オブジェクト<a class="headerlink" href="#socket-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ソケットオブジェクトは以下のメソッドを持ちます。 <code class="xref py py-meth docutils literal"><span class="pre">makefile()</span></code> 以外のメソッドは、Unixのソケット用システムコールに対応しています。</p>
<dl class="method">
<dt id="socket.socket.accept">
<code class="descclassname">socket.</code><code class="descname">accept</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.accept" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>接続を受け付けます。ソケットはアドレスにbind済みで、listen中である必要があります。戻り値は <code class="docutils literal"><span class="pre">(conn,</span> <span class="pre">address)</span></code> のペアで、 <em>conn</em> は接続を通じてデータの送受信を行うための <em>新しい</em> ソケットオブジェクト、 <em>address</em> は接続先でソケットにbindしているアドレスを示します。</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.bind">
<code class="descclassname">socket.</code><code class="descname">bind</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.bind" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットを <em>address</em> にbindします。bind済みのソケットを再バインドする事はできません。(<em>address</em> のフォーマットはアドレスファミリによって異なります – 前述。)</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">本来、このメソッドは単一のタプルのみを引数として受け付けますが、以前は <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a> アドレスを示す二つの値を指定する事ができました。これは本来の仕様ではなく、Python 2.0以降では使用することはできません。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.close">
<code class="descclassname">socket.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットをクローズします。以降、このソケットでは全ての操作が失敗します。リモート端点ではキューに溜まったデータがフラッシュされた後はそれ以上のデータを受信しません。ソケットはガベージコレクション時に自動的にクローズされます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> は接続に関連付けられたリソースを解放しますが、接続をすぐに切断するとは限りません。接続を即座に切断したい場合は、 <a class="reference internal" href="#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> の前に <a class="reference internal" href="#socket.socket.shutdown" title="socket.socket.shutdown"><code class="xref py py-meth docutils literal"><span class="pre">shutdown()</span></code></a> を呼び出してください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.connect">
<code class="descclassname">socket.</code><code class="descname">connect</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.connect" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>address</em> で示されるリモートソケットに接続します。(<em>address</em> のフォーマットはアドレスファミリによって異なります — 前述。)</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">本来、このメソッドは単一のタプルのみを引数として受け付けますが、以前は <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a> アドレスを示す二つの値を指定する事ができました。これは本来の仕様ではなく、Python 2.0以降では使用することはできません。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.connect_ex">
<code class="descclassname">socket.</code><code class="descname">connect_ex</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.connect_ex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">connect(address)</span></code> と同様ですが、C言語の <code class="xref c c-func docutils literal"><span class="pre">connect()</span></code> 関数の呼び出しでエラーが発生した場合には例外を送出せずにエラーを戻り値として返します。(これ以外の、&quot;host not found,&quot;等のエラーの場合には例外が発生します。)処理が正常に終了した場合には <code class="docutils literal"><span class="pre">0</span></code> を返し、エラー時には <code class="xref c c-data docutils literal"><span class="pre">errno</span></code> の値を返します。この関数は、非同期接続をサポートする場合などに使用することができます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">本来、このメソッドは単一のタプルのみを引数として受け付けますが、以前は <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a> アドレスを示す二つの値を指定する事ができました。これは本来の仕様ではなく、Python 2.0以降では使用することはできません。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.fileno">
<code class="descclassname">socket.</code><code class="descname">fileno</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.fileno" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットのファイル記述子を整数型で返します。ファイル記述子は、 <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select.select()</span></code></a> などで使用します。</p>
<p>Windowsではこのメソッドで返された小整数をファイル記述子を扱う箇所 (<a class="reference internal" href="os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">os.fdopen()</span></code></a> など) で利用できません。 Unix にはこの制限はありません。</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.getpeername">
<code class="descclassname">socket.</code><code class="descname">getpeername</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.getpeername" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットが接続しているリモートアドレスを返します。この関数は、リモート IPv4/v6ソケットのポート番号を調べる場合などに使用します。 <em>address</em> のフォーマットはアドレスファミリによって異なります(前述)。この関数をサポートしていないシステムも存在します。</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.getsockname">
<code class="descclassname">socket.</code><code class="descname">getsockname</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.getsockname" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケット自身のアドレスを返します。この関数は、IPv4/v6ソケットのポート番号を調べる場合などに使用します。(<em>address</em> のフォーマットはアドレスファミリによって異なります — 前述。)</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.getsockopt">
<code class="descclassname">socket.</code><code class="descname">getsockopt</code><span class="sig-paren">(</span><em>level</em>, <em>optname</em><span class="optional">[</span>, <em>buflen</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.getsockopt" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットに指定されたオプションを返します(Unixのマニュアルページ <em class="manpage">getsockopt(2)</em> を参照)。 <code class="xref py py-const docutils literal"><span class="pre">SO_*</span></code> 等のシンボルは、このモジュールで定義しています。 <em>buflen</em> を省略した場合、取得するオブションは整数とみなし、整数型の値を戻り値とします。 <em>buflen</em> を指定した場合、長さ <em>buflen</em> のバッファでオプションを受け取り、このバッファを文字列として返します。このバッファは、呼び出し元プログラムで <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret strings as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> モジュール等を利用して内容を読み取ることができます。</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.ioctl">
<code class="descclassname">socket.</code><code class="descname">ioctl</code><span class="sig-paren">(</span><em>control</em>, <em>option</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.ioctl" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">プラットフォーム:</th><td class="field-body">Windows</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#socket.socket.ioctl" title="socket.socket.ioctl"><code class="xref py py-meth docutils literal"><span class="pre">ioctl()</span></code></a> メソッドは WSAIoctl システムインタフェースへの制限されたインタフェースです。詳しい情報については、 <a class="reference external" href="https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx">Win32 documentation</a> を参照してください。</p>
<p>他のプラットフォームでは一般的な <a class="reference internal" href="fcntl.html#fcntl.fcntl" title="fcntl.fcntl"><code class="xref py py-func docutils literal"><span class="pre">fcntl.fcntl()</span></code></a> と <a class="reference internal" href="fcntl.html#fcntl.ioctl" title="fcntl.ioctl"><code class="xref py py-func docutils literal"><span class="pre">fcntl.ioctl()</span></code></a> が使われるでしょう; これらの関数は第 1 引数としてソケットオブジェクトを取ります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.listen">
<code class="descclassname">socket.</code><code class="descname">listen</code><span class="sig-paren">(</span><em>backlog</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.listen" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットをListenし、接続を待ちます。引数 <em>backlog</em> には接続キューの最大の長さ(0以上)を指定します。 <em>backlog</em> の最大数はシステムに依存します (通常は5)。最小値は必ず 0 です。</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.makefile">
<code class="descclassname">socket.</code><code class="descname">makefile</code><span class="sig-paren">(</span><span class="optional">[</span><em>mode</em><span class="optional">[</span>, <em>bufsize</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.makefile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-3">ソケットに関連付けられた <em class="dfn">ファイルオブジェクト</em> を返します (ファイルオブジェクトについては <a class="reference internal" href="stdtypes.html#bltin-file-objects"><span class="std std-ref">ファイルオブジェクト</span></a> を参照)。ファイルオブジェクトはその <a class="reference internal" href="#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> メソッドが呼ばれた際もソケットを明示的にクローズせずにソケットオブジェクトへの参照を削除するだけです。このため、ソケットは、どこからも参照されなくなってからクローズされます。</p>
<p>ソケットはブロッキングモードでなければなりません(タイムアウトを設定することもできません)。オプション引数の <em>mode</em> と <em>bufsize</em> には、 <a class="reference internal" href="functions.html#file" title="file"><code class="xref py py-func docutils literal"><span class="pre">file()</span></code></a> 組み込み関数と同じ値を指定します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Windows では、 <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal"><span class="pre">makefile()</span></code></a> によって作成される file-like オブジェクトは、 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-meth docutils literal"><span class="pre">subprocess.Popen()</span></code></a> などのファイル記述子のある file オブジェクトを期待している場所で利用することはできません。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.recv">
<code class="descclassname">socket.</code><code class="descname">recv</code><span class="sig-paren">(</span><em>bufsize</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recv" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットからデータを受信し、文字列として返します。受信する最大バイト数は、 <em>bufsize</em> で指定します。 <em>flags</em> のデフォルト値は0です。値の意味についてはUnixマニュアルページの <em class="manpage">recv(2)</em> を参照してください。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">ハードウェアおよびネットワークの現実に最大限マッチするように、 <em>bufsize</em> の値は比較的小さい2の累乗、たとえば 4096、にすべきです。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.recvfrom">
<code class="descclassname">socket.</code><code class="descname">recvfrom</code><span class="sig-paren">(</span><em>bufsize</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recvfrom" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットからデータを受信し、結果をタプル <code class="docutils literal"><span class="pre">(string,</span> <span class="pre">address)</span></code> として返します。 <em>string</em> は受信データの文字列で、 <em>address</em> は送信元のアドレスを示します。オプション引数 <em>flags</em> については、 Unix のマニュアルページ <em class="manpage">recv(2)</em> を参照してください。デフォルトは0です。 (<em>address</em> のフォーマットはアドレスファミリによって異なります(前述))</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.recvfrom_into">
<code class="descclassname">socket.</code><code class="descname">recvfrom_into</code><span class="sig-paren">(</span><em>buffer</em><span class="optional">[</span>, <em>nbytes</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recvfrom_into" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットからデータを受信し、そのデータを新しい文字列として返す代わりに <em>buffer</em> に書きます。戻り値は <code class="docutils literal"><span class="pre">(nbytes,</span> <span class="pre">address)</span></code> のペアで、 <em>nbytes</em> は受信したデータのバイト数を、 <em>address</em> はデータを送信したソケットのアドレスです。オプション引数 <em>flags</em> (デフォルト:0) の意味については、 Unix マニュアルページ <em class="manpage">recv(2)</em> を参照してください。(<em>address</em> のフォーマットは前述のとおりアドレスファミリーに依存します。)</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.recv_into">
<code class="descclassname">socket.</code><code class="descname">recv_into</code><span class="sig-paren">(</span><em>buffer</em><span class="optional">[</span>, <em>nbytes</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recv_into" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>nbytes</em> バイトまでのデータをソケットから受信して、そのデータを新しい文字列にするのではなく <em>buffer</em> に保存します。 <em>nbytes</em> が指定されない(あるいは0が指定された)場合、 <em>buffer</em> の利用可能なサイズまで受信します。受信したバイト数を返り値として返します。オプション引数 <em>flags</em> (デフォルト:0) の意味については、 Unix マニュアルページ <em class="manpage">recv(2)</em> を参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.send">
<code class="descclassname">socket.</code><code class="descname">send</code><span class="sig-paren">(</span><em>string</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.send" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットにデータを送信します。ソケットはリモートソケットに接続済みでなければなりません。オプション引数 <em>flags</em> の意味は、上記 <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a> と同じです。戻り値として、送信したバイト数を返します。アプリケーションでは、必ず戻り値をチェックし、全てのデータが送られた事を確認する必要があります。データの一部だけが送信された場合、アプリケーションで残りのデータを再送信してください。 <a class="reference internal" href="../howto/sockets.html#socket-howto"><span class="std std-ref">ソケットプログラミング HOWTO</span></a> に、さらに詳しい情報があります。</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.sendall">
<code class="descclassname">socket.</code><code class="descname">sendall</code><span class="sig-paren">(</span><em>string</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.sendall" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットにデータを送信します。ソケットはリモートソケットに接続済みでなければなりません。オプション引数 <em>flags</em> の意味は、上記 <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a> と同じです。 <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> と異なり、このメソッドは <em>string</em> の全データを送信するか、エラーが発生するまで処理を継続します。正常終了の場合は <code class="docutils literal"><span class="pre">None</span></code> を返し、エラー発生時には例外が発生します。エラー発生時、送信されたバイト数を調べる事はできません。</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.sendto">
<code class="descclassname">socket.</code><code class="descname">sendto</code><span class="sig-paren">(</span><em>string</em>, <em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.sendto" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descclassname">socket.</code><code class="descname">sendto</code><span class="sig-paren">(</span><em>string</em>, <em>flags</em>, <em>address</em><span class="sig-paren">)</span></dt>
<dd><p>ソケットにデータを送信します。このメソッドでは接続先を <em>address</em> で指定するので、接続済みではいけません。オプション引数 <em>flags</em> の意味は、上記 <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a> と同じです。戻り値として、送信したバイト数を返します。(<em>address</em> のフォーマットはアドレスファミリによって異なります — 前述。)</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.setblocking">
<code class="descclassname">socket.</code><code class="descname">setblocking</code><span class="sig-paren">(</span><em>flag</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.setblocking" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットのブロッキング・非ブロッキングモードを指定します。 <em>flag</em> が0 の場合は非ブロッキングモード、0以外の場合はブロッキングモードとなります。全てのソケットは、初期状態ではブロッキングモードです。非ブロッキングモードでは、 <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a> メソッド呼び出し時に読み込みデータが無かったり <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> メソッド呼び出し時にデータを処理する事ができないような場合に <a class="reference internal" href="#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">error</span></code></a> 例外が発生します。しかし、ブロッキングモードでは呼び出しは処理が行われるまでブロックされます。 <code class="docutils literal"><span class="pre">s.setblocking(0)</span></code> は <code class="docutils literal"><span class="pre">s.settimeout(0.0)</span></code> と、 <code class="docutils literal"><span class="pre">s.setblocking(1)</span></code> は <code class="docutils literal"><span class="pre">s.settimeout(None)</span></code> とそれぞれ同じ意味を持ちます。</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.settimeout">
<code class="descclassname">socket.</code><code class="descname">settimeout</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.settimeout" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットのブロッキング処理のタイムアウト値を指定します。 <em>value</em> には、正の浮動小数点で秒数を指定するか、もしくは <code class="docutils literal"><span class="pre">None</span></code> を指定します。浮動小数点値を指定した場合、操作が完了する前に <em>value</em> で指定した秒数が経過すると <a class="reference internal" href="#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal"><span class="pre">timeout</span></code></a> が発生します。タイムアウト値に <code class="docutils literal"><span class="pre">None</span></code> を指定すると、ソケットのタイムアウトを無効にします。 <code class="docutils literal"><span class="pre">s.settimeout(0.0)</span></code> は <code class="docutils literal"><span class="pre">s.setblocking(0)</span></code> と、 <code class="docutils literal"><span class="pre">s.settimeout(None)</span></code> は <code class="docutils literal"><span class="pre">s.setblocking(1)</span></code> とそれぞれ同じ意味を持ちます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.gettimeout">
<code class="descclassname">socket.</code><code class="descname">gettimeout</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.gettimeout" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットに指定されたタイムアウト値を取得します。タイムアウト値が設定されている場合には浮動小数点型で秒数が、設定されていなければ <code class="docutils literal"><span class="pre">None</span></code> が返ります。この値は、最後に呼び出された <a class="reference internal" href="#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal"><span class="pre">setblocking()</span></code></a> または <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></code></a> によって設定されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<p>ソケットのブロッキングとタイムアウトについて: ソケットオブジェクトのモードは、ブロッキング・非ブロッキング・タイムアウトの何れかとなります。初期状態では常にブロッキングモードです。ブロッキングモードでは、処理が完了するまで、もしくはシステムが (接続タイムアウトなどの) エラーを返すまでブロックされます。非ブロッキングモードでは、処理を行う事ができなければ(不幸にもシステムによって異なる値の)エラーとなります。タイムアウトモードでは、ソケットに指定したタイムアウトまで、もしくはシステムがエラーを返すまでに完了しなければ処理は失敗となります。 <a class="reference internal" href="#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal"><span class="pre">setblocking()</span></code></a> メソッドは、 <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></code></a> の省略形式です。</p>
<p>内部的には、タイムアウトモードではソケットを非ブロッキングモードに設定します。ブロッキングとタイムアウトの設定は、ソケットと同じネットワーク端点へ接続するファイル記述子にも反映されます。この結果、 <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal"><span class="pre">makefile()</span></code></a> で作成したファイルオブジェクトはブロッキングモードでのみ使用することができます。これは非ブロッキングモードとタイムアウトモードでは、即座に完了しないファイル操作はエラーとなるためです。</p>
<p>註: <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a> はタイムアウト設定に従います。一般的に、 <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></code></a> を <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a> の前に呼ぶかタイムアウト値を <a class="reference internal" href="#socket.create_connection" title="socket.create_connection"><code class="xref py py-meth docutils literal"><span class="pre">create_connection()</span></code></a> に渡すことをおすすめします。システムのネットワークスタックは Python のソケットタイムアウトの設定を無視して、自身のコネクションタイムアウトエラーを返すこともあります。</p>
<dl class="method">
<dt id="socket.socket.setsockopt">
<code class="descclassname">socket.</code><code class="descname">setsockopt</code><span class="sig-paren">(</span><em>level</em>, <em>optname</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.setsockopt" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-4">ソケットのオプションを設定します(Unixのマニュアルページ <em class="manpage">setsockopt(2)</em> を参照)。 <code class="xref py py-const docutils literal"><span class="pre">SO_*</span></code> 等のシンボルは、このモジュールで定義しています。 <code class="docutils literal"><span class="pre">value</span></code> には、整数または文字列をバッファとして指定する事ができます。文字列を指定する場合、文字列には適切なビットを設定するようにします。(<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret strings as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> モジュールを利用すれば、Cの構造体を文字列にエンコードする事ができます。)</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.shutdown">
<code class="descclassname">socket.</code><code class="descname">shutdown</code><span class="sig-paren">(</span><em>how</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.shutdown" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>接続の片方向、または両方向を切断します。 <em>how</em> が <code class="xref py py-const docutils literal"><span class="pre">SHUT_RD</span></code> の場合、以降は受信を行えません。 <em>how</em> が <code class="xref py py-const docutils literal"><span class="pre">SHUT_WR</span></code> の場合、以降は送信を行えません。 <em>how</em> が <code class="docutils literal"><span class="pre">SHUT_RDWR</span></code> の場合、以降は送受信を行えません。プラットフォームによっては、接続の片方向をシャットダウンすると相手側も閉じられます。(例えば、 Mac OS X では、 <code class="docutils literal"><span class="pre">shutdown(SHUT_WR)</span></code> をすると、接続の相手側はもう read ができなくなります)</p>
</dd></dl>

<p><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code> メソッドと <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> メソッドは存在しませんので注意してください。代わりに <em>flags</em> を省略した <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a> と <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> を使うことができます。</p>
<p>ソケットオブジェクトには以下の <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket</span></code></a> コンストラクタに渡された値に対応した (読み出し専用) 属性があります。</p>
<dl class="attribute">
<dt id="socket.socket.family">
<code class="descclassname">socket.</code><code class="descname">family</code><a class="headerlink" href="#socket.socket.family" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットファミリー。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="socket.socket.type">
<code class="descclassname">socket.</code><code class="descname">type</code><a class="headerlink" href="#socket.socket.type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットタイプ。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="socket.socket.proto">
<code class="descclassname">socket.</code><code class="descname">proto</code><a class="headerlink" href="#socket.socket.proto" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットプロトコル。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="example">
<span id="socket-example"></span><h2>17.2.2. 例<a class="headerlink" href="#example" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下は TCP/IP プロトコルの簡単なサンプルとして、受信したデータをクライアントにそのまま返送するサーバ (接続可能なクライアントは一件のみ) と、サーバに接続するクライアントの例を示します。サーバでは、 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> ・ <a class="reference internal" href="#socket.socket.bind" title="socket.socket.bind"><code class="xref py py-meth docutils literal"><span class="pre">bind()</span></code></a> ・ <a class="reference internal" href="#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal"><span class="pre">listen()</span></code></a> ・ <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code></a> を実行し (複数のクライアントからの接続を受け付ける場合、 <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code></a> を複数回呼び出します)、クライアントでは <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> と <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a> だけを呼び出しています。サーバでは <a class="reference internal" href="#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal"><span class="pre">sendall()</span></code></a> / <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a> メソッドは listen 中のソケットで実行するのではなく、 <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code></a> で取得したソケットに対して実行している点にも注意してください。</p>
<p>次のクライアントとサーバは、IPv4 のみをサポートしています。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Echo server program</span>
<span class="kn">import</span> <span class="nn">socket</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>                 <span class="c1"># Symbolic name meaning all available interfaces</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># Arbitrary non-privileged port</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
<span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
<span class="nb">print</span> <span class="s1">&#39;Connected by&#39;</span><span class="p">,</span> <span class="n">addr</span>
<span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span> <span class="k">break</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Echo client program</span>
<span class="kn">import</span> <span class="nn">socket</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s1">&#39;daring.cwi.nl&#39;</span>    <span class="c1"># The remote host</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># The same port as used by the server</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
<span class="n">s</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="s1">&#39;Hello, world&#39;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="nb">print</span> <span class="s1">&#39;Received&#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>次のサンプルは上記のサンプルとほとんど同じですが、IPv4 と IPv6 の両方をサポートしています。サーバでは、IPv4/v6 の両方ではなく、利用可能な最初のアドレスファミリだけを listen しています。ほとんどの IPv6 対応システムでは IPv6 が先に現れるため、サーバは IPv4 には応答しません。クライアントでは名前解決の結果として取得したアドレスに順次接続を試み、最初に接続に成功したソケットにデータを送信しています。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Echo server program</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="kc">None</span>               <span class="c1"># Symbolic name meaning all available interfaces</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># Arbitrary non-privileged port</span>
<span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_UNSPEC</span><span class="p">,</span>
                              <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">AI_PASSIVE</span><span class="p">):</span>
    <span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">canonname</span><span class="p">,</span> <span class="n">sa</span> <span class="o">=</span> <span class="n">res</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">sa</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">break</span>
<span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span> <span class="s1">&#39;could not open socket&#39;</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
<span class="nb">print</span> <span class="s1">&#39;Connected by&#39;</span><span class="p">,</span> <span class="n">addr</span>
<span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span> <span class="k">break</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Echo client program</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s1">&#39;daring.cwi.nl&#39;</span>    <span class="c1"># The remote host</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># The same port as used by the server</span>
<span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_UNSPEC</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">):</span>
    <span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">canonname</span><span class="p">,</span> <span class="n">sa</span> <span class="o">=</span> <span class="n">res</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">sa</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">break</span>
<span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span> <span class="s1">&#39;could not open socket&#39;</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="s1">&#39;Hello, world&#39;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="nb">print</span> <span class="s1">&#39;Received&#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>最後の例は、Windowsで raw socket を利用して非常にシンプルなネットワークスニファーを書きます。このサンプルを実行するには、インタフェースを操作するための管理者権限が必要です。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>

<span class="c1"># the public network interface</span>
<span class="n">HOST</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">gethostbyname</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">())</span>

<span class="c1"># create a raw socket and bind it to the public interface</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_RAW</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_IP</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># Include IP headers</span>
<span class="n">s</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_IP</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">IP_HDRINCL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># receive all packages</span>
<span class="n">s</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SIO_RCVALL</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">RCVALL_ON</span><span class="p">)</span>

<span class="c1"># receive a package</span>
<span class="nb">print</span> <span class="n">s</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">65565</span><span class="p">)</span>

<span class="c1"># disabled promiscuous mode</span>
<span class="n">s</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SIO_RCVALL</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">RCVALL_OFF</span><span class="p">)</span>
</pre></div>
</div>
<p>この例の実行を、ほとんど間を空けずに何度も実行すると、以下のエラーが起こるかもしれません:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">:</span> <span class="p">[</span><span class="n">Errno</span> <span class="mi">98</span><span class="p">]</span> <span class="n">Address</span> <span class="n">already</span> <span class="ow">in</span> <span class="n">use</span>
</pre></div>
</div>
<p>これは以前の実行がソケットを <code class="docutils literal"><span class="pre">TIME_WAIT</span></code> 状態のままにし、すぐには再利用出来ないことで起こります。</p>
<p>これを防ぐのに、 <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> フラグの <code class="xref py py-data docutils literal"><span class="pre">socket.SO_REUSEADDR</span></code> があります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="xref py py-data docutils literal"><span class="pre">SO_REUSEADDR</span></code> フラグは、 <code class="docutils literal"><span class="pre">TIME_WAIT</span></code> 状態にあるローカルソケットをそのタイムアウト期限が自然に切れるのを待つことなく再利用することをカーネルに伝えます。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">17.2. <code class="docutils literal"><span class="pre">socket</span></code> — 低レベルネットワークインターフェース</a><ul>
<li><a class="reference internal" href="#socket-objects">17.2.1. socket オブジェクト</a></li>
<li><a class="reference internal" href="#example">17.2.2. 例</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="subprocess.html"
                        title="前の章へ">17.1. <code class="docutils literal"><span class="pre">subprocess</span></code> — サブプロセス管理</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="ssl.html"
                        title="次の章へ">17.3. <code class="docutils literal"><span class="pre">ssl</span></code> — ソケットオブジェクトに対する TLS/SSL ラッパー</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">バグ報告</a></li>
  <li><a href="https://github.com/python/cpython/blob/2.7/Doc/library/socket.rst"
         rel="nofollow">ソースの表示</a>
  </li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="ssl.html" title="17.3. ssl — ソケットオブジェクトに対する TLS/SSL ラッパー"
             >次へ</a> |</li>
        <li class="right" >
          <a href="subprocess.html" title="17.1. subprocess — サブプロセス管理"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.14</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >17. プロセス間通信とネットワーク</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2018, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト).
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 2018-04-21
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>