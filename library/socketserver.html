<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>20.17. SocketServer — ネットワークサーバ構築のためのフレームワーク &#8212; Python 2.7.13 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.13',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7.13 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 2.7.13 ドキュメント" href="../contents.html" />
    <link rel="up" title="20. インターネットプロトコルとサポート" href="internet.html" />
    <link rel="next" title="20.18. BaseHTTPServer — 基本的な機能を持つ HTTP サーバ" href="basehttpserver.html" />
    <link rel="prev" title="20.16. urlparse — URL を解析して構成要素にする" href="urlparse.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/socketserver.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="basehttpserver.html" title="20.18. BaseHTTPServer — 基本的な機能を持つ HTTP サーバ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="urlparse.html" title="20.16. urlparse — URL を解析して構成要素にする"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.13</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">20. インターネットプロトコルとサポート</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-SocketServer">
<span id="socketserver-a-framework-for-network-servers"></span><h1>20.17. <a class="reference internal" href="#module-SocketServer" title="SocketServer: A framework for network servers."><code class="xref py py-mod docutils literal"><span class="pre">SocketServer</span></code></a> &#8212; ネットワークサーバ構築のためのフレームワーク<a class="headerlink" href="#module-SocketServer" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#module-SocketServer" title="SocketServer: A framework for network servers."><code class="xref py py-mod docutils literal"><span class="pre">SocketServer</span></code></a> モジュールは、Python 3 では <code class="xref py py-mod docutils literal"><span class="pre">socketserver</span></code> にリネームされました。 <a class="reference internal" href="../glossary.html#term-2to3"><span class="xref std std-term">2to3</span></a> ツールが自動的にソースコードの import を修正します。</p>
</div>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/2.7/Lib/SocketServer.py">Lib/SocketServer.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-SocketServer" title="SocketServer: A framework for network servers."><code class="xref py py-mod docutils literal"><span class="pre">SocketServer</span></code></a> モジュールはネットワークサーバを実装するタスクを単純化します。</p>
<p>基本的な具象サーバクラスが4つあります:</p>
<dl class="class">
<dt id="SocketServer.TCPServer">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">TCPServer</code><span class="sig-paren">(</span><em>server_address</em>, <em>RequestHandlerClass</em>, <em>bind_and_activate=True</em><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.TCPServer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This uses the Internet TCP protocol, which provides for
continuous streams of data between the client and server.
If <em>bind_and_activate</em> is true, the constructor automatically attempts to
invoke <a class="reference internal" href="#SocketServer.BaseServer.server_bind" title="SocketServer.BaseServer.server_bind"><code class="xref py py-meth docutils literal"><span class="pre">server_bind()</span></code></a> and
<a class="reference internal" href="#SocketServer.BaseServer.server_activate" title="SocketServer.BaseServer.server_activate"><code class="xref py py-meth docutils literal"><span class="pre">server_activate()</span></code></a>.  The other parameters are passed to
the <a class="reference internal" href="#SocketServer.BaseServer" title="SocketServer.BaseServer"><code class="xref py py-class docutils literal"><span class="pre">BaseServer</span></code></a> base class.</p>
</dd></dl>

<dl class="class">
<dt id="SocketServer.UDPServer">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">UDPServer</code><span class="sig-paren">(</span><em>server_address</em>, <em>RequestHandlerClass</em>, <em>bind_and_activate=True</em><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.UDPServer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This uses datagrams, which are discrete packets of information that may
arrive out of order or be lost while in transit.  The parameters are
the same as for <a class="reference internal" href="#SocketServer.TCPServer" title="SocketServer.TCPServer"><code class="xref py py-class docutils literal"><span class="pre">TCPServer</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="SocketServer.UnixStreamServer">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">UnixStreamServer</code><span class="sig-paren">(</span><em>server_address</em>, <em>RequestHandlerClass</em>, <em>bind_and_activate=True</em><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.UnixStreamServer" title="この定義へのパーマリンク">¶</a></dt>
<dt id="SocketServer.UnixDatagramServer">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">UnixDatagramServer</code><span class="sig-paren">(</span><em>server_address</em>, <em>RequestHandlerClass</em>, <em>bind_and_activate=True</em><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.UnixDatagramServer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These more infrequently used classes are similar to the TCP and
UDP classes, but use Unix domain sockets; they&#8217;re not available on
non-Unix platforms.  The parameters are the same as for
<a class="reference internal" href="#SocketServer.TCPServer" title="SocketServer.TCPServer"><code class="xref py py-class docutils literal"><span class="pre">TCPServer</span></code></a>.</p>
</dd></dl>

<p>これらの 4 つのクラスは要求を <em class="dfn">同期的に (synchronously)</em> 処理します; 各要求は次の要求を開始する前に完結していなければなりません。同期的な処理は、サーバで大量の計算を必要とする、あるいはクライアントが処理するには時間がかかりすぎるような大量のデータを返す、といった理由によってリクエストに長い時間がかかる状況には向いていません。こうした状況の解決方法は別のプロセスを生成するか、個々の要求を扱うスレッドを生成することです;  <a class="reference internal" href="#SocketServer.ForkingMixIn" title="SocketServer.ForkingMixIn"><code class="xref py py-class docutils literal"><span class="pre">ForkingMixIn</span></code></a> および <a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code></a> 配合クラス (mix-in classes) を使えば、非同期的な動作をサポートできます。</p>
<p>Creating a server requires several steps.  First, you must create a request
handler class by subclassing the <a class="reference internal" href="#SocketServer.BaseRequestHandler" title="SocketServer.BaseRequestHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseRequestHandler</span></code></a> class and
overriding its <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code></a> method;
this method will process incoming
requests.  Second, you must instantiate one of the server classes, passing it
the server&#8217;s address and the request handler class.  Then call the
<a class="reference internal" href="#SocketServer.BaseServer.handle_request" title="SocketServer.BaseServer.handle_request"><code class="xref py py-meth docutils literal"><span class="pre">handle_request()</span></code></a> or
<a class="reference internal" href="#SocketServer.BaseServer.serve_forever" title="SocketServer.BaseServer.serve_forever"><code class="xref py py-meth docutils literal"><span class="pre">serve_forever()</span></code></a> method of the server object to
process one or many requests.  Finally, call <a class="reference internal" href="#SocketServer.BaseServer.server_close" title="SocketServer.BaseServer.server_close"><code class="xref py py-meth docutils literal"><span class="pre">server_close()</span></code></a>
to close the socket.</p>
<p><a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code></a> から継承してスレッドを利用した接続を行う場合、突発的な通信切断時の処理を明示的に指定する必要があります。 <a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code></a> クラスには <em>daemon_threads</em> 属性があり、サーバがスレッドの終了を待ち合わせるかどうかを指定する事ができます。スレッドが独自の処理を行う場合は、このフラグを明示的に指定します。デフォルトは <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> で、Pythonは <a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code></a> クラスが起動した全てのスレッドが終了するまで実行し続けます。</p>
<p>サーバクラス群は使用するネットワークプロトコルに関わらず、同じ外部メソッドおよび属性を持ちます。</p>
<div class="section" id="server-creation-notes">
<h2>20.17.1. サーバ生成に関するノート<a class="headerlink" href="#server-creation-notes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>継承図にある五つのクラスのうち四つは四種類の同期サーバを表わしています:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">+------------+</span>
<span class="o">|</span> <span class="n">BaseServer</span> <span class="o">|</span>
<span class="o">+------------+</span>
      <span class="o">|</span>
      <span class="n">v</span>
<span class="o">+-----------+</span>        <span class="o">+------------------+</span>
<span class="o">|</span> <span class="n">TCPServer</span> <span class="o">|-------&gt;|</span> <span class="n">UnixStreamServer</span> <span class="o">|</span>
<span class="o">+-----------+</span>        <span class="o">+------------------+</span>
      <span class="o">|</span>
      <span class="n">v</span>
<span class="o">+-----------+</span>        <span class="o">+--------------------+</span>
<span class="o">|</span> <span class="n">UDPServer</span> <span class="o">|-------&gt;|</span> <span class="n">UnixDatagramServer</span> <span class="o">|</span>
<span class="o">+-----------+</span>        <span class="o">+--------------------+</span>
</pre></div>
</div>
<p><a class="reference internal" href="#SocketServer.UnixDatagramServer" title="SocketServer.UnixDatagramServer"><code class="xref py py-class docutils literal"><span class="pre">UnixDatagramServer</span></code></a> は <a class="reference internal" href="#SocketServer.UDPServer" title="SocketServer.UDPServer"><code class="xref py py-class docutils literal"><span class="pre">UDPServer</span></code></a> から派生していて、 <a class="reference internal" href="#SocketServer.UnixStreamServer" title="SocketServer.UnixStreamServer"><code class="xref py py-class docutils literal"><span class="pre">UnixStreamServer</span></code></a> からではないことに注意してください &#8212; IP と Unix ストリームサーバの唯一の違いはアドレスファミリーでそれは両方の Unix サーバクラスで単純に繰り返されています。</p>
<dl class="class">
<dt id="SocketServer.ForkingMixIn">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">ForkingMixIn</code><a class="headerlink" href="#SocketServer.ForkingMixIn" title="この定義へのパーマリンク">¶</a></dt>
<dt id="SocketServer.ThreadingMixIn">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">ThreadingMixIn</code><a class="headerlink" href="#SocketServer.ThreadingMixIn" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Forking and threading versions of each type of server can be created
using these mix-in classes.  For instance, <a class="reference internal" href="#SocketServer.ThreadingUDPServer" title="SocketServer.ThreadingUDPServer"><code class="xref py py-class docutils literal"><span class="pre">ThreadingUDPServer</span></code></a>
is created as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ThreadingUDPServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">UDPServer</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The mix-in class comes first, since it overrides a method defined in
<a class="reference internal" href="#SocketServer.UDPServer" title="SocketServer.UDPServer"><code class="xref py py-class docutils literal"><span class="pre">UDPServer</span></code></a>.  Setting the various attributes also changes the
behavior of the underlying server mechanism.</p>
<p><a class="reference internal" href="#SocketServer.ForkingMixIn" title="SocketServer.ForkingMixIn"><code class="xref py py-class docutils literal"><span class="pre">ForkingMixIn</span></code></a> and the Forking classes mentioned below are
only available on POSIX platforms that support <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">fork()</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="SocketServer.ForkingTCPServer">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">ForkingTCPServer</code><a class="headerlink" href="#SocketServer.ForkingTCPServer" title="この定義へのパーマリンク">¶</a></dt>
<dt id="SocketServer.ForkingUDPServer">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">ForkingUDPServer</code><a class="headerlink" href="#SocketServer.ForkingUDPServer" title="この定義へのパーマリンク">¶</a></dt>
<dt id="SocketServer.ThreadingTCPServer">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">ThreadingTCPServer</code><a class="headerlink" href="#SocketServer.ThreadingTCPServer" title="この定義へのパーマリンク">¶</a></dt>
<dt id="SocketServer.ThreadingUDPServer">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">ThreadingUDPServer</code><a class="headerlink" href="#SocketServer.ThreadingUDPServer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These classes are pre-defined using the mix-in classes.</p>
</dd></dl>

<p>To implement a service, you must derive a class from <a class="reference internal" href="#SocketServer.BaseRequestHandler" title="SocketServer.BaseRequestHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseRequestHandler</span></code></a>
and redefine its <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code></a> method.
You can then run various versions of
the service by combining one of the server classes with your request handler
class.  The request handler class must be different for datagram or stream
services.  This can be hidden by using the handler subclasses
<a class="reference internal" href="#SocketServer.StreamRequestHandler" title="SocketServer.StreamRequestHandler"><code class="xref py py-class docutils literal"><span class="pre">StreamRequestHandler</span></code></a> or <a class="reference internal" href="#SocketServer.DatagramRequestHandler" title="SocketServer.DatagramRequestHandler"><code class="xref py py-class docutils literal"><span class="pre">DatagramRequestHandler</span></code></a>.</p>
<p>もちろん、まだ頭を使わなければなりません! たとえば、サービスがリクエストによっては書き換えられるようなメモリ上の状態を使うならば、フォークするサーバを使うのは馬鹿げています。というのも子プロセスでの書き換えは親プロセスで保存されている初期状態にも親プロセスから分配される各子プロセスの状態にも届かないからです。この場合、スレッド実行するサーバを使うことはできますが、共有データの一貫性を保つためにロックを使わなければならなくなるでしょう。</p>
<p>一方、全てのデータが外部に(たとえばファイルシステムに)保存される HTTP サーバを作っているのだとすると、同期クラスではどうしても一つの要求が処理されている間サービスが「耳の聞こえない」状態を呈することになります &#8212; この状態はもしクライアントが要求した全てのデータをゆっくり受け取るととても長い時間続きかねません。こういう場合にはサーバをスレッド実行したりフォークすることが適切です。</p>
<p>In some cases, it may be appropriate to process part of a request synchronously,
but to finish processing in a forked child depending on the request data.  This
can be implemented by using a synchronous server and doing an explicit fork in
the request handler class <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code></a> method.</p>
<p>スレッドも <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">fork()</span></code></a> もサポートされない環境で (もしくはサービスにとってそれらがあまりに高価についたり不適切な場合に) 多数の同時要求を捌くもう一つのアプローチは、部分的に処理し終えた要求のテーブルを自分で管理し、次にどの要求に対処するか (または新しく入ってきた要求を扱うかどうか) を決めるのに <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select()</span></code></a> を使う方法です。これは (もしスレッドやサブプロセスが使えなければ) 特にストリームサービスに対して重要で、そのようなサービスでは各クライアントが潜在的に長く接続し続けます。この問題を管理する別の方法について、 <a class="reference internal" href="asyncore.html#module-asyncore" title="asyncore: A base class for developing asynchronous socket handling services."><code class="xref py py-mod docutils literal"><span class="pre">asyncore</span></code></a> モジュールを参照してください。</p>
</div>
<div class="section" id="server-objects">
<h2>20.17.2. Serverオブジェクト<a class="headerlink" href="#server-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="class">
<dt id="SocketServer.BaseServer">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">BaseServer</code><span class="sig-paren">(</span><em>server_address</em>, <em>RequestHandlerClass</em><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This is the superclass of all Server objects in the module.  It defines the
interface, given below, but does not implement most of the methods, which is
done in subclasses.  The two parameters are stored in the respective
<a class="reference internal" href="#SocketServer.BaseServer.server_address" title="SocketServer.BaseServer.server_address"><code class="xref py py-attr docutils literal"><span class="pre">server_address</span></code></a> and <a class="reference internal" href="#SocketServer.BaseServer.RequestHandlerClass" title="SocketServer.BaseServer.RequestHandlerClass"><code class="xref py py-attr docutils literal"><span class="pre">RequestHandlerClass</span></code></a> attributes.</p>
<dl class="method">
<dt id="SocketServer.BaseServer.fileno">
<code class="descname">fileno</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.fileno" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバが要求待ちを行っているソケットのファイル記述子を整数で返します。この関数は一般的に、同じプロセス中の複数のサーバを監視できるようにするために、 <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select.select()</span></code></a> に渡されます。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.handle_request">
<code class="descname">handle_request</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.handle_request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Process a single request.  This function calls the following methods in
order: <a class="reference internal" href="#SocketServer.BaseServer.get_request" title="SocketServer.BaseServer.get_request"><code class="xref py py-meth docutils literal"><span class="pre">get_request()</span></code></a>, <a class="reference internal" href="#SocketServer.BaseServer.verify_request" title="SocketServer.BaseServer.verify_request"><code class="xref py py-meth docutils literal"><span class="pre">verify_request()</span></code></a>, and
<a class="reference internal" href="#SocketServer.BaseServer.process_request" title="SocketServer.BaseServer.process_request"><code class="xref py py-meth docutils literal"><span class="pre">process_request()</span></code></a>.  If the user-provided
<a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code></a> method of the
handler class raises an exception, the server&#8217;s <a class="reference internal" href="#SocketServer.BaseServer.handle_error" title="SocketServer.BaseServer.handle_error"><code class="xref py py-meth docutils literal"><span class="pre">handle_error()</span></code></a> method
will be called.  If no request is received within <a class="reference internal" href="#SocketServer.BaseServer.timeout" title="SocketServer.BaseServer.timeout"><code class="xref py py-attr docutils literal"><span class="pre">timeout</span></code></a>
seconds, <a class="reference internal" href="#SocketServer.BaseServer.handle_timeout" title="SocketServer.BaseServer.handle_timeout"><code class="xref py py-meth docutils literal"><span class="pre">handle_timeout()</span></code></a> will be called and <a class="reference internal" href="#SocketServer.BaseServer.handle_request" title="SocketServer.BaseServer.handle_request"><code class="xref py py-meth docutils literal"><span class="pre">handle_request()</span></code></a>
will return.</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.serve_forever">
<code class="descname">serve_forever</code><span class="sig-paren">(</span><em>poll_interval=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.serve_forever" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Handle requests until an explicit <a class="reference internal" href="#SocketServer.BaseServer.shutdown" title="SocketServer.BaseServer.shutdown"><code class="xref py py-meth docutils literal"><span class="pre">shutdown()</span></code></a> request.  Poll for
shutdown every <em>poll_interval</em> seconds.
Ignores the <a class="reference internal" href="#SocketServer.BaseServer.timeout" title="SocketServer.BaseServer.timeout"><code class="xref py py-attr docutils literal"><span class="pre">timeout</span></code></a> attribute.
If you need to do periodic tasks, do them in another thread.</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.shutdown">
<code class="descname">shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.shutdown" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#SocketServer.BaseServer.serve_forever" title="SocketServer.BaseServer.serve_forever"><code class="xref py py-meth docutils literal"><span class="pre">serve_forever()</span></code></a> ループに停止するように指示し、停止されるまで待ちます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.server_close">
<code class="descname">server_close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.server_close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバをクリーンアップします。上書き出来ます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.address_family">
<code class="descname">address_family</code><a class="headerlink" href="#SocketServer.BaseServer.address_family" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバのソケットが属しているプロトコルファミリです。一般的な値は <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">socket.AF_INET</span></code></a> および <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">socket.AF_UNIX</span></code></a> です。</p>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.RequestHandlerClass">
<code class="descname">RequestHandlerClass</code><a class="headerlink" href="#SocketServer.BaseServer.RequestHandlerClass" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ユーザが提供する要求処理クラスです; 要求ごとにこのクラスのインスタンスが生成されます。</p>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.server_address">
<code class="descname">server_address</code><a class="headerlink" href="#SocketServer.BaseServer.server_address" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The address on which the server is listening.  The format of addresses varies
depending on the protocol family;
see the documentation for the <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> module
for details.  For Internet protocols, this is a tuple containing a string giving
the address, and an integer port number: <code class="docutils literal"><span class="pre">('127.0.0.1',</span> <span class="pre">80)</span></code>, for example.</p>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.socket">
<code class="descname">socket</code><a class="headerlink" href="#SocketServer.BaseServer.socket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバが入力の要求待ちを行うためのソケットオブジェクトです。</p>
</dd></dl>

<p>サーバクラスは以下のクラス変数をサポートします:</p>
<dl class="attribute">
<dt id="SocketServer.BaseServer.allow_reuse_address">
<code class="descname">allow_reuse_address</code><a class="headerlink" href="#SocketServer.BaseServer.allow_reuse_address" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバがアドレスの再使用を許すかどうかを示す値です。この値は標準で <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> で、サブクラスで再使用ポリシを変更するために設定することができます。</p>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.request_queue_size">
<code class="descname">request_queue_size</code><a class="headerlink" href="#SocketServer.BaseServer.request_queue_size" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要求待ち行列 (queue) のサイズです。単一の要求を処理するのに長時間かかる場合には、サーバが処理中に届いた要求は最大 <a class="reference internal" href="#SocketServer.BaseServer.request_queue_size" title="SocketServer.BaseServer.request_queue_size"><code class="xref py py-attr docutils literal"><span class="pre">request_queue_size</span></code></a> 個まで待ち行列に置かれます。待ち行列が一杯になると、それ以降のクライアントからの要求は &#8220;接続拒否 (Connection denied)&#8221; エラーになります。標準の値は通常 5 ですが、この値はサブクラスで上書きすることができます。</p>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.socket_type">
<code class="descname">socket_type</code><a class="headerlink" href="#SocketServer.BaseServer.socket_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバが使うソケットの型です; 一般的な2つの値は、 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_STREAM</span></code></a> と <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_DGRAM</span></code></a> です。</p>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.timeout">
<code class="descname">timeout</code><a class="headerlink" href="#SocketServer.BaseServer.timeout" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>タイムアウト時間(秒)、もしくは、タイムアウトを望まない場合に <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> 。 <a class="reference internal" href="#SocketServer.BaseServer.handle_request" title="SocketServer.BaseServer.handle_request"><code class="xref py py-meth docutils literal"><span class="pre">handle_request()</span></code></a> がこの時間内にリクエストを受信しない場合、 <a class="reference internal" href="#SocketServer.BaseServer.handle_timeout" title="SocketServer.BaseServer.handle_timeout"><code class="xref py py-meth docutils literal"><span class="pre">handle_timeout()</span></code></a> メソッドが呼ばれます。</p>
</dd></dl>

<p><a class="reference internal" href="#SocketServer.TCPServer" title="SocketServer.TCPServer"><code class="xref py py-class docutils literal"><span class="pre">TCPServer</span></code></a> のような基底クラスのサブクラスで上書きできるサーバメソッドは多数あります; これらのメソッドはサーバオブジェクトの外部のユーザにとっては役にたたないものです。</p>
<dl class="method">
<dt id="SocketServer.BaseServer.finish_request">
<code class="descname">finish_request</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.finish_request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Actually processes the request by instantiating <a class="reference internal" href="#SocketServer.BaseServer.RequestHandlerClass" title="SocketServer.BaseServer.RequestHandlerClass"><code class="xref py py-attr docutils literal"><span class="pre">RequestHandlerClass</span></code></a> and
calling its <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.get_request">
<code class="descname">get_request</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.get_request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットから要求を受理して、クライアントとの通信に使われる <em>新しい</em> ソケットオブジェクト、およびクライアントのアドレスからなる、2 要素のタプルを返します。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.handle_error">
<code class="descname">handle_error</code><span class="sig-paren">(</span><em>request</em>, <em>client_address</em><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.handle_error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This function is called if the <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code></a>
method of a <a class="reference internal" href="#SocketServer.BaseServer.RequestHandlerClass" title="SocketServer.BaseServer.RequestHandlerClass"><code class="xref py py-attr docutils literal"><span class="pre">RequestHandlerClass</span></code></a> instance raises
an exception.  The default action is to print the traceback to
standard output and continue handling further requests.</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.handle_timeout">
<code class="descname">handle_timeout</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.handle_timeout" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="#SocketServer.BaseServer.timeout" title="SocketServer.BaseServer.timeout"><code class="xref py py-attr docutils literal"><span class="pre">timeout</span></code></a> 属性が <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> 以外に設定されて、リクエストがないままタイムアウト秒数が過ぎたときに呼ばれます。 fork型サーバーでのデフォルトの動作は、終了した子プロセスの情報を集めるようになっています。スレッド型サーバーではこのメソッドは何もしません。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.process_request">
<code class="descname">process_request</code><span class="sig-paren">(</span><em>request</em>, <em>client_address</em><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.process_request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#SocketServer.BaseServer.finish_request" title="SocketServer.BaseServer.finish_request"><code class="xref py py-meth docutils literal"><span class="pre">finish_request()</span></code></a> を呼び出して、 <a class="reference internal" href="#SocketServer.BaseServer.RequestHandlerClass" title="SocketServer.BaseServer.RequestHandlerClass"><code class="xref py py-attr docutils literal"><span class="pre">RequestHandlerClass</span></code></a> のインスタンスを生成します。必要なら、この関数から新たなプロセスかスレッドを生成して要求を処理することができます; その処理は <a class="reference internal" href="#SocketServer.ForkingMixIn" title="SocketServer.ForkingMixIn"><code class="xref py py-class docutils literal"><span class="pre">ForkingMixIn</span></code></a> または <a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code></a>  クラスが行います。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.server_activate">
<code class="descname">server_activate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.server_activate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Called by the server&#8217;s constructor to activate the server.  The default behavior
for a TCP server just invokes <a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal"><span class="pre">listen()</span></code></a>
on the server&#8217;s socket. May be overridden.</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.server_bind">
<code class="descname">server_bind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.server_bind" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバのコンストラクタによって呼び出され、適切なアドレスにソケットをバインドします。このメソッドは上書きできます。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.verify_request">
<code class="descname">verify_request</code><span class="sig-paren">(</span><em>request</em>, <em>client_address</em><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.verify_request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ブール値を返さなければなりません; 値が <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> の場合には要求が処理され、 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> の場合には要求は拒否されます。サーバへのアクセス制御を実装するためにこの関数を上書きすることができます。標準の実装では常に <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を返します。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="request-handler-objects">
<h2>20.17.3. Request Handler Objects<a class="headerlink" href="#request-handler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="class">
<dt id="SocketServer.BaseRequestHandler">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">BaseRequestHandler</code><a class="headerlink" href="#SocketServer.BaseRequestHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This is the superclass of all request handler objects.  It defines
the interface, given below.  A concrete request handler subclass must
define a new <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code></a> method, and can override any of
the other methods.  A new instance of the subclass is created for each
request.</p>
<dl class="method">
<dt id="SocketServer.BaseRequestHandler.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseRequestHandler.setup" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code></a>   メソッドより前に呼び出され、何らかの必要な初期化処理を行います。標準の実装では何も行いません。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseRequestHandler.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseRequestHandler.handle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数では、クライアントからの要求を実現するために必要な全ての作業を行わなければなりません。デフォルト実装では何もしません。この作業の上で、いくつかのインスタンス属性を利用することができます; クライアントからの要求は <code class="xref py py-attr docutils literal"><span class="pre">self.request</span></code> です; クライアントのアドレスは <code class="xref py py-attr docutils literal"><span class="pre">self.client_address</span></code> です;  そしてサーバごとの情報にアクセスする場合には、サーバインスタンスを <code class="xref py py-attr docutils literal"><span class="pre">self.server</span></code> で取得できます。</p>
<p>The type of <code class="xref py py-attr docutils literal"><span class="pre">self.request</span></code> is different for datagram or stream
services.  For stream services, <code class="xref py py-attr docutils literal"><span class="pre">self.request</span></code> is a socket object; for
datagram services, <code class="xref py py-attr docutils literal"><span class="pre">self.request</span></code> is a pair of string and socket.</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseRequestHandler.finish">
<code class="descname">finish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseRequestHandler.finish" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code></a>   メソッドより後に呼び出され、何らかの必要なクリーンアップ処理を行います。標準の実装では何も行いません。 <a class="reference internal" href="#SocketServer.BaseRequestHandler.setup" title="SocketServer.BaseRequestHandler.setup"><code class="xref py py-meth docutils literal"><span class="pre">setup()</span></code></a> メソッドが例外を送出した場合、このメソッドは呼び出されません。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="SocketServer.StreamRequestHandler">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">StreamRequestHandler</code><a class="headerlink" href="#SocketServer.StreamRequestHandler" title="この定義へのパーマリンク">¶</a></dt>
<dt id="SocketServer.DatagramRequestHandler">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">DatagramRequestHandler</code><a class="headerlink" href="#SocketServer.DatagramRequestHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These <a class="reference internal" href="#SocketServer.BaseRequestHandler" title="SocketServer.BaseRequestHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseRequestHandler</span></code></a> subclasses override the
<a class="reference internal" href="#SocketServer.BaseRequestHandler.setup" title="SocketServer.BaseRequestHandler.setup"><code class="xref py py-meth docutils literal"><span class="pre">setup()</span></code></a> and <a class="reference internal" href="#SocketServer.BaseRequestHandler.finish" title="SocketServer.BaseRequestHandler.finish"><code class="xref py py-meth docutils literal"><span class="pre">finish()</span></code></a>
methods, and provide <code class="xref py py-attr docutils literal"><span class="pre">self.rfile</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">self.wfile</span></code> attributes.
The <code class="xref py py-attr docutils literal"><span class="pre">self.rfile</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">self.wfile</span></code> attributes can be
read or written, respectively, to get the request data or return data
to the client.</p>
</dd></dl>

</div>
<div class="section" id="examples">
<h2>20.17.4. 例<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="socketserver-tcpserver-example">
<h3>20.17.4.1. <a class="reference internal" href="#SocketServer.TCPServer" title="SocketServer.TCPServer"><code class="xref py py-class docutils literal"><span class="pre">SocketServer.TCPServer</span></code></a> の例<a class="headerlink" href="#socketserver-tcpserver-example" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>サーバーサイドの例です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">SocketServer</span>

<span class="k">class</span> <span class="nc">MyTCPHandler</span><span class="p">(</span><span class="n">SocketServer</span><span class="o">.</span><span class="n">BaseRequestHandler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The request handler class for our server.</span>

<span class="sd">    It is instantiated once per connection to the server, and must</span>
<span class="sd">    override the handle() method to implement communication to the</span>
<span class="sd">    client.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># self.request is the TCP socket connected to the client</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="nb">print</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> wrote:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="c1"># just send back the same data, but upper-cased</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">9999</span>

    <span class="c1"># Create the server, binding to localhost on port 9999</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">SocketServer</span><span class="o">.</span><span class="n">TCPServer</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">),</span> <span class="n">MyTCPHandler</span><span class="p">)</span>

    <span class="c1"># Activate the server; this will keep running until you</span>
    <span class="c1"># interrupt the program with Ctrl-C</span>
    <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>別の、ストリーム(標準のファイル型のインタフェースを利用して通信をシンプルにしたファイルライクオブジェクト)を使うリクエストハンドラクラスの例です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTCPHandler</span><span class="p">(</span><span class="n">SocketServer</span><span class="o">.</span><span class="n">StreamRequestHandler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># self.rfile is a file-like object created by the handler;</span>
        <span class="c1"># we can now use e.g. readline() instead of raw recv() calls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="nb">print</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> wrote:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="c1"># Likewise, self.wfile is a file-like object used to write back</span>
        <span class="c1"># to the client</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
</pre></div>
</div>
<p>先ほどとの違いは、<code class="docutils literal"><span class="pre">readline()</span></code> の呼び出しが、改行を受け取るまで <code class="docutils literal"><span class="pre">recv()</span></code> を複数回呼び出すことです。1回の <code class="docutils literal"><span class="pre">recv()</span></code> の呼び出しは、クライアント側から1回の <code class="docutils literal"><span class="pre">sendall()</span></code> 呼び出しで送信された分しか受け取りません。</p>
<p>クライアントサイドの例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">9999</span>
<span class="n">data</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

<span class="c1"># Create a socket (SOCK_STREAM means a TCP socket)</span>
<span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Connect to server and send data</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Receive data from the server and shut down</span>
    <span class="n">received</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="nb">print</span> <span class="s2">&quot;Sent:     </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span> <span class="s2">&quot;Received: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">received</span><span class="p">)</span>
</pre></div>
</div>
<p>この例の出力は次のようになります:</p>
<p>Server:</p>
<div class="highlight-shell-session"><div class="highlight"><pre><span></span><span class="gp">$</span> python TCPServer.py
<span class="go">127.0.0.1 wrote:</span>
<span class="go">hello world with TCP</span>
<span class="go">127.0.0.1 wrote:</span>
<span class="go">python is nice</span>
</pre></div>
</div>
<p>Client:</p>
<div class="highlight-shell-session"><div class="highlight"><pre><span></span><span class="gp">$</span> python TCPClient.py hello world with TCP
<span class="go">Sent:     hello world with TCP</span>
<span class="go">Received: HELLO WORLD WITH TCP</span>
<span class="gp">$</span> python TCPClient.py python is nice
<span class="go">Sent:     python is nice</span>
<span class="go">Received: PYTHON IS NICE</span>
</pre></div>
</div>
</div>
<div class="section" id="socketserver-udpserver-example">
<h3>20.17.4.2. <a class="reference internal" href="#SocketServer.UDPServer" title="SocketServer.UDPServer"><code class="xref py py-class docutils literal"><span class="pre">SocketServer.UDPServer</span></code></a> の例<a class="headerlink" href="#socketserver-udpserver-example" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>サーバーサイドの例です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">SocketServer</span>

<span class="k">class</span> <span class="nc">MyUDPHandler</span><span class="p">(</span><span class="n">SocketServer</span><span class="o">.</span><span class="n">BaseRequestHandler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class works similar to the TCP handler class, except that</span>
<span class="sd">    self.request consists of a pair of data and client socket, and since</span>
<span class="sd">    there is no connection the client address must be given explicitly</span>
<span class="sd">    when sending data back via sendto().</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">socket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> wrote:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span> <span class="n">data</span>
        <span class="n">socket</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">9999</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">SocketServer</span><span class="o">.</span><span class="n">UDPServer</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">),</span> <span class="n">MyUDPHandler</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>クライアントサイドの例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">9999</span>
<span class="n">data</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

<span class="c1"># SOCK_DGRAM is the socket type to use for UDP sockets</span>
<span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span><span class="p">)</span>

<span class="c1"># As you can see, there is no connect() call; UDP has no connections.</span>
<span class="c1"># Instead, data is directly sent to the recipient via sendto().</span>
<span class="n">sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
<span class="n">received</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>

<span class="nb">print</span> <span class="s2">&quot;Sent:     </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span> <span class="s2">&quot;Received: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">received</span><span class="p">)</span>
</pre></div>
</div>
<p>この例の出力は、TCPサーバーの例と全く同じようになります。</p>
</div>
<div class="section" id="asynchronous-mixins">
<h3>20.17.4.3. 非同期処理の Mix-in<a class="headerlink" href="#asynchronous-mixins" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>複数の接続を非同期に処理するハンドラを作るには、 <a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code></a> か <a class="reference internal" href="#SocketServer.ForkingMixIn" title="SocketServer.ForkingMixIn"><code class="xref py py-class docutils literal"><span class="pre">ForkingMixIn</span></code></a> クラスを利用します。</p>
<p><a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code></a> クラスの利用例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">SocketServer</span>

<span class="k">class</span> <span class="nc">ThreadedTCPRequestHandler</span><span class="p">(</span><span class="n">SocketServer</span><span class="o">.</span><span class="n">BaseRequestHandler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
        <span class="n">cur_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">()</span>
        <span class="n">response</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cur_thread</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ThreadedTCPServer</span><span class="p">(</span><span class="n">SocketServer</span><span class="o">.</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">SocketServer</span><span class="o">.</span><span class="n">TCPServer</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">client</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
        <span class="nb">print</span> <span class="s2">&quot;Received: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Port 0 means to select an arbitrary unused port</span>
    <span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">0</span>

    <span class="n">server</span> <span class="o">=</span> <span class="n">ThreadedTCPServer</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">),</span> <span class="n">ThreadedTCPRequestHandler</span><span class="p">)</span>
    <span class="n">ip</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="n">server_address</span>

    <span class="c1"># Start a thread with the server -- that thread will then start one</span>
    <span class="c1"># more thread for each request</span>
    <span class="n">server_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">)</span>
    <span class="c1"># Exit the server thread when the main thread terminates</span>
    <span class="n">server_thread</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">server_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="nb">print</span> <span class="s2">&quot;Server loop running in thread:&quot;</span><span class="p">,</span> <span class="n">server_thread</span><span class="o">.</span><span class="n">name</span>

    <span class="n">client</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="s2">&quot;Hello World 1&quot;</span><span class="p">)</span>
    <span class="n">client</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="s2">&quot;Hello World 2&quot;</span><span class="p">)</span>
    <span class="n">client</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="s2">&quot;Hello World 3&quot;</span><span class="p">)</span>

    <span class="n">server</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
    <span class="n">server</span><span class="o">.</span><span class="n">server_close</span><span class="p">()</span>
</pre></div>
</div>
<p>この例の出力は次のようになります:</p>
<div class="highlight-shell-session"><div class="highlight"><pre><span></span><span class="gp">$</span> python ThreadedTCPServer.py
<span class="go">Server loop running in thread: Thread-1</span>
<span class="go">Received: Thread-2: Hello World 1</span>
<span class="go">Received: Thread-3: Hello World 2</span>
<span class="go">Received: Thread-4: Hello World 3</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#SocketServer.ForkingMixIn" title="SocketServer.ForkingMixIn"><code class="xref py py-class docutils literal"><span class="pre">ForkingMixIn</span></code></a> class is used in the same way, except that the server
will spawn a new process for each request.
Available only on POSIX platforms that support <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">fork()</span></code></a>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">20.17. <code class="docutils literal"><span class="pre">SocketServer</span></code> &#8212; ネットワークサーバ構築のためのフレームワーク</a><ul>
<li><a class="reference internal" href="#server-creation-notes">20.17.1. サーバ生成に関するノート</a></li>
<li><a class="reference internal" href="#server-objects">20.17.2. Serverオブジェクト</a></li>
<li><a class="reference internal" href="#request-handler-objects">20.17.3. Request Handler Objects</a></li>
<li><a class="reference internal" href="#examples">20.17.4. 例</a><ul>
<li><a class="reference internal" href="#socketserver-tcpserver-example">20.17.4.1. <code class="docutils literal"><span class="pre">SocketServer.TCPServer</span></code> の例</a></li>
<li><a class="reference internal" href="#socketserver-udpserver-example">20.17.4.2. <code class="docutils literal"><span class="pre">SocketServer.UDPServer</span></code> の例</a></li>
<li><a class="reference internal" href="#asynchronous-mixins">20.17.4.3. 非同期処理の Mix-in</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="urlparse.html"
                        title="前の章へ">20.16. <code class="docutils literal"><span class="pre">urlparse</span></code> &#8212; URL を解析して構成要素にする</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="basehttpserver.html"
                        title="次の章へ">20.18. <code class="docutils literal"><span class="pre">BaseHTTPServer</span></code> &#8212; 基本的な機能を持つ HTTP サーバ</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">バグ報告</a></li>
  <li><a href="https://github.com/python/cpython/blob/2.7/Doc/library/socketserver.rst"
         rel="nofollow">ソースの表示</a>
  </li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="basehttpserver.html" title="20.18. BaseHTTPServer — 基本的な機能を持つ HTTP サーバ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="urlparse.html" title="20.16. urlparse — URL を解析して構成要素にする"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.13</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >20. インターネットプロトコルとサポート</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト).
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    Last updated on 2017-03-20.
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>