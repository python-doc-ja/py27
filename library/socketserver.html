<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>20.17. SocketServer — ネットワークサーバ構築のためのフレームワーク &#8212; Python 2.7.x ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.x',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7.x ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7.x ドキュメント" href="../contents.html" />
    <link rel="up" title="20. インターネットプロトコルとサポート" href="internet.html" />
    <link rel="next" title="20.18. BaseHTTPServer — 基本的な機能を持つ HTTP サーバ" href="basehttpserver.html" />
    <link rel="prev" title="20.16. urlparse — URL を解析して構成要素にする" href="urlparse.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="basehttpserver.html" title="20.18. BaseHTTPServer — 基本的な機能を持つ HTTP サーバ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="urlparse.html" title="20.16. urlparse — URL を解析して構成要素にする"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.x</span>
          <a href="../index.html">Documentation</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">20. インターネットプロトコルとサポート</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-SocketServer">
<span id="socketserver-a-framework-for-network-servers"></span><h1>20.17. <a class="reference internal" href="#module-SocketServer" title="SocketServer: A framework for network servers."><code class="xref py py-mod docutils literal"><span class="pre">SocketServer</span></code></a> &#8212; ネットワークサーバ構築のためのフレームワーク<a class="headerlink" href="#module-SocketServer" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#module-SocketServer" title="SocketServer: A framework for network servers."><code class="xref py py-mod docutils literal"><span class="pre">SocketServer</span></code></a> モジュールは、Python 3 では <code class="xref py py-mod docutils literal"><span class="pre">socketserver</span></code> にリネームされました。 <a class="reference internal" href="../glossary.html#term-2to3"><span class="xref std std-term">2to3</span></a> ツールが自動的にソースコードの import を修正します。</p>
</div>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://hg.python.org/cpython/file/2.7/Lib/SocketServer.py">Lib/SocketServer.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-SocketServer" title="SocketServer: A framework for network servers."><code class="xref py py-mod docutils literal"><span class="pre">SocketServer</span></code></a> モジュールはネットワークサーバを実装するタスクを単純化します。</p>
<p>このモジュールには 4 つのサーバクラスがあります: <code class="xref py py-class docutils literal"><span class="pre">TCPServer</span></code> は、クライアントとサーバ間に継続的なデータ流路を提供する、インターネット TCP プロトコルを使います。 <code class="xref py py-class docutils literal"><span class="pre">UDPServer</span></code> は、順序通りに到着しなかったり、転送中に喪失してしまってもかまわない情報の断続的なパケットである、データグラムを使います。 <code class="xref py py-class docutils literal"><span class="pre">UnixStreamServer</span></code> および <code class="xref py py-class docutils literal"><span class="pre">UnixDatagramServer</span></code> クラスも同様ですが、Unix ドメインソケットを使います; 従って非 Unix プラットフォームでは利用できません。ネットワークプログラミングについての詳細は、W. Richard Steven 著 UNIX Network Programming や、 Ralph Davis 著 Win32 Network Programming のような書籍を参照してください。</p>
<p>これらの 4 つのクラスは要求を <em class="dfn">同期的に (synchronously)</em> 処理します; 各要求は次の要求を開始する前に完結していなければなりません。同期的な処理は、サーバで大量の計算を必要とする、あるいはクライアントが処理するには時間がかかりすぎるような大量のデータを返す、といった理由によってリクエストに長い時間がかかる状況には向いていません。こうした状況の解決方法は別のプロセスを生成するか、個々の要求を扱うスレッドを生成することです;  <code class="xref py py-class docutils literal"><span class="pre">ForkingMixIn</span></code> および <code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code> 配合クラス (mix-in classes) を使えば、非同期的な動作をサポートできます。</p>
<p>サーバの作成にはいくつかのステップがあります。最初に、 <code class="xref py py-class docutils literal"><span class="pre">BaseRequestHandler</span></code> クラスをサブクラス化して要求処理クラス (request hander class) を生成し、その <code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code> メソッドを上書きしなければなりません; このメソッドで入力される要求を処理します。次に、サーバクラスのうち一つをインスタンス化して、サーバのアドレスと要求処理クラスを渡さなければなりません。そして、サーバオブジェクトの <code class="xref py py-meth docutils literal"><span class="pre">handle_request()</span></code> または  <code class="xref py py-meth docutils literal"><span class="pre">serve_forever()</span></code> メソッドを呼び出して、単一または多数の要求を処理します。最後に、 <a class="reference internal" href="#SocketServer.BaseServer.server_close" title="SocketServer.BaseServer.server_close"><code class="xref py py-meth docutils literal"><span class="pre">server_close()</span></code></a> を呼び出してソケットを閉じます。</p>
<p><code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code> から継承してスレッドを利用した接続を行う場合、突発的な通信切断時の処理を明示的に指定する必要があります。 <code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code> クラスには <em>daemon_threads</em> 属性があり、サーバがスレッドの終了を待ち合わせるかどうかを指定する事ができます。スレッドが独自の処理を行う場合は、このフラグを明示的に指定します。デフォルトは <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> で、Pythonは <code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code> クラスが起動した全てのスレッドが終了するまで実行し続けます。</p>
<p>サーバクラス群は使用するネットワークプロトコルに関わらず、同じ外部メソッドおよび属性を持ちます。</p>
<div class="section" id="server-creation-notes">
<h2>20.17.1. サーバ生成に関するノート<a class="headerlink" href="#server-creation-notes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>継承図にある五つのクラスのうち四つは四種類の同期サーバを表わしています:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">+------------+</span>
<span class="o">|</span> <span class="n">BaseServer</span> <span class="o">|</span>
<span class="o">+------------+</span>
      <span class="o">|</span>
      <span class="n">v</span>
<span class="o">+-----------+</span>        <span class="o">+------------------+</span>
<span class="o">|</span> <span class="n">TCPServer</span> <span class="o">|-------&gt;|</span> <span class="n">UnixStreamServer</span> <span class="o">|</span>
<span class="o">+-----------+</span>        <span class="o">+------------------+</span>
      <span class="o">|</span>
      <span class="n">v</span>
<span class="o">+-----------+</span>        <span class="o">+--------------------+</span>
<span class="o">|</span> <span class="n">UDPServer</span> <span class="o">|-------&gt;|</span> <span class="n">UnixDatagramServer</span> <span class="o">|</span>
<span class="o">+-----------+</span>        <span class="o">+--------------------+</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">UnixDatagramServer</span></code> は <code class="xref py py-class docutils literal"><span class="pre">UDPServer</span></code> から派生していて、 <code class="xref py py-class docutils literal"><span class="pre">UnixStreamServer</span></code> からではないことに注意してください &#8212; IP と Unix ストリームサーバの唯一の違いはアドレスファミリーでそれは両方の Unix サーバクラスで単純に繰り返されています。</p>
<p>それぞれのタイプのサーバのフォークしたりスレッド実行したりするバージョンは <code class="xref py py-class docutils literal"><span class="pre">ForkingMixIn</span></code> および <code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code> ミクシン(mix-in)クラスを使って作ることができます。たとえば、スレッド実行する UDP サーバクラスは以下のようにして作られます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ThreadingUDPServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">UDPServer</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p>ミクシンクラスは <code class="xref py py-class docutils literal"><span class="pre">UDPServer</span></code> で定義されるメソッドをオーバライドするために、先に来なければなりません。様々な属性を設定することで元になるサーバ機構の振る舞いを変えられます。</p>
<p>サービスの実装には、 <code class="xref py py-class docutils literal"><span class="pre">BaseRequestHandler</span></code> からクラスを派生させてその <code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code> メソッドを再定義しなければなりません。このようにすれば、サーバクラスと要求処理クラスを結合して様々なバージョンのサービスを実行することができます。要求処理クラスはデータグラムサービスかストリームサービスかで異なることでしょう。この違いは処理サブクラス <code class="xref py py-class docutils literal"><span class="pre">StreamRequestHandler</span></code> または <code class="xref py py-class docutils literal"><span class="pre">DatagramRequestHandler</span></code> を使うという形で隠蔽できます。</p>
<p>もちろん、まだ頭を使わなければなりません! たとえば、サービスがリクエストによっては書き換えられるようなメモリ上の状態を使うならば、フォークするサーバを使うのは馬鹿げています。というのも子プロセスでの書き換えは親プロセスで保存されている初期状態にも親プロセスから分配される各子プロセスの状態にも届かないからです。この場合、スレッド実行するサーバを使うことはできますが、共有データの一貫性を保つためにロックを使わなければならなくなるでしょう。</p>
<p>一方、全てのデータが外部に(たとえばファイルシステムに)保存される HTTP サーバを作っているのだとすると、同期クラスではどうしても一つの要求が処理されている間サービスが「耳の聞こえない」状態を呈することになります &#8212; この状態はもしクライアントが要求した全てのデータをゆっくり受け取るととても長い時間続きかねません。こういう場合にはサーバをスレッド実行したりフォークすることが適切です。</p>
<p>ある場合には、要求の一部を同期的に処理する一方で、要求データに依って子プロセスをフォークして処理を終了させる、といった方法も適当かもしれません。こうした処理方法は同期サーバを使って要求処理クラスの <code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code> メソッドの中で自分でフォークするようにして実装することができます。</p>
<p>スレッドも <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">fork()</span></code></a> もサポートされない環境で (もしくはサービスにとってそれらがあまりに高価についたり不適切な場合に) 多数の同時要求を捌くもう一つのアプローチは、部分的に処理し終えた要求のテーブルを自分で管理し、次にどの要求に対処するか (または新しく入ってきた要求を扱うかどうか) を決めるのに <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select()</span></code></a> を使う方法です。これは (もしスレッドやサブプロセスが使えなければ) 特にストリームサービスに対して重要で、そのようなサービスでは各クライアントが潜在的に長く接続し続けます。この問題を管理する別の方法について、 <a class="reference internal" href="asyncore.html#module-asyncore" title="asyncore: A base class for developing asynchronous socket handling services."><code class="xref py py-mod docutils literal"><span class="pre">asyncore</span></code></a> モジュールを参照してください。</p>
</div>
<div class="section" id="server-objects">
<h2>20.17.2. Serverオブジェクト<a class="headerlink" href="#server-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="class">
<dt id="SocketServer.BaseServer">
<em class="property">class </em><code class="descclassname">SocketServer.</code><code class="descname">BaseServer</code><a class="headerlink" href="#SocketServer.BaseServer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これは、このモジュールにある全てのサーバーオブジェクトの基底クラスです。このクラスは、ここから説明するインタフェースを定義していますが、そのほとんどを実装していません。実装はサブクラスで行われます。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.fileno">
<code class="descclassname">BaseServer.</code><code class="descname">fileno</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.fileno" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバが要求待ちを行っているソケットのファイル記述子を整数で返します。この関数は一般的に、同じプロセス中の複数のサーバを監視できるようにするために、 <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select.select()</span></code></a> に渡されます。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.handle_request">
<code class="descclassname">BaseServer.</code><code class="descname">handle_request</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.handle_request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>単一の要求を処理します。この関数は以下のメソッド: <a class="reference internal" href="#SocketServer.BaseServer.get_request" title="SocketServer.BaseServer.get_request"><code class="xref py py-meth docutils literal"><span class="pre">get_request()</span></code></a> 、 <a class="reference internal" href="#SocketServer.BaseServer.verify_request" title="SocketServer.BaseServer.verify_request"><code class="xref py py-meth docutils literal"><span class="pre">verify_request()</span></code></a> 、および <a class="reference internal" href="#SocketServer.BaseServer.process_request" title="SocketServer.BaseServer.process_request"><code class="xref py py-meth docutils literal"><span class="pre">process_request()</span></code></a> を順番に呼び出します。ハンドラ中でユーザによって提供された <code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code> が例外を送出した場合、サーバの <a class="reference internal" href="#SocketServer.BaseServer.handle_error" title="SocketServer.BaseServer.handle_error"><code class="xref py py-meth docutils literal"><span class="pre">handle_error()</span></code></a> メソッドが呼び出されます。 <code class="xref py py-attr docutils literal"><span class="pre">self.timeout</span></code> 秒以内にリクエストが来なかった場合、 <a class="reference internal" href="#SocketServer.BaseServer.handle_timeout" title="SocketServer.BaseServer.handle_timeout"><code class="xref py py-meth docutils literal"><span class="pre">handle_timeout()</span></code></a> が呼ばれて、 <a class="reference internal" href="#SocketServer.BaseServer.handle_request" title="SocketServer.BaseServer.handle_request"><code class="xref py py-meth docutils literal"><span class="pre">handle_request()</span></code></a> が終了します。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.serve_forever">
<code class="descclassname">BaseServer.</code><code class="descname">serve_forever</code><span class="sig-paren">(</span><em>poll_interval=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.serve_forever" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#SocketServer.BaseServer.shutdown" title="SocketServer.BaseServer.shutdown"><code class="xref py py-meth docutils literal"><span class="pre">shutdown()</span></code></a> が明示的に呼ばれるまで、リクエストを処理し続けます。 shutdown が呼ばれたかどうかを、 <em>poll_interval</em> 秒ごとにポーリングします。 <code class="xref py py-attr docutils literal"><span class="pre">self.timeout</span></code> は無視されます。周期的に何かするタスクが必要であれば、それを別のスレッドで行ってください。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.shutdown">
<code class="descclassname">BaseServer.</code><code class="descname">shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.shutdown" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#SocketServer.BaseServer.serve_forever" title="SocketServer.BaseServer.serve_forever"><code class="xref py py-meth docutils literal"><span class="pre">serve_forever()</span></code></a> ループに停止するように指示し、停止されるまで待ちます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.server_close">
<code class="descclassname">BaseServer.</code><code class="descname">server_close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.server_close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバをクリーンアップします。上書き出来ます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.address_family">
<code class="descclassname">BaseServer.</code><code class="descname">address_family</code><a class="headerlink" href="#SocketServer.BaseServer.address_family" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバのソケットが属しているプロトコルファミリです。一般的な値は <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">socket.AF_INET</span></code></a> および <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">socket.AF_UNIX</span></code></a> です。</p>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.RequestHandlerClass">
<code class="descclassname">BaseServer.</code><code class="descname">RequestHandlerClass</code><a class="headerlink" href="#SocketServer.BaseServer.RequestHandlerClass" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ユーザが提供する要求処理クラスです; 要求ごとにこのクラスのインスタンスが生成されます。</p>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.server_address">
<code class="descclassname">BaseServer.</code><code class="descname">server_address</code><a class="headerlink" href="#SocketServer.BaseServer.server_address" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバが要求待ちを行うアドレスです。アドレスの形式はプロトコルファミリによって異なります。詳細は <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> モジュールを参照してください。インターネットプロトコルでは、この値は例えば <code class="docutils literal"><span class="pre">('127.0.0.1',</span> <span class="pre">80)</span></code> のようにアドレスを与える文字列と整数のポート番号を含むタプルです。</p>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.socket">
<code class="descclassname">BaseServer.</code><code class="descname">socket</code><a class="headerlink" href="#SocketServer.BaseServer.socket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバが入力の要求待ちを行うためのソケットオブジェクトです。</p>
</dd></dl>

<p>サーバクラスは以下のクラス変数をサポートします:</p>
<dl class="attribute">
<dt id="SocketServer.BaseServer.allow_reuse_address">
<code class="descclassname">BaseServer.</code><code class="descname">allow_reuse_address</code><a class="headerlink" href="#SocketServer.BaseServer.allow_reuse_address" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバがアドレスの再使用を許すかどうかを示す値です。この値は標準で <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> で、サブクラスで再使用ポリシを変更するために設定することができます。</p>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.request_queue_size">
<code class="descclassname">BaseServer.</code><code class="descname">request_queue_size</code><a class="headerlink" href="#SocketServer.BaseServer.request_queue_size" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要求待ち行列 (queue) のサイズです。単一の要求を処理するのに長時間かかる場合には、サーバが処理中に届いた要求は最大 <a class="reference internal" href="#SocketServer.BaseServer.request_queue_size" title="SocketServer.BaseServer.request_queue_size"><code class="xref py py-attr docutils literal"><span class="pre">request_queue_size</span></code></a> 個まで待ち行列に置かれます。待ち行列が一杯になると、それ以降のクライアントからの要求は &#8220;接続拒否 (Connection denied)&#8221; エラーになります。標準の値は通常 5 ですが、この値はサブクラスで上書きすることができます。</p>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.socket_type">
<code class="descclassname">BaseServer.</code><code class="descname">socket_type</code><a class="headerlink" href="#SocketServer.BaseServer.socket_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバが使うソケットの型です; 一般的な2つの値は、 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_STREAM</span></code></a> と <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_DGRAM</span></code></a> です。</p>
</dd></dl>

<dl class="attribute">
<dt id="SocketServer.BaseServer.timeout">
<code class="descclassname">BaseServer.</code><code class="descname">timeout</code><a class="headerlink" href="#SocketServer.BaseServer.timeout" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>タイムアウト時間(秒)、もしくは、タイムアウトを望まない場合に <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> 。 <a class="reference internal" href="#SocketServer.BaseServer.handle_request" title="SocketServer.BaseServer.handle_request"><code class="xref py py-meth docutils literal"><span class="pre">handle_request()</span></code></a> がこの時間内にリクエストを受信しない場合、 <a class="reference internal" href="#SocketServer.BaseServer.handle_timeout" title="SocketServer.BaseServer.handle_timeout"><code class="xref py py-meth docutils literal"><span class="pre">handle_timeout()</span></code></a> メソッドが呼ばれます。</p>
</dd></dl>

<p><code class="xref py py-class docutils literal"><span class="pre">TCPServer</span></code> のような基底クラスのサブクラスで上書きできるサーバメソッドは多数あります; これらのメソッドはサーバオブジェクトの外部のユーザにとっては役にたたないものです。</p>
<dl class="method">
<dt id="SocketServer.BaseServer.finish_request">
<code class="descclassname">BaseServer.</code><code class="descname">finish_request</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.finish_request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#SocketServer.BaseServer.RequestHandlerClass" title="SocketServer.BaseServer.RequestHandlerClass"><code class="xref py py-attr docutils literal"><span class="pre">RequestHandlerClass</span></code></a> をインスタンス化し、 <code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code> メソッドを呼び出して、実際に要求を処理します。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.get_request">
<code class="descclassname">BaseServer.</code><code class="descname">get_request</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.get_request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットから要求を受理して、クライアントとの通信に使われる <em>新しい</em> ソケットオブジェクト、およびクライアントのアドレスからなる、2 要素のタプルを返します。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.handle_error">
<code class="descclassname">BaseServer.</code><code class="descname">handle_error</code><span class="sig-paren">(</span><em>request</em>, <em>client_address</em><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.handle_error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="#SocketServer.BaseServer.RequestHandlerClass" title="SocketServer.BaseServer.RequestHandlerClass"><code class="xref py py-attr docutils literal"><span class="pre">RequestHandlerClass</span></code></a> の <code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code> メソッドが例外を送出した際に呼び出されます。標準の動作では標準出力へトレースバックを出力し、後続する要求を継続して処理します。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.handle_timeout">
<code class="descclassname">BaseServer.</code><code class="descname">handle_timeout</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.handle_timeout" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="#SocketServer.BaseServer.timeout" title="SocketServer.BaseServer.timeout"><code class="xref py py-attr docutils literal"><span class="pre">timeout</span></code></a> 属性が <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> 以外に設定されて、リクエストがないままタイムアウト秒数が過ぎたときに呼ばれます。 fork型サーバーでのデフォルトの動作は、終了した子プロセスの情報を集めるようになっています。スレッド型サーバーではこのメソッドは何もしません。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.process_request">
<code class="descclassname">BaseServer.</code><code class="descname">process_request</code><span class="sig-paren">(</span><em>request</em>, <em>client_address</em><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.process_request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#SocketServer.BaseServer.finish_request" title="SocketServer.BaseServer.finish_request"><code class="xref py py-meth docutils literal"><span class="pre">finish_request()</span></code></a> を呼び出して、 <a class="reference internal" href="#SocketServer.BaseServer.RequestHandlerClass" title="SocketServer.BaseServer.RequestHandlerClass"><code class="xref py py-attr docutils literal"><span class="pre">RequestHandlerClass</span></code></a> のインスタンスを生成します。必要なら、この関数から新たなプロセスかスレッドを生成して要求を処理することができます; その処理は <code class="xref py py-class docutils literal"><span class="pre">ForkingMixIn</span></code> または <code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code>  クラスが行います。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.server_activate">
<code class="descclassname">BaseServer.</code><code class="descname">server_activate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.server_activate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバのコンストラクタによって呼び出され、サーバを活動状態にします。デフォルトではサーバのソケットを <code class="xref py py-meth docutils literal"><span class="pre">listen()</span></code> するだけです。このメソッドは上書きできます。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.server_bind">
<code class="descclassname">BaseServer.</code><code class="descname">server_bind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.server_bind" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバのコンストラクタによって呼び出され、適切なアドレスにソケットをバインドします。このメソッドは上書きできます。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.BaseServer.verify_request">
<code class="descclassname">BaseServer.</code><code class="descname">verify_request</code><span class="sig-paren">(</span><em>request</em>, <em>client_address</em><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.BaseServer.verify_request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ブール値を返さなければなりません; 値が <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> の場合には要求が処理され、 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> の場合には要求は拒否されます。サーバへのアクセス制御を実装するためにこの関数を上書きすることができます。標準の実装では常に <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を返します。</p>
</dd></dl>

</div>
<div class="section" id="requesthandler-objects">
<h2>20.17.3. RequestHandlerオブジェクト<a class="headerlink" href="#requesthandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>要求処理クラスでは、新たな <code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code> メソッドを定義しなくてはならず、また以下のメソッドのいずれかを上書きすることができます。各要求ごとに新たなインスタンスが生成されます。</p>
<dl class="method">
<dt id="SocketServer.RequestHandler.finish">
<code class="descclassname">RequestHandler.</code><code class="descname">finish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.RequestHandler.finish" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#SocketServer.RequestHandler.handle" title="SocketServer.RequestHandler.handle"><code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code></a>   メソッドより後に呼び出され、何らかの必要なクリーンアップ処理を行います。標準の実装では何も行いません。 <a class="reference internal" href="#SocketServer.RequestHandler.setup" title="SocketServer.RequestHandler.setup"><code class="xref py py-meth docutils literal"><span class="pre">setup()</span></code></a> メソッドが例外を送出した場合、このメソッドは呼び出されません。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.RequestHandler.handle">
<code class="descclassname">RequestHandler.</code><code class="descname">handle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.RequestHandler.handle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数では、クライアントからの要求を実現するために必要な全ての作業を行わなければなりません。デフォルト実装では何もしません。この作業の上で、いくつかのインスタンス属性を利用することができます; クライアントからの要求は <code class="xref py py-attr docutils literal"><span class="pre">self.request</span></code> です; クライアントのアドレスは <code class="xref py py-attr docutils literal"><span class="pre">self.client_address</span></code> です;  そしてサーバごとの情報にアクセスする場合には、サーバインスタンスを <code class="xref py py-attr docutils literal"><span class="pre">self.server</span></code> で取得できます。</p>
<p><code class="xref py py-attr docutils literal"><span class="pre">self.request</span></code> の型はサービスがデータグラム型かストリーム型かで異なります。ストリーム型では、 <code class="xref py py-attr docutils literal"><span class="pre">self.request</span></code> はソケットオブジェクトです; データグラムサービスでは、 <code class="xref py py-attr docutils literal"><span class="pre">self.request</span></code> は文字列とソケットのタプルになります。しかし、この違いは要求処理サブクラスの <code class="xref py py-class docutils literal"><span class="pre">StreamRequestHandler</span></code> や <code class="xref py py-class docutils literal"><span class="pre">DatagramRequestHandler</span></code> を使うことで隠蔽することができます。これらのクラスでは <a class="reference internal" href="#SocketServer.RequestHandler.setup" title="SocketServer.RequestHandler.setup"><code class="xref py py-meth docutils literal"><span class="pre">setup()</span></code></a> および <a class="reference internal" href="#SocketServer.RequestHandler.finish" title="SocketServer.RequestHandler.finish"><code class="xref py py-meth docutils literal"><span class="pre">finish()</span></code></a> メソッドを上書きしており、 <code class="xref py py-attr docutils literal"><span class="pre">self.rfile</span></code> および <code class="xref py py-attr docutils literal"><span class="pre">self.wfile</span></code> 属性を提供しています。 <code class="xref py py-attr docutils literal"><span class="pre">self.rfile</span></code> および <code class="xref py py-attr docutils literal"><span class="pre">self.wfile</span></code> は、要求データを取得したりクライアントにデータを返すために、それぞれ読み出し、書き込みを行うことができます。</p>
</dd></dl>

<dl class="method">
<dt id="SocketServer.RequestHandler.setup">
<code class="descclassname">RequestHandler.</code><code class="descname">setup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SocketServer.RequestHandler.setup" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#SocketServer.RequestHandler.handle" title="SocketServer.RequestHandler.handle"><code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code></a>   メソッドより前に呼び出され、何らかの必要な初期化処理を行います。標準の実装では何も行いません。</p>
</dd></dl>

</div>
<div class="section" id="examples">
<h2>20.17.4. 例<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="socketserver-tcpserver-example">
<h3>20.17.4.1. <code class="xref py py-class docutils literal"><span class="pre">SocketServer.TCPServer</span></code> の例<a class="headerlink" href="#socketserver-tcpserver-example" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>サーバーサイドの例です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">SocketServer</span>

<span class="k">class</span> <span class="nc">MyTCPHandler</span><span class="p">(</span><span class="n">SocketServer</span><span class="o">.</span><span class="n">BaseRequestHandler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The RequestHandler class for our server.</span>

<span class="sd">    It is instantiated once per connection to the server, and must</span>
<span class="sd">    override the handle() method to implement communication to the</span>
<span class="sd">    client.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># self.request is the TCP socket connected to the client</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="nb">print</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> wrote:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="c1"># just send back the same data, but upper-cased</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">9999</span>

    <span class="c1"># Create the server, binding to localhost on port 9999</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">SocketServer</span><span class="o">.</span><span class="n">TCPServer</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">),</span> <span class="n">MyTCPHandler</span><span class="p">)</span>

    <span class="c1"># Activate the server; this will keep running until you</span>
    <span class="c1"># interrupt the program with Ctrl-C</span>
    <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>別の、ストリーム(標準のファイル型のインタフェースを利用して通信をシンプルにしたファイルライクオブジェクト)を使うリクエストハンドラクラスの例です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTCPHandler</span><span class="p">(</span><span class="n">SocketServer</span><span class="o">.</span><span class="n">StreamRequestHandler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># self.rfile is a file-like object created by the handler;</span>
        <span class="c1"># we can now use e.g. readline() instead of raw recv() calls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="nb">print</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> wrote:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="c1"># Likewise, self.wfile is a file-like object used to write back</span>
        <span class="c1"># to the client</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
</pre></div>
</div>
<p>先ほどとの違いは、<code class="docutils literal"><span class="pre">readline()</span></code> の呼び出しが、改行を受け取るまで <code class="docutils literal"><span class="pre">recv()</span></code> を複数回呼び出すことです。1回の <code class="docutils literal"><span class="pre">recv()</span></code> の呼び出しは、クライアント側から1回の <code class="docutils literal"><span class="pre">sendall()</span></code> 呼び出しで送信された分しか受け取りません。</p>
<p>クライアントサイドの例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">9999</span>
<span class="n">data</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

<span class="c1"># Create a socket (SOCK_STREAM means a TCP socket)</span>
<span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Connect to server and send data</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Receive data from the server and shut down</span>
    <span class="n">received</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="nb">print</span> <span class="s2">&quot;Sent:     </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span> <span class="s2">&quot;Received: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">received</span><span class="p">)</span>
</pre></div>
</div>
<p>この例の出力は次のようになります:</p>
<p>サーバー:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ python TCPServer.py
127.0.0.1 wrote:
hello world with TCP
127.0.0.1 wrote:
python is nice
</pre></div>
</div>
<p>クライアント:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ python TCPClient.py hello world with TCP
Sent:     hello world with TCP
Received: HELLO WORLD WITH TCP
$ python TCPClient.py python is nice
Sent:     python is nice
Received: PYTHON IS NICE
</pre></div>
</div>
</div>
<div class="section" id="socketserver-udpserver-example">
<h3>20.17.4.2. <code class="xref py py-class docutils literal"><span class="pre">SocketServer.UDPServer</span></code> の例<a class="headerlink" href="#socketserver-udpserver-example" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>サーバーサイドの例です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">SocketServer</span>

<span class="k">class</span> <span class="nc">MyUDPHandler</span><span class="p">(</span><span class="n">SocketServer</span><span class="o">.</span><span class="n">BaseRequestHandler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class works similar to the TCP handler class, except that</span>
<span class="sd">    self.request consists of a pair of data and client socket, and since</span>
<span class="sd">    there is no connection the client address must be given explicitly</span>
<span class="sd">    when sending data back via sendto().</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">socket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> wrote:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span> <span class="n">data</span>
        <span class="n">socket</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">9999</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">SocketServer</span><span class="o">.</span><span class="n">UDPServer</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">),</span> <span class="n">MyUDPHandler</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>クライアントサイドの例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">9999</span>
<span class="n">data</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

<span class="c1"># SOCK_DGRAM is the socket type to use for UDP sockets</span>
<span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span><span class="p">)</span>

<span class="c1"># As you can see, there is no connect() call; UDP has no connections.</span>
<span class="c1"># Instead, data is directly sent to the recipient via sendto().</span>
<span class="n">sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
<span class="n">received</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>

<span class="nb">print</span> <span class="s2">&quot;Sent:     </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span> <span class="s2">&quot;Received: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">received</span><span class="p">)</span>
</pre></div>
</div>
<p>この例の出力は、TCPサーバーの例と全く同じようになります。</p>
</div>
<div class="section" id="asynchronous-mixins">
<h3>20.17.4.3. 非同期処理の Mix-in<a class="headerlink" href="#asynchronous-mixins" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>複数の接続を非同期に処理するハンドラを作るには、 <code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code> か <code class="xref py py-class docutils literal"><span class="pre">ForkingMixIn</span></code> クラスを利用します。</p>
<p><code class="xref py py-class docutils literal"><span class="pre">ThreadingMixIn</span></code> クラスの利用例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">SocketServer</span>

<span class="k">class</span> <span class="nc">ThreadedTCPRequestHandler</span><span class="p">(</span><span class="n">SocketServer</span><span class="o">.</span><span class="n">BaseRequestHandler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
        <span class="n">cur_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">()</span>
        <span class="n">response</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cur_thread</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ThreadedTCPServer</span><span class="p">(</span><span class="n">SocketServer</span><span class="o">.</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">SocketServer</span><span class="o">.</span><span class="n">TCPServer</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">client</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
        <span class="nb">print</span> <span class="s2">&quot;Received: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Port 0 means to select an arbitrary unused port</span>
    <span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">0</span>

    <span class="n">server</span> <span class="o">=</span> <span class="n">ThreadedTCPServer</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">),</span> <span class="n">ThreadedTCPRequestHandler</span><span class="p">)</span>
    <span class="n">ip</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="n">server_address</span>

    <span class="c1"># Start a thread with the server -- that thread will then start one</span>
    <span class="c1"># more thread for each request</span>
    <span class="n">server_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">)</span>
    <span class="c1"># Exit the server thread when the main thread terminates</span>
    <span class="n">server_thread</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">server_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="nb">print</span> <span class="s2">&quot;Server loop running in thread:&quot;</span><span class="p">,</span> <span class="n">server_thread</span><span class="o">.</span><span class="n">name</span>

    <span class="n">client</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="s2">&quot;Hello World 1&quot;</span><span class="p">)</span>
    <span class="n">client</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="s2">&quot;Hello World 2&quot;</span><span class="p">)</span>
    <span class="n">client</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="s2">&quot;Hello World 3&quot;</span><span class="p">)</span>

    <span class="n">server</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
    <span class="n">server</span><span class="o">.</span><span class="n">server_close</span><span class="p">()</span>
</pre></div>
</div>
<p>この例の出力は次のようになります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ python ThreadedTCPServer.py
Server loop running in thread: Thread-1
Received: Thread-2: Hello World 1
Received: Thread-3: Hello World 2
Received: Thread-4: Hello World 3
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">ForkingMixIn</span></code> クラスは同じように利用することができます。この場合、サーバーはリクエスト毎に新しいプロセスを作成します。</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">20.17. <code class="docutils literal"><span class="pre">SocketServer</span></code> &#8212; ネットワークサーバ構築のためのフレームワーク</a><ul>
<li><a class="reference internal" href="#server-creation-notes">20.17.1. サーバ生成に関するノート</a></li>
<li><a class="reference internal" href="#server-objects">20.17.2. Serverオブジェクト</a></li>
<li><a class="reference internal" href="#requesthandler-objects">20.17.3. RequestHandlerオブジェクト</a></li>
<li><a class="reference internal" href="#examples">20.17.4. 例</a><ul>
<li><a class="reference internal" href="#socketserver-tcpserver-example">20.17.4.1. <code class="docutils literal"><span class="pre">SocketServer.TCPServer</span></code> の例</a></li>
<li><a class="reference internal" href="#socketserver-udpserver-example">20.17.4.2. <code class="docutils literal"><span class="pre">SocketServer.UDPServer</span></code> の例</a></li>
<li><a class="reference internal" href="#asynchronous-mixins">20.17.4.3. 非同期処理の Mix-in</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="urlparse.html"
                        title="前の章へ">20.16. <code class="docutils literal"><span class="pre">urlparse</span></code> &#8212; URL を解析して構成要素にする</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="basehttpserver.html"
                        title="次の章へ">20.18. <code class="docutils literal"><span class="pre">BaseHTTPServer</span></code> &#8212; 基本的な機能を持つ HTTP サーバ</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/socketserver.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="basehttpserver.html" title="20.18. BaseHTTPServer — 基本的な機能を持つ HTTP サーバ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="urlparse.html" title="20.16. urlparse — URL を解析して構成要素にする"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.x</span>
          <a href="../index.html">Documentation</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >20. インターネットプロトコルとサポート</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト).
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="https://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on 2017-02-08.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9.
    </div>

  </body>
</html>