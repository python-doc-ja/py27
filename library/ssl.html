<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>17.3. ssl — ソケットオブジェクトに対する TLS/SSL ラッパー &#8212; Python 2.7.13 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.13',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7.13 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 2.7.13 ドキュメント" href="../contents.html" />
    <link rel="up" title="17. プロセス間通信とネットワーク" href="ipc.html" />
    <link rel="next" title="17.4. signal — 非同期イベントにハンドラを設定する" href="signal.html" />
    <link rel="prev" title="17.2. socket — 低レベルネットワークインターフェース" href="socket.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/ssl.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="signal.html" title="17.4. signal — 非同期イベントにハンドラを設定する"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="socket.html" title="17.2. socket — 低レベルネットワークインターフェース"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.13</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" accesskey="U">17. プロセス間通信とネットワーク</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-ssl">
<span id="ssl-tls-ssl-wrapper-for-socket-objects"></span><h1>17.3. <a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal"><span class="pre">ssl</span></code></a> &#8212; ソケットオブジェクトに対する TLS/SSL ラッパー<a class="headerlink" href="#module-ssl" title="このヘッドラインへのパーマリンク">¶</a></h1>
<span class="target" id="index-0"></span><div class="versionadded" id="index-1">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/2.7/Lib/ssl.py">Lib/ssl.py</a></p>
<hr class="docutils" />
<p>このモジュールは Transport Layer Security (よく &#8220;Secure Sockets Layer&#8221; という名前で知られています) 暗号化と、クライアントサイド、サーバーサイド両方のネットワークソケットのためのピア認証の仕組みを提供しています。このモジュールはOpenSSLライブラリを利用しています。OpenSSLは、全てのモダンなUnixシステム、Windows、Mac OS X、その他幾つかの OpenSSLがインストールされているプラットフォームで利用できます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">OSのソケットAPIに対して実装されているので、幾つかの挙動はプラットフォーム依存になるかもしれません。インストールされているOpenSSLのバージョンの違いも挙動の違いの原因になるかもしれません。例えば、TLSv1.1, TLSv1.2 は openssl version 1.0.1 以降でのみ利用出来ます。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last"><a class="reference internal" href="#ssl-security"><span class="std std-ref">セキュリティで考慮すべき点</span></a> を読まずにこのモジュールを使用しないでください。SSL のデフォルト設定はアプリケーションに十分ではないので、読まない場合はセキュリティに誤った意識を持ってしまうかもしれません。</p>
</div>
<p>このセクションでは、 <code class="docutils literal"><span class="pre">ssl</span></code> モジュールのオブジェクトと関数の解説します。 TLS, SSL, certificates に関するより一般的な情報は、末尾にある &#8220;See Also&#8221; のセクションを参照してください。</p>
<p>このモジュールは1つのクラス、 <code class="xref py py-class docutils literal"><span class="pre">ssl.SSLSocket</span></code> を提供します。このクラスは <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> クラスを継承していて、ソケットで通信されるデータをSSLで暗号化・復号するソケットに似たラッパーになります。また、このクラスは追加で、接続の相手側からの証明書を取得する <code class="xref py py-meth docutils literal"><span class="pre">getpeercert()</span></code> メソッド、セキュア接続で使うための暗号方式を取得する <code class="xref py py-meth docutils literal"><span class="pre">cipher()</span></code> のようなメソッドをサポートしています。</p>
<p>より洗練されたアプリケーションのために、 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">ssl.SSLContext</span></code></a> クラスが設定と証明書の管理の助けとなるでしょう。それは <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></code></a> メソッドを通して SSL ソケットを作成することで引き継がれます。</p>
<div class="section" id="functions-constants-and-exceptions">
<h2>17.3.1. 関数、定数、例外<a class="headerlink" href="#functions-constants-and-exceptions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="exception">
<dt id="ssl.SSLError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLError</code><a class="headerlink" href="#ssl.SSLError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>(現在のところ OpenSSL ライブラリによって提供されている)下層の SSL 実装からのエラーを伝えるための例外です。このエラーは、低レベルなネットワークの上に載っている、高レベルな暗号化と認証レイヤーでの問題を通知します。このエラーは <a class="reference internal" href="socket.html#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">socket.error</span></code></a> のサブタイプで、 <a class="reference internal" href="socket.html#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">socket.error</span></code></a> は <a class="reference internal" href="exceptions.html#exceptions.IOError" title="exceptions.IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a> のサブタイプです。 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> インスタンスのエラーコードとメッセージは OpenSSL ライブラリによるものです。</p>
<dl class="attribute">
<dt id="ssl.SSLError.library">
<code class="descname">library</code><a class="headerlink" href="#ssl.SSLError.library" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>エラーが起こった OpenSSL サブモジュールを示すニーモニック文字列で、 <code class="docutils literal"><span class="pre">SSL</span></code>, <code class="docutils literal"><span class="pre">PEM</span></code>, <code class="docutils literal"><span class="pre">X509</span></code> などです。取り得る値は OpenSSL のバージョンに依存します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLError.reason">
<code class="descname">reason</code><a class="headerlink" href="#ssl.SSLError.reason" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>エラーが起こった原因を示すニーモニック文字列で、 <code class="docutils literal"><span class="pre">CERTIFICATE_VERIFY_FAILED</span></code> などです。取り得る値は OpenSSL のバージョンに依存します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ssl.SSLZeroReturnError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLZeroReturnError</code><a class="headerlink" href="#ssl.SSLZeroReturnError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>読み出しあるいは書き込みを試みようとした際に SSL コネクションが行儀よく閉じられてしまった場合に送出される <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> サブクラス例外です。これは下層の転送(read TCP)が閉じたことは意味しないことに注意してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLWantReadError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLWantReadError</code><a class="headerlink" href="#ssl.SSLWantReadError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>読み出しあるいは書き込みを試みようとした際に、リクエストが遂行される前に下層の TCP 転送で受け取る必要があるデータが不足した場合に <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">non-blocking SSL socket</span></a> によって送出される <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> サブクラス例外です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLWantWriteError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLWantWriteError</code><a class="headerlink" href="#ssl.SSLWantWriteError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>読み出しあるいは書き込みを試みようとした際に、リクエストが遂行される前に下層の TCP 転送が送信する必要があるデータが不足した場合に <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">non-blocking SSL socket</span></a> によって送出される <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> サブクラス例外です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLSyscallError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLSyscallError</code><a class="headerlink" href="#ssl.SSLSyscallError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL ソケット上で操作を遂行しようとしていてシステムエラーが起こった場合に送出される <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> サブクラス例外です。残念ながら元となった errno 番号を調べる簡単な方法はありません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLEOFError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLEOFError</code><a class="headerlink" href="#ssl.SSLEOFError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL コネクションが唐突に打ち切られた際に送出される <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> サブクラス例外です。一般的に、このエラーが起こったら下層の転送を再利用しようと試みるべきではありません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.CertificateError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">CertificateError</code><a class="headerlink" href="#ssl.CertificateError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>証明書のエラー(ホスト名のミスマッチのような)を通知するために送出されます。ただし、OpenSSL によって検出された場合の証明書エラーは <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> です。</p>
</dd></dl>

<div class="section" id="socket-creation">
<h3>17.3.1.1. ソケットの作成<a class="headerlink" href="#socket-creation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下に示す関数は、スタンドアロンでソケットを作りたい場合に使います。Python 2.7.9 からは、これよりもっと柔軟な <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></code></a> が使えます。</p>
<dl class="function">
<dt id="ssl.wrap_socket">
<code class="descclassname">ssl.</code><code class="descname">wrap_socket</code><span class="sig-paren">(</span><em>sock</em>, <em>keyfile=None</em>, <em>certfile=None</em>, <em>server_side=False</em>, <em>cert_reqs=CERT_NONE</em>, <em>ssl_version={see docs}</em>, <em>ca_certs=None</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em>, <em>ciphers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.wrap_socket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> のインスタンス <code class="docutils literal"><span class="pre">sock</span></code> を受け取り、 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> のサブタイプである <code class="xref py py-class docutils literal"><span class="pre">ssl.SSLSocket</span></code> のインスタンスを返します。 <code class="xref py py-class docutils literal"><span class="pre">ssl.SSLSocket</span></code> は低レイヤのソケットをSSLコンテキストでラップします。 <code class="docutils literal"><span class="pre">sock</span></code> は <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal"><span class="pre">SOCK_STREAM</span></code></a> ソケットでなければなりません; ほかのタイプのソケットはサポートされていません。</p>
<p>クライアントサイドソケットにおいて、コンテキストの生成は遅延されます。つまり、低レイヤのソケットがまだ接続されていない場合、コンテキストの生成はそのソケットの <code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code> メソッドが呼ばれた後に行われます。サーバーサイドソケットの場合、そのソケットに接続先が居なければそれは listen 用ソケットだと判断されます。 <code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code> メソッドで生成されるクライアント接続に対してのサーバーサイド SSLラップは自動的に行われます。 <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> は <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> を送出することがあります。</p>
<p>オプションの <code class="docutils literal"><span class="pre">keyfile</span></code> と <code class="docutils literal"><span class="pre">certfile</span></code> 引数は、接続のこちら側を識別するために利用される証明書を含むファイルを指定します。証明書がどのように <code class="docutils literal"><span class="pre">certfile</span></code> に格納されるかについてのより詳しい情報は、 <a class="reference internal" href="#ssl-certificates"><span class="std std-ref">証明書</span></a> を参照してください。</p>
<p><code class="docutils literal"><span class="pre">server_side</span></code> 引数は真偽値で、このソケットがサーバーサイドとクライアントサイドのどちらの動作をするのかを指定します。</p>
<p><code class="docutils literal"><span class="pre">cert_reqs</span></code> 引数は、接続の相手側からの証明書を必要とするかどうかと、それを検証(validate)するかどうかを指定します。これは次の3つの定数のどれかで無ければなりません: <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></code></a> (証明書は無視されます), <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal"><span class="pre">CERT_OPTIONAL</span></code></a> (必要としないが、提供された場合は検証する), <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></code></a> (証明書を必要とし、検証する)。もしこの引数が <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></code></a> 以外だった場合、 <code class="docutils literal"><span class="pre">ca_certs</span></code> 引数はCA証明書ファイルを指定していなければなりません。</p>
<p><code class="docutils literal"><span class="pre">ca_certs</span></code> ファイルは、接続の相手側から渡された証明書を検証するために使う、一連のCA証明書を結合したものを含んでいます。このファイル内にどう証明書を並べるかについての詳しい情報は <a class="reference internal" href="#ssl-certificates"><span class="std std-ref">証明書</span></a> を参照してください。</p>
<p><code class="docutils literal"><span class="pre">ssl_version</span></code> 引数は、使用するSSLプロトコルのバージョンを指定します。通常、サーバー側が特定のプロトコルバージョンを選び、クライアント側はサーバーの選んだプロトコルを受け入れなければなりません。ほとんどのバージョンは他のバージョンと互換性がありません。もしこの引数が指定されなかった場合、デフォルトは <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-data docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a> になります。このバージョンは、できるだけの互換性を確保するように選ばれています。</p>
<p>次のテーブルは、どのクライアント側のバージョンがどのサーバー側のバージョンに接続できるかを示しています:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="11%" />
<col width="11%" />
<col width="12%" />
<col width="11%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><em>client</em> / <strong>server</strong></td>
<td><strong>SSLv2</strong></td>
<td><strong>SSLv3</strong></td>
<td><strong>SSLv23</strong></td>
<td><strong>TLSv1</strong></td>
<td><strong>TLSv1.1</strong></td>
<td><strong>TLSv1.2</strong></td>
</tr>
<tr class="row-even"><td><em>SSLv2</em></td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr class="row-odd"><td><em>SSLv3</em></td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr class="row-even"><td><em>SSLv23</em></td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr class="row-odd"><td><em>TLSv1</em></td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr class="row-even"><td><em>TLSv1.1</em></td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr class="row-odd"><td><em>TLSv1.2</em></td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">どの接続が成功するかは、 OpenSSL のバージョンに依存して大きく変わります。例えば、OpenSSL 1.0.0 以前は、SSLv23 クライアントは常に SSLv2 接続を試みていました。</p>
</div>
<p><em>ciphers</em> 引数はこの SSL オブジェクトで利用可能な暗号化アルゴリズム群を指定します。これは、 <a class="reference external" href="https://www.openssl.org/docs/apps/ciphers.html#CIPHER-LIST-FORMAT">OpenSSL cipher list format</a> 形式で書かれた文字列でなければなりません。</p>
<p><code class="docutils literal"><span class="pre">do_handshake_on_connect</span></code> 引数は、 <code class="xref py py-meth docutils literal"><span class="pre">socket.connect()</span></code> の後に自動的に SSLハンドシェイクを行うか、それともアプリケーションが明示的に <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.do_handshake()</span></code></a> メソッドを実行するかを指定します。 <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.do_handshake()</span></code></a> を明示的に呼びだすことで、ハンドシェイクによるソケットI/Oのブロッキング動作を制御できます。</p>
<p><code class="docutils literal"><span class="pre">suppress_ragged_eofs</span></code> 引数は、 <code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.read()</span></code> メソッドが、接続先から予期しないEOF を受け取った時に通知する方法を指定します。 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> (デフォルト) の場合、下位のソケットレイヤーから予期せぬEOFエラーが来た場合、通常のEOF (空のバイト列オブジェクト)を返します。 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> の場合、呼び出し元に例外を投げて通知します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span>新しいオプション引数 <em>ciphers</em></p>
</div>
</dd></dl>

</div>
<div class="section" id="context-creation">
<h3>17.3.1.2. コンテキストの作成<a class="headerlink" href="#context-creation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>コンビニエンス関数が、共通の目的で使用される <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> オブジェクトを作成するのに役立ちます。</p>
<dl class="function">
<dt id="ssl.create_default_context">
<code class="descclassname">ssl.</code><code class="descname">create_default_context</code><span class="sig-paren">(</span><em>purpose=Purpose.SERVER_AUTH</em>, <em>cafile=None</em>, <em>capath=None</em>, <em>cadata=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.create_default_context" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新規の <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> オブジェクトを、与えられた <em>purpose</em> のデフォルト設定で返します。設定は <a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal"><span class="pre">ssl</span></code></a> モジュールで選択され、通常は <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> のコンストラクタを直接呼び出すよりも高いセキュリティレベルを表現します。</p>
<p><em>cafile</em>, <em>capath</em>, <em>cadata</em> は証明書の検証で信用するオプションの CA 証明書で、 <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_verify_locations()</span></code></a> のものと同じです。これら 3 つ全てが <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> であれば、この関数は代わりにシステムのデフォルトの CA 証明書を信用して選択することが出来ます。</p>
<p>これで作られる設定はこのようになります: RC4 を除く、高レベルで、未認証のものを含まない暗号化一式と <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-data docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a>, <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal"><span class="pre">OP_NO_SSLv2</span></code></a>, <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal"><span class="pre">OP_NO_SSLv3</span></code></a> 。 <em>purpose</em> に <a class="reference internal" href="#ssl.Purpose.SERVER_AUTH" title="ssl.Purpose.SERVER_AUTH"><code class="xref py py-data docutils literal"><span class="pre">SERVER_AUTH</span></code></a> を渡すと、 <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-data docutils literal"><span class="pre">verify_mode</span></code></a> には <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal"><span class="pre">CERT_REQUIRED</span></code></a> がセットされ、(<em>cafile</em>, <em>capath</em>, <em>cadata</em> のいずれかが与えられれば) CA 証明書がロードされるかまたはデフォルトの CA 証明書をロードするために <a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_default_certs()</span></code></a> が使われます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>プロトコル、オプション、暗号その他設定はもっと制限された、過去の廃れたものを含まない値にいつでも出来るでしょう。この値は互換性と安全性の公平なバランスを表明しています。</p>
<p class="last">もしもあなたのアプリケーションがそのような設定を必要とするのであれば、 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> を作ってあなた自身の設定を適用すべきです。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>ある種の古いクライアントやサーバが接続しようと試みてきた場合に、この関数で作られた <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> が &#8220;Protocol or cipher suite mismatch&#8221; で始まるエラーを起こすのを目撃したらそれは、この関数が <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal"><span class="pre">OP_NO_SSLv3</span></code></a> を使って除外している SSL 3.0 しかサポートしていないのでしょう。SSL 3.0 は <a class="reference external" href="https://en.wikipedia.org/wiki/POODLE">完璧にぶっ壊れている</a> ことが広く知られています。それでもまだこの関数を使って、ただし SSL 3.0 接続を許可したいと望むならば、これをこのように再有効化出来ます:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">(</span><span class="n">Purpose</span><span class="o">.</span><span class="n">CLIENT_AUTH</span><span class="p">)</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ssl</span><span class="o">.</span><span class="n">OP_NO_SSLv3</span>
</pre></div>
</div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7.10 で変更: </span>デフォルトの暗号設定から RC4 が除かれました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7.13 で変更: </span>ChaCha20/Poly1305 was added to the default cipher string.</p>
<p>3DES was dropped from the default cipher string.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl._https_verify_certificates">
<code class="descclassname">ssl.</code><code class="descname">_https_verify_certificates</code><span class="sig-paren">(</span><em>enable=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl._https_verify_certificates" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Specifies whether or not server certificates are verified when creating
client HTTPS connections without specifying a particular SSL context.</p>
<p>Starting with Python 2.7.9, <a class="reference internal" href="httplib.html#module-httplib" title="httplib: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">httplib</span></code></a> and modules which use it, such as
<a class="reference internal" href="urllib2.html#module-urllib2" title="urllib2: Next generation URL opening library."><code class="xref py py-mod docutils literal"><span class="pre">urllib2</span></code></a> and <a class="reference internal" href="xmlrpclib.html#module-xmlrpclib" title="xmlrpclib: XML-RPC client access."><code class="xref py py-mod docutils literal"><span class="pre">xmlrpclib</span></code></a>, default to verifying remote server
certificates received when establishing client HTTPS connections. This
default verification checks that the certificate is signed by a Certificate
Authority in the system trust store and that the Common Name (or Subject
Alternate Name) on the presented certificate matches the requested host.</p>
<p>Setting <em>enable</em> to <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> ensures this default behaviour is in
effect.</p>
<p>Setting <em>enable</em> to <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> reverts the default HTTPS certificate
handling to that of Python 2.7.8 and earlier, allowing connections to
servers using self-signed certificates, servers using certificates signed
by a Certicate Authority not present in the system trust store, and servers
where the hostname does not match the presented server certificate.</p>
<p>The leading underscore on this function denotes that it intentionally does
not exist in any implementation of Python 3 and may not be present in all
Python 2.7 implementations. The portable approach to bypassing certificate
checks or the system trust store when necessary is for tools to enable that
on a case-by-case basis by explicitly passing in a suitably configured SSL
context, rather than reverting the default behaviour of the standard library
client modules.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.12 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<ul class="last simple">
<li><a class="reference external" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9365">CVE-2014-9365</a>
&#8211; HTTPS man-in-the-middle attack against Python clients using default settings</li>
<li><span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0476"><strong>PEP 476</strong></a> &#8211; Enabling certificate verification by default for HTTPS</li>
<li><span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0493"><strong>PEP 493</strong></a> &#8211; HTTPS verification migration tools for Python 2.7</li>
</ul>
</div>
</dd></dl>

</div>
<div class="section" id="random-generation">
<h3>17.3.1.3. 乱数生成<a class="headerlink" href="#random-generation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<blockquote>
<div><div class="deprecated">
<p><span class="versionmodified">バージョン 2.7.13 で撤廃: </span>OpenSSL has deprecated <code class="xref py py-func docutils literal"><span class="pre">ssl.RAND_pseudo_bytes()</span></code>, use
<code class="xref py py-func docutils literal"><span class="pre">ssl.RAND_bytes()</span></code> instead.</p>
</div>
</div></blockquote>
<dl class="function">
<dt id="ssl.RAND_status">
<code class="descclassname">ssl.</code><code class="descname">RAND_status</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_status" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL 擬似乱数生成器が十分なランダム性(randomness)を受け取っている時に <code class="docutils literal"><span class="pre">True</span></code> を、それ以外の場合は <cite>False</cite> を返します。 <a class="reference internal" href="#ssl.RAND_egd" title="ssl.RAND_egd"><code class="xref py py-func docutils literal"><span class="pre">ssl.RAND_egd()</span></code></a> と <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal"><span class="pre">ssl.RAND_add()</span></code></a> を使って擬似乱数生成機にランダム性を加えることができます。</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_egd">
<code class="descclassname">ssl.</code><code class="descname">RAND_egd</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_egd" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>もしエントロピー収集デーモン(EGD=entropy-gathering daemon)が動いていて、 <em>path</em> がEGDへのソケットのパスだった場合、この関数はそのソケットから 256バイトのランダム性を読み込み、SSL擬似乱数生成器にそれを渡すことで、生成される暗号鍵のセキュリティを向上させることができます。これは、より良いランダム性のソースが無いシステムでのみ必要です。</p>
<p>エントロピー収集デーモンについては、 <a class="reference external" href="http://egd.sourceforge.net/">http://egd.sourceforge.net/</a> や <a class="reference external" href="http://prngd.sourceforge.net/">http://prngd.sourceforge.net/</a> を参照してください。</p>
<p>Availability: not available with LibreSSL and OpenSSL &gt; 1.1.0</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_add">
<code class="descclassname">ssl.</code><code class="descname">RAND_add</code><span class="sig-paren">(</span><em>bytes</em>, <em>entropy</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_add" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた <em>bytes</em> をSSL擬似乱数生成器に混ぜます。 <em>entropy</em> 引数(float値)は、その文字列に含まれるエントロピーの下限(lower bound)です。 (なので、いつでも <code class="xref py py-const docutils literal"><span class="pre">0.0</span></code> を使うことができます。) エントロピーのソースについてのより詳しい情報は、 <span class="target" id="index-30"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1750.html"><strong>RFC 1750</strong></a> を参照してください。</p>
</dd></dl>

</div>
<div class="section" id="certificate-handling">
<h3>17.3.1.4. 証明書の取り扱い<a class="headerlink" href="#certificate-handling" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="function">
<dt id="ssl.match_hostname">
<code class="descclassname">ssl.</code><code class="descname">match_hostname</code><span class="sig-paren">(</span><em>cert</em>, <em>hostname</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.match_hostname" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>(<a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.getpeercert()</span></code></a> が返してきたようなデコードされたフォーマットの) <em>cert</em> が、与えられた <em>hostname</em> に合致するかを検証します。HTTPS サーバの身元をチェックするために適用されるルールは <span class="target" id="index-31"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2818.html"><strong>RFC 2818</strong></a>, <span class="target" id="index-32"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6125.html"><strong>RFC 6125</strong></a> で概説されているものです。ただし IP アドレスによるものは現在サポートされていません。HTTPS に加え、この関数は他の SSL ベースのプロトコル、例えば FTPS, IMAPS, POPS などのサーバの身元をチェックするのに相応しいはずです。</p>
<p>失敗すれば <a class="reference internal" href="#ssl.CertificateError" title="ssl.CertificateError"><code class="xref py py-exc docutils literal"><span class="pre">CertificateError</span></code></a> が送出されます。成功すれば、この関数は何も返しません:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cert</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span> <span class="s1">&#39;example.com&#39;</span><span class="p">),),)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s2">&quot;example.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s2">&quot;example.org&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/home/py3k/Lib/ssl.py&quot;</span>, line <span class="m">130</span>, in <span class="n">match_hostname</span>
<span class="gr">ssl.CertificateError</span>: <span class="n">hostname &#39;example.org&#39; doesn&#39;t match &#39;example.com&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.cert_time_to_seconds">
<code class="descclassname">ssl.</code><code class="descname">cert_time_to_seconds</code><span class="sig-paren">(</span><em>cert_time</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.cert_time_to_seconds" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">cert_time</span></code> として証明書内の &#8220;notBefore&#8221; や &#8220;notAfter&#8221; の <code class="docutils literal"><span class="pre">&quot;%b</span> <span class="pre">%d</span> <span class="pre">%H:%M:%S</span> <span class="pre">%Y</span> <span class="pre">%Z&quot;</span></code> strptime フォーマット (C locale) 日付を渡すと、エポックからの積算秒を返します。</p>
<p>例です。 :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">cert_time_to_seconds</span><span class="p">(</span><span class="s2">&quot;Jan  5 09:34:43 2018 GMT&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span>
<span class="go">1515144883</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))</span>
<span class="go">2018-01-05 09:34:43</span>
</pre></div>
</div>
<p>&#8220;notBefore&#8221; や &#8220;notAfter&#8221; の日付には GMT を使わなければなりません(<span class="target" id="index-33"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5280.html"><strong>RFC 5280</strong></a>)。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7.9 で変更: </span>入力文字列に指定された &#8216;GMT&#8217; タイムゾーンを UTC として解釈するようになりました。以前はローカルタイムで解釈していました。また、整数を返すようになりました(入力に含まれる秒の端数を含まない)。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.get_server_certificate">
<code class="descclassname">ssl.</code><code class="descname">get_server_certificate</code><span class="sig-paren">(</span><em>addr</em>, <em>ssl_version=PROTOCOL_SSLv23</em>, <em>ca_certs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.get_server_certificate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSLで保護されたサーバーのアドレス <code class="docutils literal"><span class="pre">addr</span></code> を (<em>hostname</em>, <em>port-number</em>) の形で受け取り、そのサーバーから証明書を取得し、それを PEMエンコードされた文字列として返します。 <code class="docutils literal"><span class="pre">ssl_version</span></code> が指定された場合は、サーバーに接続を試みるときにそのバージョンのSSLプロトコルを利用します。 <code class="docutils literal"><span class="pre">ca_certs</span></code> が指定された場合、それは <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> の同名の引数と同じフォーマットで、ルート証明書のリストを含むファイルでなければなりません。この関数はサーバー証明書をルート証明書リストに対して認証し、認証が失敗した場合にこの関数も失敗します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7.9 で変更: </span>この関数は IPv6 互換になりました。 <em>ssl_version</em> のデフォルトが、最近のサーバへの最大限の互換性のために <a class="reference internal" href="#ssl.PROTOCOL_SSLv3" title="ssl.PROTOCOL_SSLv3"><code class="xref py py-data docutils literal"><span class="pre">PROTOCOL_SSLv3</span></code></a> から <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-data docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a> に変更されました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.DER_cert_to_PEM_cert">
<code class="descclassname">ssl.</code><code class="descname">DER_cert_to_PEM_cert</code><span class="sig-paren">(</span><em>DER_cert_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.DER_cert_to_PEM_cert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>DERエンコードされたバイト列として与えられた証明書から、 PEMエンコードされたバージョンの同じ証明書を返します。</p>
</dd></dl>

<dl class="function">
<dt id="ssl.PEM_cert_to_DER_cert">
<code class="descclassname">ssl.</code><code class="descname">PEM_cert_to_DER_cert</code><span class="sig-paren">(</span><em>PEM_cert_string</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.PEM_cert_to_DER_cert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>PEM 形式のASCII文字列として与えられた証明書から、同じ証明書をDERエンコードしたバイト列を返します。</p>
</dd></dl>

<dl class="function">
<dt id="ssl.get_default_verify_paths">
<code class="descclassname">ssl.</code><code class="descname">get_default_verify_paths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.get_default_verify_paths" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>OpenSSL デフォルトの cafile, capath を指すパスを名前付きタプルで返します。パスは <a class="reference internal" href="#ssl.SSLContext.set_default_verify_paths" title="ssl.SSLContext.set_default_verify_paths"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.set_default_verify_paths()</span></code></a> で使われるものと同じです。戻り値は <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> <code class="docutils literal"><span class="pre">DefaultVerifyPaths</span></code> です:</p>
<ul class="simple">
<li><code class="xref py py-attr docutils literal"><span class="pre">cafile</span></code> - resolved path to cafile or <code class="docutils literal"><span class="pre">None</span></code> if the file doesn&#8217;t exist,</li>
<li><code class="xref py py-attr docutils literal"><span class="pre">capath</span></code> - resolved path to capath or <code class="docutils literal"><span class="pre">None</span></code> if the directory doesn&#8217;t exist,</li>
<li><p class="first"><code class="xref py py-attr docutils literal"><span class="pre">openssl_cafile_env</span></code> - cafile を指す OpenSSL の環境変数</p>
</li>
<li><p class="first"><code class="xref py py-attr docutils literal"><span class="pre">openssl_cafile</span></code> - OpenSSL にハードコードされた cafile のパス</p>
</li>
<li><p class="first"><code class="xref py py-attr docutils literal"><span class="pre">openssl_capath_env</span></code> - capath を指す OpenSSL の環境変数</p>
</li>
<li><p class="first"><code class="xref py py-attr docutils literal"><span class="pre">openssl_capath</span></code> - OpenSSL にハードコードされた capath のパス</p>
</li>
</ul>
<p>Availability: LibreSSL ignores the environment vars
<code class="xref py py-attr docutils literal"><span class="pre">openssl_cafile_env</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">openssl_capath_env</span></code></p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.enum_certificates">
<code class="descclassname">ssl.</code><code class="descname">enum_certificates</code><span class="sig-paren">(</span><em>store_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.enum_certificates" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows のシステム証明書ストアより証明書を抽出します。 <em>store_name</em> は <code class="docutils literal"><span class="pre">CA</span></code>, <code class="docutils literal"><span class="pre">ROOT</span></code>, <code class="docutils literal"><span class="pre">MY</span></code> のうちどれか一つでしょう。Windows は追加の証明書ストアを提供しているかもしれません。</p>
<p>この関数はタプル (cert_bytes, encoding_type, trust) のリストで返します。encoding_type は cert_bytes のエンコーディングを表します。X.509 ASN.1 に対する <code class="xref py py-const docutils literal"><span class="pre">x509_asn</span></code> か PKCS#7 ASN.1 データに対する <code class="xref py py-const docutils literal"><span class="pre">pkcs_7_asn</span></code> のいずれかです。trust は、証明書の目的を、OIDS を内容に持つ set として表すか、または証明書が全ての目的で信頼出来るならば <code class="docutils literal"><span class="pre">True</span></code> です。</p>
<p>例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">enum_certificates</span><span class="p">(</span><span class="s2">&quot;CA&quot;</span><span class="p">)</span>
<span class="go">[(b&#39;data...&#39;, &#39;x509_asn&#39;, {&#39;1.3.6.1.5.5.7.3.1&#39;, &#39;1.3.6.1.5.5.7.3.2&#39;}),</span>
<span class="go"> (b&#39;data...&#39;, &#39;x509_asn&#39;, True)]</span>
</pre></div>
</div>
<p>利用出来る環境: Windows.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.enum_crls">
<code class="descclassname">ssl.</code><code class="descname">enum_crls</code><span class="sig-paren">(</span><em>store_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.enum_crls" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows のシステム証明書ストアより CRLs を抽出します。 <em>store_name</em> は <code class="docutils literal"><span class="pre">CA</span></code>, <code class="docutils literal"><span class="pre">ROOT</span></code>, <code class="docutils literal"><span class="pre">MY</span></code> のうちどれか一つでしょう。Windows は追加の証明書ストアを提供しているかもしれません。</p>
<p>この関数はタプル (cert_bytes, encoding_type, trust) のリストで返します。encoding_type は cert_bytes のエンコーディングを表します。X.509 ASN.1 に対する <code class="xref py py-const docutils literal"><span class="pre">x509_asn</span></code> か PKCS#7 ASN.1 データに対する <code class="xref py py-const docutils literal"><span class="pre">pkcs_7_asn</span></code> のいずれかです。</p>
<p>利用出来る環境: Windows.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="constants">
<h3>17.3.1.5. 定数<a class="headerlink" href="#constants" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="data">
<dt id="ssl.CERT_NONE">
<code class="descclassname">ssl.</code><code class="descname">CERT_NONE</code><a class="headerlink" href="#ssl.CERT_NONE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_mode</span></code></a> または <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> の <code class="docutils literal"><span class="pre">cert_reqs</span></code> パラメータに使用する値です。このモード(これがデフォルトです)では、ソケット接続先からの証明書やその認証を必要としません。接続先から証明書を受け取っても検証は試みられません。</p>
<p>このドキュメントの下の方の、 <a class="reference internal" href="#ssl-security"><span class="std std-ref">セキュリティで考慮すべき点</span></a> に関する議論を参照してください。</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_OPTIONAL">
<code class="descclassname">ssl.</code><code class="descname">CERT_OPTIONAL</code><a class="headerlink" href="#ssl.CERT_OPTIONAL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_mode</span></code></a> または <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> の <code class="docutils literal"><span class="pre">cert_reqs</span></code> パラメータに使用する値です。このモードでは、ソケット接続先からの証明書やその認証を必要としませんが、証明書が提供されれば検証が試みられ、検証失敗時には <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal"><span class="pre">SSLError</span></code></a> が送出されます。</p>
<p>この設定では、正当なCA証明書のセットを <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_verify_locations()</span></code></a> または <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> の <code class="docutils literal"><span class="pre">ca_certs</span></code> パラメータのどちらかに渡す必要があります。</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_REQUIRED">
<code class="descclassname">ssl.</code><code class="descname">CERT_REQUIRED</code><a class="headerlink" href="#ssl.CERT_REQUIRED" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_mode</span></code></a> または <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> の <code class="docutils literal"><span class="pre">cert_reqs</span></code> パラメータに使用する値です。このモードでは、ソケット接続先からの証明書やその認証を必要とされ、証明書が提供されないかその検証失敗時には <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal"><span class="pre">SSLError</span></code></a> が送出されます。</p>
<p>この設定では、正当なCA証明書のセットを <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_verify_locations()</span></code></a> または <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> の <code class="docutils literal"><span class="pre">ca_certs</span></code> パラメータのどちらかに渡す必要があります。</p>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_DEFAULT">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_DEFAULT</code><a class="headerlink" href="#ssl.VERIFY_DEFAULT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値です。このモードでは、証明書失効リスト(CRLs)はチェックされません。デフォルトでは OpenSSL は CRLs を必要ともしませんし検証にも使いません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_CRL_CHECK_LEAF">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_CRL_CHECK_LEAF</code><a class="headerlink" href="#ssl.VERIFY_CRL_CHECK_LEAF" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値です。このモードでは、接続先の証明書のチェックのみで仲介の CA 証明書はチェックしません。接続先証明書の発行者(その CA の直接の祖先)によって署名された妥当な CRL が必要です。 <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.load_verify_locations</span></code></a> が相応しいものをロードしていなければ、検証は失敗するでしょう。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_CRL_CHECK_CHAIN">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_CRL_CHECK_CHAIN</code><a class="headerlink" href="#ssl.VERIFY_CRL_CHECK_CHAIN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値です。このモードでは、接続先の証明書チェイン内の全ての証明書についての CRLs がチェックされます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_X509_STRICT">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_X509_STRICT</code><a class="headerlink" href="#ssl.VERIFY_X509_STRICT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値で、壊れた X.509 証明書に対するワークアラウンドを無効にします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_X509_TRUSTED_FIRST">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_X509_TRUSTED_FIRST</code><a class="headerlink" href="#ssl.VERIFY_X509_TRUSTED_FIRST" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値です。OpenSSL に対し、証明書検証のために信頼チェインを構築する際、信頼出来る証明書を選ぶように指示します。これはデフォルトで有効にされています。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.10 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLS">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLS</code><a class="headerlink" href="#ssl.PROTOCOL_TLS" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとして、クライアントとサーバの両方がサポートする中の、プロトコルバージョンが最も大きなものを選択します。その名前にも関わらず、このオプションは &#8220;SSL&#8221; とともに &#8220;TLS&#8221; プロトコルも選択できます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.13 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv23">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv23</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv23" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Alias for <code class="docutils literal"><span class="pre">PROTOCOL_TLS</span></code>.</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 2.7.13 で撤廃: </span>Use <code class="docutils literal"><span class="pre">PROTOCOL_TLS</span></code> instead.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv2">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv2</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv2" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとして SSL バージョン2を選択します。</p>
<p>このプロトコルは、 OpenSSL が <code class="docutils literal"><span class="pre">OPENSSL_NO_SSL2</span></code> フラグが有効な状態でコンパイルされている場合には利用できません。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">SSL version 2 は非セキュアです。このプロトコルは強く非推奨です。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 2.7.13 で撤廃: </span>OpenSSL has removed support for SSLv2.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv3">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv3</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv3" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてSSLバージョン3を選択します。</p>
<p>このプロトコルは、 OpenSSL が <code class="docutils literal"><span class="pre">OPENSSL_NO_SSLv3</span></code> フラグが有効な状態でコンパイルされている場合には利用できません。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">SSL version 3 は非セキュアです。このプロトコルは強く非推奨です。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 2.7.13 で撤廃: </span>OpenSSL has deprecated all version specific protocols. Use the default
protocol with flags like <code class="docutils literal"><span class="pre">OP_NO_SSLv3</span></code> instead.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLSv1">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLSv1</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてTLSバージョン1.0を選択します。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 2.7.13 で撤廃: </span>OpenSSL has deprecated all version specific protocols. Use the default
protocol with flags like <code class="docutils literal"><span class="pre">OP_NO_SSLv3</span></code> instead.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLSv1_1">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLSv1_1</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1_1" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてTLSバージョン1.1を選択します。 openssl version 1.0.1+ のみで利用可能です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 2.7.13 で撤廃: </span>OpenSSL has deprecated all version specific protocols. Use the default
protocol with flags like <code class="docutils literal"><span class="pre">OP_NO_SSLv3</span></code> instead.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLSv1_2">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLSv1_2</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1_2" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてTLSバージョン1.2を選択します。これは最も現代的で、接続の両サイドが利用できる場合は、たぶん最も安全な選択肢です。 openssl version 1.0.1+ のみで利用可能です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 2.7.13 で撤廃: </span>OpenSSL has deprecated all version specific protocols. Use the default
protocol with flags like <code class="docutils literal"><span class="pre">OP_NO_SSLv3</span></code> instead.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_ALL">
<code class="descclassname">ssl.</code><code class="descname">OP_ALL</code><a class="headerlink" href="#ssl.OP_ALL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>相手にする SSL 実装のさまざまなバグを回避するためのワークアラウンドを有効にします。このオプションはデフォルトで有効です。これを有効にする場合 OpenSSL 用の同じ意味のフラグ <code class="docutils literal"><span class="pre">SSL_OP_ALL</span></code> をセットする必要はありません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_SSLv2">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_SSLv2</code><a class="headerlink" href="#ssl.OP_NO_SSLv2" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSLv2 接続が行われないようにします。このオプションは <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a> と組み合わせでのみ意味を持ちます。ピア間で SSLv2 がプロトコルバージョンとして選択されることを防ぎます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_SSLv3">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_SSLv3</code><a class="headerlink" href="#ssl.OP_NO_SSLv3" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSLv3 接続が行われないようにします。このオプションは <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a> と組み合わせでのみ意味を持ちます。ピア間で SSLv3 がプロトコルバージョンとして選択されることを防ぎます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TLSv1">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TLSv1</code><a class="headerlink" href="#ssl.OP_NO_TLSv1" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>TLSv1 接続が行われないようにします。このオプションは <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a> と組み合わせでのみ意味を持ちます。ピア間で TLSv1 がプロトコルバージョンとして選択されることを防ぎます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TLSv1_1">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TLSv1_1</code><a class="headerlink" href="#ssl.OP_NO_TLSv1_1" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>TLSv1.1 接続が行われないようにします。このオプションは <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a> と組み合わせでのみ意味を持ちます。ピア間で TLSv1.1 がプロトコルバージョンとして選択されることを防ぎます。openssl version 1.0.1+ でのみ利用できます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TLSv1_2">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TLSv1_2</code><a class="headerlink" href="#ssl.OP_NO_TLSv1_2" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>TLSv1.2 接続が行われないようにします。このオプションは <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a> と組み合わせでのみ意味を持ちます。ピア間で TLSv1.2 がプロトコルバージョンとして選択されることを防ぎます。openssl version 1.0.1+ でのみ利用できます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_CIPHER_SERVER_PREFERENCE">
<code class="descclassname">ssl.</code><code class="descname">OP_CIPHER_SERVER_PREFERENCE</code><a class="headerlink" href="#ssl.OP_CIPHER_SERVER_PREFERENCE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>暗号の優先順位として、クライアントのものではなくサーバのものを使います。このオプションはクライアントソケットと SSLv2 のサーバソケットでは効果はありません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_SINGLE_DH_USE">
<code class="descclassname">ssl.</code><code class="descname">OP_SINGLE_DH_USE</code><a class="headerlink" href="#ssl.OP_SINGLE_DH_USE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL セッションを区別するのに同じ DH 鍵を再利用しないようにします。これはセキュリティを向上させますが、より多くの計算機リソースを必要とします。このオプションはサーバソケットに適用されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_SINGLE_ECDH_USE">
<code class="descclassname">ssl.</code><code class="descname">OP_SINGLE_ECDH_USE</code><a class="headerlink" href="#ssl.OP_SINGLE_ECDH_USE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL セッションを区別するのに同じ ECDH 鍵を再利用しないようにします。これはセキュリティを向上させますが、より多くの計算機リソースを必要とします。このオプションはサーバソケットに適用されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_COMPRESSION">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_COMPRESSION</code><a class="headerlink" href="#ssl.OP_NO_COMPRESSION" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL チャネルでの圧縮を無効にします。これはアプリケーションのプロトコルが自身の圧縮方法をサポートする場合に有用です。</p>
<p>このオプションは OpenSSL 1.0.0以降のみで使用できます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_ALPN">
<code class="descclassname">ssl.</code><code class="descname">HAS_ALPN</code><a class="headerlink" href="#ssl.HAS_ALPN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みで <span class="target" id="index-34"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7301.html"><strong>RFC 7301</strong></a> で記述されている <em>Application-Layer Protocol Negotiation</em> TLS 拡張をサポートしているかどうか。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.10 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_ECDH">
<code class="descclassname">ssl.</code><code class="descname">HAS_ECDH</code><a class="headerlink" href="#ssl.HAS_ECDH" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みの楕円曲線ディフィー・ヘルマン鍵共有をサポートしているかどうか。これは、ディストリビュータが明示的に無効にしていない限りは、真であるはずです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_SNI">
<code class="descclassname">ssl.</code><code class="descname">HAS_SNI</code><a class="headerlink" href="#ssl.HAS_SNI" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みで (<span class="target" id="index-35"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4366.html"><strong>RFC 4366</strong></a> で記述されている) <em>Server Name Indication</em> 拡張をサポートしているかどうか。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_NPN">
<code class="descclassname">ssl.</code><code class="descname">HAS_NPN</code><a class="headerlink" href="#ssl.HAS_NPN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みで、<a class="reference external" href="https://tools.ietf.org/html/draft-agl-tls-nextprotoneg">NPN draft specification</a> で記述されている <em>Next Protocol Negotiation</em> をサポートしているかどうか。 true であれば、サポートしたいプロトコルを <a class="reference internal" href="#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.set_npn_protocols()</span></code></a> メソッドで提示することができます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.CHANNEL_BINDING_TYPES">
<code class="descclassname">ssl.</code><code class="descname">CHANNEL_BINDING_TYPES</code><a class="headerlink" href="#ssl.CHANNEL_BINDING_TYPES" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サポートされている TLS のチャネルバインディングのタイプのリスト。リスト内の文字列は <a class="reference internal" href="#ssl.SSLSocket.get_channel_binding" title="ssl.SSLSocket.get_channel_binding"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.get_channel_binding()</span></code></a> の引数に渡せます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION">
<code class="descclassname">ssl.</code><code class="descname">OPENSSL_VERSION</code><a class="headerlink" href="#ssl.OPENSSL_VERSION" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インタプリタによってロードされた OpenSSL ライブラリのバージョン文字列:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION</span>
<span class="go">&#39;OpenSSL 0.9.8k 25 Mar 2009&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION_INFO">
<code class="descclassname">ssl.</code><code class="descname">OPENSSL_VERSION_INFO</code><a class="headerlink" href="#ssl.OPENSSL_VERSION_INFO" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>OpenSSL ライブラリのバージョン情報を表す5つの整数のタプル:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_INFO</span>
<span class="go">(0, 9, 8, 11, 15)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION_NUMBER">
<code class="descclassname">ssl.</code><code class="descname">OPENSSL_VERSION_NUMBER</code><a class="headerlink" href="#ssl.OPENSSL_VERSION_NUMBER" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>1つの整数の形式の、 OpenSSL ライブラリの生のバージョン番号:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span>
<span class="go">9470143L</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span><span class="p">)</span>
<span class="go">&#39;0x9080bfL&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE">
<code class="descclassname">ssl.</code><code class="descname">ALERT_DESCRIPTION_HANDSHAKE_FAILURE</code><a class="headerlink" href="#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE" title="この定義へのパーマリンク">¶</a></dt>
<dt id="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR">
<code class="descclassname">ssl.</code><code class="descname">ALERT_DESCRIPTION_INTERNAL_ERROR</code><a class="headerlink" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">ALERT_DESCRIPTION_*</code></dt>
<dd><p><span class="target" id="index-36"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5246.html"><strong>RFC 5246</strong></a> その他からのアラートの種類です。 <a class="reference external" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-6">IANA TLS Alert Registry</a> にはこのリストとその意味が定義された RFC へのリファレンスが含まれています。</p>
<p><a class="reference internal" href="#ssl.SSLContext.set_servername_callback" title="ssl.SSLContext.set_servername_callback"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.set_servername_callback()</span></code></a> でのコールバック関数の戻り値として使われます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.Purpose.SERVER_AUTH">
<code class="descclassname">Purpose.</code><code class="descname">SERVER_AUTH</code><a class="headerlink" href="#ssl.Purpose.SERVER_AUTH" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal"><span class="pre">create_default_context()</span></code></a> と <a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_default_certs()</span></code></a> に渡すオプションです。この値はコンテキストが Web サーバの認証に使われることを示します (ですので、クライアントサイドのソケットを作るのに使うことになるでしょう)。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.Purpose.CLIENT_AUTH">
<code class="descclassname">Purpose.</code><code class="descname">CLIENT_AUTH</code><a class="headerlink" href="#ssl.Purpose.CLIENT_AUTH" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal"><span class="pre">create_default_context()</span></code></a> と <a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_default_certs()</span></code></a> に渡すオプションです。この値はコンテキストが Web クライアントの認証に使われることを示します (ですので、サーバサイドのソケットを作るのに使うことになるでしょう)。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="ssl-sockets">
<h2>17.3.2. SSL ソケット<a class="headerlink" href="#ssl-sockets" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SSL ソケットは <a class="reference internal" href="socket.html#socket-objects"><span class="std std-ref">socket オブジェクト</span></a> の以下のメソッドを提供します:</p>
<ul class="simple">
<li><a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.bind" title="socket.socket.bind"><code class="xref py py-meth docutils literal"><span class="pre">bind()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.fileno" title="socket.socket.fileno"><code class="xref py py-meth docutils literal"><span class="pre">fileno()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal"><span class="pre">getpeername()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.getsockname" title="socket.socket.getsockname"><code class="xref py py-meth docutils literal"><span class="pre">getsockname()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.getsockopt" title="socket.socket.getsockopt"><code class="xref py py-meth docutils literal"><span class="pre">getsockopt()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.setsockopt" title="socket.socket.setsockopt"><code class="xref py py-meth docutils literal"><span class="pre">setsockopt()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.gettimeout" title="socket.socket.gettimeout"><code class="xref py py-meth docutils literal"><span class="pre">gettimeout()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></code></a>,
<a class="reference internal" href="socket.html#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal"><span class="pre">setblocking()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal"><span class="pre">listen()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal"><span class="pre">makefile()</span></code></a></li>
<li><p class="first"><a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal"><span class="pre">recv_into()</span></code></a> (非ゼロの <code class="docutils literal"><span class="pre">flags</span></code> は渡せません)</p>
</li>
<li><p class="first"><a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal"><span class="pre">sendall()</span></code></a> (非ゼロの <code class="docutils literal"><span class="pre">flags</span></code> は渡せません)</p>
</li>
<li><a class="reference internal" href="socket.html#socket.socket.shutdown" title="socket.socket.shutdown"><code class="xref py py-meth docutils literal"><span class="pre">shutdown()</span></code></a></li>
</ul>
<p>SSL(およびTLS)プロトコルは TCP の上に独自の枠組みを持っているので、SSLソケットの抽象化は、いくつかの点で通常の OSレベルのソケットの仕様から逸脱することがあります。特に <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">ノンブロッキングソケットについての注釈</span></a> を参照してください。</p>
<p>SSL ソケットには、以下に示す追加のメソッドと属性もあります:</p>
<dl class="method">
<dt id="ssl.SSLSocket.do_handshake">
<code class="descclassname">SSLSocket.</code><code class="descname">do_handshake</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.do_handshake" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL セットアップのハンドシェイクを実行します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7.9 で変更: </span>ソケットの <a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal"><span class="pre">context</span></code></a> の属性 <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal"><span class="pre">check_hostname</span></code></a> が真の場合に、ハンドシェイクメソッドが <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal"><span class="pre">match_hostname()</span></code></a> を実行するようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.getpeercert">
<code class="descclassname">SSLSocket.</code><code class="descname">getpeercert</code><span class="sig-paren">(</span><em>binary_form=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.getpeercert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>接続先に証明書が無い場合、 <code class="docutils literal"><span class="pre">None</span></code> を返します。SSL ハンドシェイクがまだ行われていない場合は、 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。</p>
<p><code class="docutils literal"><span class="pre">binary_form</span></code> が <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> で接続先から証明書を取得した場合、このメソッドは <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> のインスタンスを返します。証明書が認証されていない場合、辞書は空です。証明書が認証されていた場合いくつかのキーを持った辞書を返し、 <code class="docutils literal"><span class="pre">subject</span></code> (証明書が発行された principal), <code class="docutils literal"><span class="pre">issuer</span></code> (証明書を発行した principal) を含みます。証明書が <em>Subject Alternative Name</em> 拡張(<span class="target" id="index-37"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3280.html"><strong>RFC 3280</strong></a> を参照)のインスタンスを格納していた場合、 <code class="docutils literal"><span class="pre">subjectAltName</span></code> キーも辞書に含まれます。</p>
<p><code class="docutils literal"><span class="pre">subject</span></code>, <code class="docutils literal"><span class="pre">issuer</span></code> フィールドは、証明書のそれぞれのフィールドについてのデータ構造で与えられる RDN (relative distinguishued name) のシーケンスを格納したタプルで、各 RDN は name-value ペアのシーケンスです。現実世界での例をお見せします:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;issuer&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;countryName&#39;</span><span class="p">,</span> <span class="s1">&#39;IL&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s1">&#39;StartCom Ltd.&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;organizationalUnitName&#39;</span><span class="p">,</span>
              <span class="s1">&#39;Secure Digital Certificate Signing&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span>
              <span class="s1">&#39;StartCom Class 2 Primary Intermediate Server CA&#39;</span><span class="p">),)),</span>
 <span class="s1">&#39;notAfter&#39;</span><span class="p">:</span> <span class="s1">&#39;Nov 22 08:15:19 2013 GMT&#39;</span><span class="p">,</span>
 <span class="s1">&#39;notBefore&#39;</span><span class="p">:</span> <span class="s1">&#39;Nov 21 03:09:52 2011 GMT&#39;</span><span class="p">,</span>
 <span class="s1">&#39;serialNumber&#39;</span><span class="p">:</span> <span class="s1">&#39;95F0&#39;</span><span class="p">,</span>
 <span class="s1">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="s1">&#39;571208-SLe257oHY9fVQ07Z&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;countryName&#39;</span><span class="p">,</span> <span class="s1">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;stateOrProvinceName&#39;</span><span class="p">,</span> <span class="s1">&#39;California&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;localityName&#39;</span><span class="p">,</span> <span class="s1">&#39;San Francisco&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s1">&#39;Electronic Frontier Foundation, Inc.&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span> <span class="s1">&#39;*.eff.org&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;emailAddress&#39;</span><span class="p">,</span> <span class="s1">&#39;hostmaster@eff.org&#39;</span><span class="p">),)),</span>
 <span class="s1">&#39;subjectAltName&#39;</span><span class="p">:</span> <span class="p">((</span><span class="s1">&#39;DNS&#39;</span><span class="p">,</span> <span class="s1">&#39;*.eff.org&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;DNS&#39;</span><span class="p">,</span> <span class="s1">&#39;eff.org&#39;</span><span class="p">)),</span>
 <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">特定のサービスのために証明書の検証がしたければ、 <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal"><span class="pre">match_hostname()</span></code></a> 関数を使うことが出来ます。</p>
</div>
<p><code class="docutils literal"><span class="pre">binary_form</span></code> 引数が <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> だった場合、証明書が渡されていればこのメソッドはDERエンコードされた証明書全体をバイト列として返し、接続先が証明書を提示しなかった場合は <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を返します。接続先が証明書を提供するかどうかは SSL ソケットの役割に依存します:</p>
<ul class="simple">
<li><p class="first">クライアント側ソケットでは、認証が要求されているかどうかに関わらず、サーバは常に証明書を提供します;</p>
</li>
<li><p class="first">サーバ側ソケットでは、クライアントはサーバによって認証が要求されている場合にのみ証明書を提供します; ですので、 (<a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal"><span class="pre">CERT_OPTIONAL</span></code></a> や <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></code></a> ではなく) <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></code></a> を使うと <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal"><span class="pre">getpeercert()</span></code></a> は <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を返します。</p>
</li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7.9 で変更: </span>返される辞書に <code class="docutils literal"><span class="pre">issuer</span></code>, <code class="docutils literal"><span class="pre">notBefore</span></code> のような追加アイテムを含むようになりました。加えて、ハンドシェイクが済んでいなければ <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を投げるようになりました。返される辞書に <code class="docutils literal"><span class="pre">crlDistributionPoints</span></code>, <code class="docutils literal"><span class="pre">caIssuers</span></code>, <code class="docutils literal"><span class="pre">OCSP</span></code> URI のような X509v3 拡張アイテムを含むようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.cipher">
<code class="descclassname">SSLSocket.</code><code class="descname">cipher</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.cipher" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>利用されている暗号の名前、その暗号の利用を定義しているSSLプロトコルのバージョン、利用されている鍵のbit長の3つの値を含むタプルを返します。もし接続が確立されていない場合、 <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.compression">
<code class="descclassname">SSLSocket.</code><code class="descname">compression</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.compression" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>使われている圧縮アルゴリズムを文字列で返します。接続が圧縮されていなければ <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
<p>上位レベルのプロトコルが自身で圧縮メカニズムをサポートする場合、SSL レベルでの圧縮を <a class="reference internal" href="#ssl.OP_NO_COMPRESSION" title="ssl.OP_NO_COMPRESSION"><code class="xref py py-data docutils literal"><span class="pre">OP_NO_COMPRESSION</span></code></a> を使って無効に出来ます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.get_channel_binding">
<code class="descclassname">SSLSocket.</code><code class="descname">get_channel_binding</code><span class="sig-paren">(</span><em>cb_type=&quot;tls-unique&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.get_channel_binding" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在の接続におけるチャネルバインディングのデータを取得します。未接続あるいはハンドシェイクが完了していなければ <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
<p><em>cb_type</em> パラメータにより、望みのチャネルバインディングのタイプを選択出来ます。チャネルバインディングのタイプの妥当なものは <a class="reference internal" href="#ssl.CHANNEL_BINDING_TYPES" title="ssl.CHANNEL_BINDING_TYPES"><code class="xref py py-data docutils literal"><span class="pre">CHANNEL_BINDING_TYPES</span></code></a> でリストされています。現在のところは <span class="target" id="index-38"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5929.html"><strong>RFC 5929</strong></a> で定義されている &#8216;tls-unique&#8217; のみがサポートされています。未サポートのチャネルバインディングのタイプが要求された場合、 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.selected_alpn_protocol">
<code class="descclassname">SSLSocket.</code><code class="descname">selected_alpn_protocol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.selected_alpn_protocol" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>TLS ハンドシェイクで選択されたプロトコルを返します。 <a class="reference internal" href="#ssl.SSLContext.set_alpn_protocols" title="ssl.SSLContext.set_alpn_protocols"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.set_alpn_protocols()</span></code></a> が呼ばれていない場合、相手側が ALPN をサポートしていない場合、クライアントが提案したプロトコルのどれもソケットがサポートしない場合、あるいはハンドシェイクがまだ行われていない場合には、 <code class="docutils literal"><span class="pre">None</span></code> が返されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.10 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.selected_npn_protocol">
<code class="descclassname">SSLSocket.</code><code class="descname">selected_npn_protocol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.selected_npn_protocol" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>TLS/SSL ハンドシェイクで選択された上位レベルのプロトコルを返します。 <a class="reference internal" href="#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.set_npn_protocols()</span></code></a> が呼ばれていない場合、相手側が NPN をサポートしていない場合、あるいはハンドシェイクがまだ行われていない場合には、 <code class="docutils literal"><span class="pre">None</span></code> が返されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.unwrap">
<code class="descclassname">SSLSocket.</code><code class="descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.unwrap" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSLシャットダウンハンドシェイクを実行します。これは下位レイヤーのソケットからTLSレイヤーを取り除き、下位レイヤーのソケットオブジェクトを返します。これは暗号化されたオペレーションから暗号化されていない接続に移行するときに利用されます。以降の通信には、オリジナルのソケットではなくこのメソッドが返したソケットのみを利用するべきです。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.version">
<code class="descclassname">SSLSocket.</code><code class="descname">version</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.version" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コネクションによって実際にネゴシエイトされた SSL プロトコルバージョンを文字列で、または、セキュアなコネクションが確立していなければ <code class="docutils literal"><span class="pre">None</span></code> を返します。これを書いている時点では、 <code class="docutils literal"><span class="pre">&quot;SSLv2&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;SSLv3&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;TLSv1&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;TLSv1.1&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;TLSv1.2&quot;</span></code> などが返ります。最新の OpenSSL はもっと色々な値を定義しているかもしれません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSocket.context">
<code class="descclassname">SSLSocket.</code><code class="descname">context</code><a class="headerlink" href="#ssl.SSLSocket.context" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この SSL ソケットに結び付けられた <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> オブジェクトです。SSL ソケットが (<a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></code></a> ではなく)トップレベルの <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> 関数を使って作られた場合、これはこの SSL ソケットのために作られたカスタムコンテキストオブジェクトです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="ssl-contexts">
<h2>17.3.3. SSL コンテキスト<a class="headerlink" href="#ssl-contexts" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.9 で追加.</span></p>
</div>
<p>SSL コンテキストは、SSL 構成オプション、証明書(群)や秘密鍵(群)などのような、一回の SSL 接続よりも長生きするさまざまなデータを保持します。これはサーバサイドソケットの SSL セッションのキャッシュも管理し、同じクライアントからの繰り返しの接続時の速度向上に一役買います。</p>
<dl class="class">
<dt id="ssl.SSLContext">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">SSLContext</code><span class="sig-paren">(</span><em>protocol</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しい SSL コンテキストを作成します。 <em>protocol</em> にはこのモジュールで定義されている <code class="docutils literal"><span class="pre">PROTOCOL_*</span></code> 定数のうち一つを指定しなければなりません。最大限の互換性のためには、現時点での推奨は <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-data docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a> です。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal"><span class="pre">create_default_context()</span></code></a> は <a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal"><span class="pre">ssl</span></code></a> モジュールに、目的に合ったセキュリティ設定を選ばせます。</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> オブジェクトは以下のメソッドと属性を持っています:</p>
<dl class="method">
<dt id="ssl.SSLContext.cert_store_stats">
<code class="descclassname">SSLContext.</code><code class="descname">cert_store_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.cert_store_stats" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ロードされた X.509 証明書の数、CA 証明書で活性の X.509 証明書の数、証明書失効リストの数、についての統計情報を辞書として取得します。</p>
<p>一つの CA と他の一つの証明書を持ったコンテキストでの例です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">cert_store_stats</span><span class="p">()</span>
<span class="go">{&#39;crl&#39;: 0, &#39;x509_ca&#39;: 1, &#39;x509&#39;: 2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_cert_chain">
<code class="descclassname">SSLContext.</code><code class="descname">load_cert_chain</code><span class="sig-paren">(</span><em>certfile</em>, <em>keyfile=None</em>, <em>password=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_cert_chain" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>秘密鍵と対応する証明書をロードします。 <em>certfile</em> は、証明書と、証明書認証で必要とされる任意の数の CA 証明書を含む、PEM フォーマットの単一ファイルへのパスでなければなりません。 <em>keyfile</em> を指定する場合は、秘密鍵が含まれるファイルを指さなければなりません。そうでなければ秘密鍵も <em>certfile</em> から取られます。 <em>certfile</em> に証明書をどのように格納すれば良いかについての詳しい情報は、 <a class="reference internal" href="#ssl-certificates"><span class="std std-ref">証明書</span></a> の議論を参照してください。</p>
<p><em>password</em> 引数に、秘密鍵を復号するためのパスワードを返す関数を与えることが出来ます。その関数は秘密鍵が暗号化されていて、なおかつパスワードが必要な場合にのみ呼び出されます。その関数は引数なしで呼び出され、string, bytes, または bytearray を返さなければなりません。戻り値が string の場合は鍵を復号化するのに使う前に UTF-8 でエンコードされます。string の代わりに bytes や bytearray を返した場合は <em>password</em> 引数に直接供給されます。秘密鍵が暗号化されていなかったりパスワードを必要としない場合は、指定は無視されます。</p>
<p><em>password</em> が与えられず、そしてパスワードが必要な場合には、OpenSSL 組み込みのパスワード問い合わせメカニズムが、ユーザに対話的にパスワードを問い合わせます。</p>
<p>秘密鍵が証明書に合致しなければ、 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal"><span class="pre">SSLError</span></code></a> が送出されます。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_default_certs">
<code class="descclassname">SSLContext.</code><code class="descname">load_default_certs</code><span class="sig-paren">(</span><em>purpose=Purpose.SERVER_AUTH</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_default_certs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デフォルトの場所から &#8220;認証局&#8221; (CA=certification authority) 証明書ファイル一式をロードします。Windows では、CA 証明書はシステム記憶域の <code class="docutils literal"><span class="pre">CA</span></code> と <code class="docutils literal"><span class="pre">ROOT</span></code> からロードします。それ以外のシステムでは、この関数は <a class="reference internal" href="#ssl.SSLContext.set_default_verify_paths" title="ssl.SSLContext.set_default_verify_paths"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.set_default_verify_paths()</span></code></a> を呼び出します。将来的にはこのメソッドは、他の場所からも CA 証明書をロードするかもしれません。</p>
<p><em>purpose</em> フラグでどの種類の CA 証明書をロードするかを指定します。デフォルトの <a class="reference internal" href="#ssl.Purpose.SERVER_AUTH" title="ssl.Purpose.SERVER_AUTH"><code class="xref py py-data docutils literal"><span class="pre">Purpose.SERVER_AUTH</span></code></a> は TLS web サーバの認証のために活性かつ信頼された証明書をロードします(クライアントサイドのソケット)。 <a class="reference internal" href="#ssl.Purpose.CLIENT_AUTH" title="ssl.Purpose.CLIENT_AUTH"><code class="xref py py-data docutils literal"><span class="pre">Purpose.CLIENT_AUTH</span></code></a> はクライアント証明書の正当性検証をサーバサイドで行うための CA 証明書をロードします。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_verify_locations">
<code class="descclassname">SSLContext.</code><code class="descname">load_verify_locations</code><span class="sig-paren">(</span><em>cafile=None</em>, <em>capath=None</em>, <em>cadata=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_verify_locations" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-data docutils literal"><span class="pre">verify_mode</span></code></a> が <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal"><span class="pre">CERT_NONE</span></code></a> でない場合に接続先の証明書ファイルの正当性検証に使われる &#8220;認証局&#8221; (CA=certification authority) 証明書ファイル一式をロードします。少なくとも <em>cafile</em> か <em>capath</em> のどちらかは指定しなければなりません。</p>
<p>このメソッドは PEM または DER フォーマットの証明書失効リスト (CRLs=certification revocation lists)もロード出来ます。CRLs のために使うには、 <a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_flags</span></code></a> を適切に設定しなければなりません。</p>
<p><em>cafile</em> を指定する場合は、PEM フォーマットで CA 証明書が結合されたファイルへのパスを指定してください。このファイル内で証明書をどのように編成すれば良いのかについての詳しい情報については、 <a class="reference internal" href="#ssl-certificates"><span class="std std-ref">証明書</span></a> の議論を参照してください。</p>
<p><em>capath</em> を指定する場合は、PEM フォーマットの CA 証明書が含まれる、<a class="reference external" href="https://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html">OpenSSL specific layout</a> に従ったディレクトリへのパスを指定してください。</p>
<p><em>cadata</em> オブジェクトを指定する場合は、PEM エンコードの証明書一つ以上の ASCII 文字列か、DER エンコードの証明書のバイトライクなオブジェクトのどちらかを指定してください。PEM エンコードの証明書の周囲の余分な行は無視されますが、少なくとも一つの証明書が含まれている必要があります。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.get_ca_certs">
<code class="descclassname">SSLContext.</code><code class="descname">get_ca_certs</code><span class="sig-paren">(</span><em>binary_form=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.get_ca_certs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ロードされた &#8220;認証局&#8221; (CA=certification authority) 証明書のリストを取得します。 <code class="docutils literal"><span class="pre">binary_form</span></code> パラメータが <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> であれば、リストのそれぞれのエントリは <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.getpeercert()</span></code></a> が出力するような辞書になります。そうでない場合このメソッドは、DER エンコード形式の証明書のリストで返します。返却されるリストには、 SSL 接続によって要求されてロードされない限りは <em>capath</em> からの証明書は含みません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">capath ディレクトリ内の証明書は一度でも使われない限りはロードされません。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_default_verify_paths">
<code class="descclassname">SSLContext.</code><code class="descname">set_default_verify_paths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_default_verify_paths" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デフォルトの &#8220;認証局&#8221; (CA=certification authority) 証明書を、OpenSSL ライブラリがビルドされた際に定義されたファイルシステム上のパスからロードします。残念ながらこのメソッドが成功したかどうかを知るための簡単な方法はありません: 証明書が見つからなくてもエラーは返りません。OpenSSL ライブラリがオペレーティングシステムの一部として提供されている際にはどうやら適切に構成できるようですが。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_ciphers">
<code class="descclassname">SSLContext.</code><code class="descname">set_ciphers</code><span class="sig-paren">(</span><em>ciphers</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_ciphers" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このコンテキストによって作られるソケットで利用できる暗号を設定します。 <a class="reference external" href="https://www.openssl.org/docs/apps/ciphers.html#CIPHER-LIST-FORMAT">OpenSSL cipher list format</a> に書かれている形式の文字列でなければなりません。 (OpenSSL のコンパイル時オプションや他の設定がそれらすべての暗号の使用を禁止しているなどの理由で) どの暗号も選べない場合、 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal"><span class="pre">SSLError</span></code></a> が送出されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">接続時に SSL ソケットの <a class="reference internal" href="#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.cipher()</span></code></a> メソッドが、現在選択されているその暗号を使います。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_alpn_protocols">
<code class="descclassname">SSLContext.</code><code class="descname">set_alpn_protocols</code><span class="sig-paren">(</span><em>protocols</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_alpn_protocols" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL/TLS ハンドシェイク時にソケットが提示すべきプロトコルを指定します。 <code class="docutils literal"><span class="pre">['http/1.1',</span> <span class="pre">'spdy/2']</span></code> のような推奨順に並べた ASII 文字列のリストでなければなりません。プロトコルの選択は <span class="target" id="index-39"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7301.html"><strong>RFC 7301</strong></a> に従いハンドシェイクの中で行われます。ハンドシェイクが正常に終了後、 <a class="reference internal" href="#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a> メソッドは合意されたプロトコルを返します。</p>
<p>このメソッドは <a class="reference internal" href="#ssl.HAS_ALPN" title="ssl.HAS_ALPN"><code class="xref py py-data docutils literal"><span class="pre">HAS_ALPN</span></code></a> が偽の場合 <a class="reference internal" href="exceptions.html#exceptions.NotImplementedError" title="exceptions.NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> を送出します。</p>
<p>OpenSSL 1.1.0+ will abort the handshake and raise <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> when
both sides support ALPN but cannot agree on a protocol.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7.10 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_npn_protocols">
<code class="descclassname">SSLContext.</code><code class="descname">set_npn_protocols</code><span class="sig-paren">(</span><em>protocols</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_npn_protocols" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL/TLS ハンドシェイク時にソケットが提示すべきプロトコルを指定します。 <code class="docutils literal"><span class="pre">['http/1.1',</span> <span class="pre">'spdy/2']</span></code> のような推奨順に並べた文字列のリストでなければなりません。プロトコルの選択は <a class="reference external" href="https://tools.ietf.org/html/draft-agl-tls-nextprotoneg">NPN draft specification</a> に従いハンドシェイクの中で行われます。ハンドシェイクが正常に終了後、 <a class="reference internal" href="#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a> メソッドは合意されたプロトコルを返します。</p>
<p>このメソッドは <a class="reference internal" href="#ssl.HAS_NPN" title="ssl.HAS_NPN"><code class="xref py py-data docutils literal"><span class="pre">HAS_NPN</span></code></a> が偽の場合 <a class="reference internal" href="exceptions.html#exceptions.NotImplementedError" title="exceptions.NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_servername_callback">
<code class="descclassname">SSLContext.</code><code class="descname">set_servername_callback</code><span class="sig-paren">(</span><em>server_name_callback</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_servername_callback" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>TLS クライアントがサーバ名表示を指定した際の、SSL/TLS サーバによって TLS Client Hello ハンドシェイクメッセージが受け取られたあとで呼び出されるコールバック関数を登録します。サーバ名表示メカニズムは <span class="target" id="index-40"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6066.html"><strong>RFC 6066</strong></a> セクション 3 - Server Name Indication で述べられています。</p>
<p><code class="docutils literal"><span class="pre">SSLContext</span></code> ごとに一つだけコールバックをセット出来ます。 <em>server_name_callback</em> を <code class="docutils literal"><span class="pre">None</span></code> にすればコールバックは無効になります。この関数を続けて呼ぶと、以前に登録されたコールバックを上書きします。</p>
<p>コールバック関数 <em>server_name_callback</em> は 3 つの引数で呼び出されます; 最初の引数は <code class="xref py py-class docutils literal"><span class="pre">ssl.SSLSocket</span></code> です。2 つ目の引数は、クライアントが相手をしようと意図しているサーバ名を表す文字列 (または TLS Client Hello がサーバ名を含まない場合は <code class="docutils literal"><span class="pre">None</span></code>) です。そして 3 つ目の引数はオリジナルの <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> です。サーバ名引数は IDNA デコードされたサーバ名です。</p>
<p>このコールバックの典型的な利用方法は、 <code class="xref py py-class docutils literal"><span class="pre">ssl.SSLSocket</span></code> の <a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal"><span class="pre">SSLSocket.context</span></code></a> 属性を、サーバ名に合致する証明書チェインを持つ新しい <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> オブジェクトに変更することです。</p>
<p>TLS 接続の初期ネゴシエーションのフェーズですから、 <a class="reference internal" href="#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a>, <a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal"><span class="pre">SSLSocket.context</span></code></a> のような限られたメソッドと属性のみ使えます。 <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.getpeercert()</span></code></a>, <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.getpeercert()</span></code></a>, <a class="reference internal" href="#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.cipher()</span></code></a>, <code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.compress()</span></code> メソッドは TLS 接続が TLS Client Hello よりも先に進行していることを必要としますから、これらは意味のある値を返しませんし、安全に呼び出すことも出来ません。</p>
<p>TLS ネゴシエーションを継続させるならば、 <em>server_name_callback</em> 関数は <code class="docutils literal"><span class="pre">None</span></code> を返さなければなりません。TLS が失敗することを必要とするなら、 constant <a class="reference internal" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal"><span class="pre">ALERT_DESCRIPTION_*</span></code></a> を返してください。ここにない値を返すと、致命エラー <a class="reference internal" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal"><span class="pre">ALERT_DESCRIPTION_INTERNAL_ERROR</span></code></a> を引き起こします。</p>
<p>サーバ名に対する IDNA デコードのエラーがあれば、TLS 接続はクライアントに対する TLS の致命的アラートメッセージ <a class="reference internal" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal"><span class="pre">ALERT_DESCRIPTION_INTERNAL_ERROR</span></code></a> とともに終了します。</p>
<p><em>server_name_callback</em> 関数が例外を送出した場合、TLS 接続は TLS の致命的アラートメッセージ <a class="reference internal" href="#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE" title="ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE"><code class="xref py py-const docutils literal"><span class="pre">ALERT_DESCRIPTION_HANDSHAKE_FAILURE</span></code></a> とともに終了します。</p>
<p>このメソッドは OpenSSL ライブラリが OPENSSL_NO_TLSEXT を定義してビルドされている場合、 <a class="reference internal" href="exceptions.html#exceptions.NotImplementedError" title="exceptions.NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_dh_params">
<code class="descclassname">SSLContext.</code><code class="descname">load_dh_params</code><span class="sig-paren">(</span><em>dhfile</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_dh_params" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ディフィー・ヘルマン(DH)鍵交換のための鍵生成パラメータをロードします。DH 鍵交換を用いることは、(サーバ、クライアントともに)計算機リソースに高い処理負荷をかけますがセキュリティを向上させます。 <em>dhfile</em> パラメータは PEM フォーマットの DH パラメータを含んだファイルへのパスでなければなりません。</p>
<p>この設定はクライアントソケットには適用されません。さらにセキュリティを改善するのに <a class="reference internal" href="#ssl.OP_SINGLE_DH_USE" title="ssl.OP_SINGLE_DH_USE"><code class="xref py py-data docutils literal"><span class="pre">OP_SINGLE_DH_USE</span></code></a> オプションも利用できます。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_ecdh_curve">
<code class="descclassname">SSLContext.</code><code class="descname">set_ecdh_curve</code><span class="sig-paren">(</span><em>curve_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_ecdh_curve" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>楕円曲線ディフィー・ヘルマン(ECDH)鍵交換の曲線名を指定します。ECDH はもとの DH に較べて、ほぼ間違いなく同程度に安全である一方で、顕著に高速です。 <em>curve_name</em> パラメータは既知の楕円曲線を表す文字列でなければなりません。例えば <code class="docutils literal"><span class="pre">prime256v1</span></code> が広くサポートされている曲線です。</p>
<p>この設定はクライアントソケットには適用されません。さらにセキュリティを改善するのに <a class="reference internal" href="#ssl.OP_SINGLE_ECDH_USE" title="ssl.OP_SINGLE_ECDH_USE"><code class="xref py py-data docutils literal"><span class="pre">OP_SINGLE_ECDH_USE</span></code></a> オプションも利用できます。</p>
<p>This method is not available if <a class="reference internal" href="#ssl.HAS_ECDH" title="ssl.HAS_ECDH"><code class="xref py py-data docutils literal"><span class="pre">HAS_ECDH</span></code></a> is <code class="docutils literal"><span class="pre">False</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference external" href="http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html">SSL/TLS &amp; Perfect Forward Secrecy</a></dt>
<dd>Vincent Bernat.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.wrap_socket">
<code class="descclassname">SSLContext.</code><code class="descname">wrap_socket</code><span class="sig-paren">(</span><em>sock</em>, <em>server_side=False</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em>, <em>server_hostname=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.wrap_socket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>既存の Python ソケット <em>sock</em> をラップして <code class="xref py py-class docutils literal"><span class="pre">ssl.SSLSocket</span></code> オブジェクトを返します。 <em>sock</em> は <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal"><span class="pre">SOCK_STREAM</span></code></a> ソケットでなければなりません; ほかのタイプのソケットはサポートされていません。</p>
<p>返される SSL ソケットは、コンテキスト、その設定と証明書に関連付けられます。パラメータ <em>server_side</em>, <em>do_handshake_on_connect</em>, <em>suppress_ragged_eofs</em> はトップレベルの関数 <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> のものと同じ意味です。</p>
<p>クライアントサイドから接続では、 <em>server_hostname</em> で接続しようとしているサービスのホスト名を指定出来ます。これは HTTP バーチャルホストにかなり似て、シングルサーバで複数の SSL ベースのサービスを別々の証明書でホストしているようなサーバに対して使えます。 <em>server_side</em> が真の場合に <em>server_hostname</em> を指定すると <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7.9 で変更: </span>OpenSSL が SNI をサポートしなくても server_hostname を許容するようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.session_stats">
<code class="descclassname">SSLContext.</code><code class="descname">session_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.session_stats" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このコンテキストによって作られた、または管理されている SSL セッションについての統計情報を取得します。 <a class="reference external" href="https://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html">piece of information</a> のそれぞれの名前にそれらが持つ数値をマッピングした辞書で返します。例えば、コンテキストが作られてからのセッションキャッシュのキャッシュヒットとキャッシュミスの総計を見るには:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">session_stats</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;hits&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;misses&#39;</span><span class="p">]</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.check_hostname">
<code class="descclassname">SSLContext.</code><code class="descname">check_hostname</code><a class="headerlink" href="#ssl.SSLContext.check_hostname" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.do_handshake()</span></code></a> 呼び出し時に、 <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal"><span class="pre">match_hostname()</span></code></a> を使って接続先証明書のホスト名の合致を見るかどうか。コンテキストの <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal"><span class="pre">verify_mode</span></code></a> には <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal"><span class="pre">CERT_OPTIONAL</span></code></a> か <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal"><span class="pre">CERT_REQUIRED</span></code></a> をセットしなければなりません。また <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal"><span class="pre">wrap_socket()</span></code></a> にはホスト名の合致をみるための <em>server_hostname</em> を渡さなければなりません。</p>
<p>例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLSv1</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span>
<span class="n">context</span><span class="o">.</span><span class="n">check_hostname</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_default_certs</span><span class="p">()</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">ssl_sock</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="s1">&#39;www.verisign.com&#39;</span><span class="p">)</span>
<span class="n">ssl_sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;www.verisign.com&#39;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">この機能にはOpenSSL0.9.8f以降が必要です。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.options">
<code class="descclassname">SSLContext.</code><code class="descname">options</code><a class="headerlink" href="#ssl.SSLContext.options" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このコンテキストで有効になっている SSL オプションを表す整数。デフォルトの値は <a class="reference internal" href="#ssl.OP_ALL" title="ssl.OP_ALL"><code class="xref py py-data docutils literal"><span class="pre">OP_ALL</span></code></a> ですが、 <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal"><span class="pre">OP_NO_SSLv2</span></code></a> のようなほかの値をビットOR演算で指定出来ます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">OpenSSL の 0.9.8m より古いバージョンを使う場合、値はセットは出来ますがクリアが出来ません。オプションを(対応するビットをリセットすることで)クリアしようとすると <code class="docutils literal"><span class="pre">ValueError</span></code> が送出されます。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.protocol">
<code class="descclassname">SSLContext.</code><code class="descname">protocol</code><a class="headerlink" href="#ssl.SSLContext.protocol" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテキストの構築時に選択されたプロトコルバージョン。この属性は読み取り専用です。</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.verify_flags">
<code class="descclassname">SSLContext.</code><code class="descname">verify_flags</code><a class="headerlink" href="#ssl.SSLContext.verify_flags" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>証明書の検証操作のためのフラグです。 <a class="reference internal" href="#ssl.VERIFY_CRL_CHECK_LEAF" title="ssl.VERIFY_CRL_CHECK_LEAF"><code class="xref py py-data docutils literal"><span class="pre">VERIFY_CRL_CHECK_LEAF</span></code></a> などのフラグをビットOR演算でセット出来ます。デフォルトでは OpenSSL は証明書失効リスト(CRLs)を必要ともしませんし検証にも使いません。openssl version 0.9.8+ でのみ利用可能です。</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.verify_mode">
<code class="descclassname">SSLContext.</code><code class="descname">verify_mode</code><a class="headerlink" href="#ssl.SSLContext.verify_mode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>接続先の証明書の検証を試みるかどうか、また、検証が失敗した場合にどのように振舞うべきかを制御します。この属性は <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal"><span class="pre">CERT_NONE</span></code></a>, <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal"><span class="pre">CERT_OPTIONAL</span></code></a>, <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal"><span class="pre">CERT_REQUIRED</span></code></a> のうちどれか一つでなければなりません。</p>
</dd></dl>

<span class="target" id="index-15"></span></div>
<div class="section" id="certificates">
<span id="ssl-certificates"></span><span id="index-16"></span><h2>17.3.4. 証明書<a class="headerlink" href="#certificates" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>証明書を大まかに説明すると、公開鍵/秘密鍵システムの一種です。このシステムでは、各 <em>principal</em> (これはマシン、人、組織などです) は、ユニークな2つの暗号鍵を割り当てられます。1つは公開され、 <em>公開鍵(public key)</em> と呼ばれます。もう一方は秘密にされ、 <em>秘密鍵(private key)</em> と呼ばれます。 2つの鍵は関連しており、片方の鍵で暗号化したメッセージは、もう片方の鍵 <strong>のみ</strong> で復号できます。</p>
<p>証明書は2つの principal の情報を含んでいます。証明書は <em>subject</em> 名とその公開鍵を含んでいます。また、もう一つの principal である <em>発行者(issuer)</em> からの、 subject が本人であることと、その公開鍵が正しいことの宣言(statement)を含んでいます。発行者からの宣言は、その発行者の秘密鍵で署名されています。発行者の秘密鍵は発行者しか知りませんが、誰もがその発行者の公開鍵を利用して宣言を復号し、証明書内の別の情報と比較することで認証することができます。証明書はまた、その証明書が有効である期限に関する情報も含んでいます。この期限は &#8220;notBefore&#8221; と &#8220;notAfter&#8221; と呼ばれる2つのフィールドで表現されています。</p>
<p>Python において証明書を利用する場合、クライアントもサーバーも自分を証明するために証明書を利用することができます。ネットワーク接続の相手側に証明書の提示を要求する事ができ、そのクライアントやサーバーが認証を必要とするならその証明書を認証することができます。認証が失敗した場合、接続は例外を発生させます。認証は下位層のOpenSSLフレームワークが自動的に行います。アプリケーションは認証機構について意識する必要はありません。しかし、アプリケーションは認証プロセスのために幾つかの証明書を提供する必要があるかもしれません。</p>
<p>Python は証明書を格納したファイルを利用します。そのファイルは &#8220;PEM&#8221; (<span class="target" id="index-41"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1422.html"><strong>RFC 1422</strong></a> 参照) フォーマットという、ヘッダー行とフッター行の間にbase-64エンコードされた形をとっている必要があります。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
<div class="section" id="certificate-chains">
<h3>17.3.4.1. 証明書チェイン<a class="headerlink" href="#certificate-chains" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Pythonが利用する証明書を格納したファイルは、ときには <em>証明書チェイン(certificate chain)</em> と呼ばれる証明書のシーケンスを格納します。このチェインは、まずクライアントやサーバー自体の principal の証明書で始まらなければなりません。それ以降に続く証明書は、手前の証明書の発行者(issuer)の証明書になり、最後にsubject と発行者が同じ <em>自己署名(self-signed)</em> 証明書で終わります。この最後の証明書は <em>ルート証明書(root certificate</em> と呼ばれます。これらの証明書チェインは1つの証明書ファイルに結合されなければなりません。例えば、3つの証明書からなる証明書チェインがあるとします。私たちのサーバーの証明書から、私たちのサーバーに署名した認証局の証明書、そして認証局の証明書を発行した機関のルート証明書です。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="k">for</span> <span class="n">your</span> <span class="n">server</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">root</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="s1">&#39;s issuer)...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</div>
<div class="section" id="ca-certificates">
<h3>17.3.4.2. CA 証明書<a class="headerlink" href="#ca-certificates" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>もし相手から送られてきた証明書の認証をしたい場合、信頼している各発行者の証明書チェインが入った &#8220;CA certs&#8221; ファイルを提供する必要があります。繰り返しますが、このファイルは単純に、各チェインを結合しただけのものです。認証のために、Pythonはそのファイルの中の最初にマッチしたチェインを利用します。<a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_default_certs()</span></code></a> を呼び出すことでプラットフォームの証明書ファイルも使われますが、これは <a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal"><span class="pre">create_default_context()</span></code></a> によって自動的に行われます。</p>
</div>
<div class="section" id="combined-key-and-certificate">
<h3>17.3.4.3. 秘密鍵と証明書を一緒にする<a class="headerlink" href="#combined-key-and-certificate" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>多くの場合、証明書と同じファイルに秘密鍵も格納されています。この場合、 <a class="reference internal" href="#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_cert_chain()</span></code></a>, <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> には <code class="docutils literal"><span class="pre">certfile</span></code> 引数だけが必要とされます。秘密鍵が証明書ファイルに格納されている場合、秘密鍵は証明書チェインの最初の証明書よりも先にないといけません。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">private</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</div>
<div class="section" id="self-signed-certificates">
<h3>17.3.4.4. 自己署名証明書<a class="headerlink" href="#self-signed-certificates" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>SSL暗号化接続サービスを提供するサーバーを建てる場合、適切な証明書を取得するには、認証局から買うなどの幾つかの方法があります。また、自己署名証明書を作るケースもあります。 OpenSSLを使って自己署名証明書を作るには、次のようにします。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">openssl</span> <span class="n">req</span> <span class="o">-</span><span class="n">new</span> <span class="o">-</span><span class="n">x509</span> <span class="o">-</span><span class="n">days</span> <span class="mi">365</span> <span class="o">-</span><span class="n">nodes</span> <span class="o">-</span><span class="n">out</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span> <span class="o">-</span><span class="n">keyout</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span>
<span class="n">Generating</span> <span class="n">a</span> <span class="mi">1024</span> <span class="n">bit</span> <span class="n">RSA</span> <span class="n">private</span> <span class="n">key</span>
<span class="o">.......++++++</span>
<span class="o">.............................++++++</span>
<span class="n">writing</span> <span class="n">new</span> <span class="n">private</span> <span class="n">key</span> <span class="n">to</span> <span class="s1">&#39;cert.pem&#39;</span>
<span class="o">-----</span>
<span class="n">You</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">be</span> <span class="n">asked</span> <span class="n">to</span> <span class="n">enter</span> <span class="n">information</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">incorporated</span>
<span class="n">into</span> <span class="n">your</span> <span class="n">certificate</span> <span class="n">request</span><span class="o">.</span>
<span class="n">What</span> <span class="n">you</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">enter</span> <span class="ow">is</span> <span class="n">what</span> <span class="ow">is</span> <span class="n">called</span> <span class="n">a</span> <span class="n">Distinguished</span> <span class="n">Name</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">DN</span><span class="o">.</span>
<span class="n">There</span> <span class="n">are</span> <span class="n">quite</span> <span class="n">a</span> <span class="n">few</span> <span class="n">fields</span> <span class="n">but</span> <span class="n">you</span> <span class="n">can</span> <span class="n">leave</span> <span class="n">some</span> <span class="n">blank</span>
<span class="n">For</span> <span class="n">some</span> <span class="n">fields</span> <span class="n">there</span> <span class="n">will</span> <span class="n">be</span> <span class="n">a</span> <span class="n">default</span> <span class="n">value</span><span class="p">,</span>
<span class="n">If</span> <span class="n">you</span> <span class="n">enter</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">the</span> <span class="n">field</span> <span class="n">will</span> <span class="n">be</span> <span class="n">left</span> <span class="n">blank</span><span class="o">.</span>
<span class="o">-----</span>
<span class="n">Country</span> <span class="n">Name</span> <span class="p">(</span><span class="mi">2</span> <span class="n">letter</span> <span class="n">code</span><span class="p">)</span> <span class="p">[</span><span class="n">AU</span><span class="p">]:</span><span class="n">US</span>
<span class="n">State</span> <span class="ow">or</span> <span class="n">Province</span> <span class="n">Name</span> <span class="p">(</span><span class="n">full</span> <span class="n">name</span><span class="p">)</span> <span class="p">[</span><span class="n">Some</span><span class="o">-</span><span class="n">State</span><span class="p">]:</span><span class="n">MyState</span>
<span class="n">Locality</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">city</span><span class="p">)</span> <span class="p">[]:</span><span class="n">Some</span> <span class="n">City</span>
<span class="n">Organization</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">company</span><span class="p">)</span> <span class="p">[</span><span class="n">Internet</span> <span class="n">Widgits</span> <span class="n">Pty</span> <span class="n">Ltd</span><span class="p">]:</span><span class="n">My</span> <span class="n">Organization</span><span class="p">,</span> <span class="n">Inc</span><span class="o">.</span>
<span class="n">Organizational</span> <span class="n">Unit</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">section</span><span class="p">)</span> <span class="p">[]:</span><span class="n">My</span> <span class="n">Group</span>
<span class="n">Common</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">YOUR</span> <span class="n">name</span><span class="p">)</span> <span class="p">[]:</span><span class="n">myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="n">Email</span> <span class="n">Address</span> <span class="p">[]:</span><span class="n">ops</span><span class="nd">@myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="o">%</span>
</pre></div>
</div>
<p>自己署名証明書の欠点は、それ自身がルート証明書であり、他の人はその証明書を持っていない (そして信頼しない)ことです。</p>
</div>
</div>
<div class="section" id="examples">
<h2>17.3.5. 例<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="testing-for-ssl-support">
<h3>17.3.5.1. SSLサポートをテストする<a class="headerlink" href="#testing-for-ssl-support" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>インストールされているPythonがSSLをサポートしているかどうかをテストするために、ユーザーコードは次のイディオムを利用することができます。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">ssl</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">else</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># do something that requires SSL support</span>
</pre></div>
</div>
</div>
<div class="section" id="client-side-operation">
<h3>17.3.5.2. クライアントサイドの処理<a class="headerlink" href="#client-side-operation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この例では、自動的に証明書の検証を行うことを含む望ましいセキュリティ設定でクライアントソケットの SSL コンテキストを作ります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>
</pre></div>
</div>
<p>あなた自身でセキュリティ設定を調整したいと望むなら、スクラッチからコンテキストを作ることは出来ます(ですが正しくない設定をしてしまいがちなことに警戒してください)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_SSLv23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">check_hostname</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">load_verify_locations</span><span class="p">(</span><span class="s2">&quot;/etc/ssl/certs/ca-bundle.crt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>(このスニペットは全ての CA 証明書が <code class="docutils literal"><span class="pre">/etc/ssl/certs/ca-bundle.crt</span></code> にバンドルされていることを仮定しています; もし違っていればエラーになりますので、適宜修正してください)</p>
<p>サーバへの接続にこのコンテキストを使うと、 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></code></a> でサーバの証明書の検証が行われます: サーバの証明書が CA 証明書のいずれかに署名されていて、その署名が正しいことを保障します。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">),</span>
<span class="gp">... </span>                           <span class="n">server_hostname</span><span class="o">=</span><span class="s2">&quot;www.python.org&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s2">&quot;www.python.org&quot;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>
</pre></div>
</div>
<p>そして証明書を持ってくることが出来ます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cert</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">getpeercert</span><span class="p">()</span>
</pre></div>
</div>
<p>証明書が、期待しているサービス (つまり、 HTTPS ホスト <code class="docutils literal"><span class="pre">www.python.org</span></code>) の身元を特定していることを視覚的に点検してみましょう:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">cert</span><span class="p">)</span>
<span class="go">{&#39;OCSP&#39;: (&#39;http://ocsp.digicert.com&#39;,),</span>
<span class="go"> &#39;caIssuers&#39;: (&#39;http://cacerts.digicert.com/DigiCertSHA2ExtendedValidationServerCA.crt&#39;,),</span>
<span class="go"> &#39;crlDistributionPoints&#39;: (&#39;http://crl3.digicert.com/sha2-ev-server-g1.crl&#39;,</span>
<span class="go">                           &#39;http://crl4.digicert.com/sha2-ev-server-g1.crl&#39;),</span>
<span class="go"> &#39;issuer&#39;: (((&#39;countryName&#39;, &#39;US&#39;),),</span>
<span class="go">            ((&#39;organizationName&#39;, &#39;DigiCert Inc&#39;),),</span>
<span class="go">            ((&#39;organizationalUnitName&#39;, &#39;www.digicert.com&#39;),),</span>
<span class="go">            ((&#39;commonName&#39;, &#39;DigiCert SHA2 Extended Validation Server CA&#39;),)),</span>
<span class="go"> &#39;notAfter&#39;: &#39;Sep  9 12:00:00 2016 GMT&#39;,</span>
<span class="go"> &#39;notBefore&#39;: &#39;Sep  5 00:00:00 2014 GMT&#39;,</span>
<span class="go"> &#39;serialNumber&#39;: &#39;01BB6F00122B177F36CAB49CEA8B6B26&#39;,</span>
<span class="go"> &#39;subject&#39;: (((&#39;businessCategory&#39;, &#39;Private Organization&#39;),),</span>
<span class="go">             ((&#39;1.3.6.1.4.1.311.60.2.1.3&#39;, &#39;US&#39;),),</span>
<span class="go">             ((&#39;1.3.6.1.4.1.311.60.2.1.2&#39;, &#39;Delaware&#39;),),</span>
<span class="go">             ((&#39;serialNumber&#39;, &#39;3359300&#39;),),</span>
<span class="go">             ((&#39;streetAddress&#39;, &#39;16 Allen Rd&#39;),),</span>
<span class="go">             ((&#39;postalCode&#39;, &#39;03894-4801&#39;),),</span>
<span class="go">             ((&#39;countryName&#39;, &#39;US&#39;),),</span>
<span class="go">             ((&#39;stateOrProvinceName&#39;, &#39;NH&#39;),),</span>
<span class="go">             ((&#39;localityName&#39;, &#39;Wolfeboro,&#39;),),</span>
<span class="go">             ((&#39;organizationName&#39;, &#39;Python Software Foundation&#39;),),</span>
<span class="go">             ((&#39;commonName&#39;, &#39;www.python.org&#39;),)),</span>
<span class="go"> &#39;subjectAltName&#39;: ((&#39;DNS&#39;, &#39;www.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;pypi.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;docs.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;testpypi.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;bugs.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;wiki.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;hg.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;mail.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;packaging.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;www.pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;test.pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;us.pycon.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;id.python.org&#39;)),</span>
<span class="go"> &#39;version&#39;: 3}</span>
</pre></div>
</div>
<p>SSL チャネルは今や確立されて証明書が検証されているので、サーバとのお喋りを続けることが出来ます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;HEAD / HTTP/1.0</span><span class="se">\r\n</span><span class="s2">Host: linuxfr.org</span><span class="se">\r\n\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">))</span>
<span class="go">[b&#39;HTTP/1.1 200 OK&#39;,</span>
<span class="go"> b&#39;Date: Sat, 18 Oct 2014 18:27:20 GMT&#39;,</span>
<span class="go"> b&#39;Server: nginx&#39;,</span>
<span class="go"> b&#39;Content-Type: text/html; charset=utf-8&#39;,</span>
<span class="go"> b&#39;X-Frame-Options: SAMEORIGIN&#39;,</span>
<span class="go"> b&#39;Content-Length: 45679&#39;,</span>
<span class="go"> b&#39;Accept-Ranges: bytes&#39;,</span>
<span class="go"> b&#39;Via: 1.1 varnish&#39;,</span>
<span class="go"> b&#39;Age: 2188&#39;,</span>
<span class="go"> b&#39;X-Served-By: cache-lcy1134-LCY&#39;,</span>
<span class="go"> b&#39;X-Cache: HIT&#39;,</span>
<span class="go"> b&#39;X-Cache-Hits: 11&#39;,</span>
<span class="go"> b&#39;Vary: Cookie&#39;,</span>
<span class="go"> b&#39;Strict-Transport-Security: max-age=63072000; includeSubDomains&#39;,</span>
<span class="go"> b&#39;Connection: close&#39;,</span>
<span class="go"> b&#39;&#39;,</span>
<span class="go"> b&#39;&#39;]</span>
</pre></div>
</div>
<p>このドキュメントの下の方の、 <a class="reference internal" href="#ssl-security"><span class="std std-ref">セキュリティで考慮すべき点</span></a> に関する議論を参照してください。</p>
</div>
<div class="section" id="server-side-operation">
<h3>17.3.5.3. サーバーサイドの処理<a class="headerlink" href="#server-side-operation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>サーバーサイドの処理では、通常、サーバー証明書と秘密鍵がそれぞれファイルに格納された形で必要です。最初に秘密鍵と証明書が保持されたコンテキストを作成し、クライアントがあなたの信憑性をチェック出来るようにします。そののちにソケットを開き、ポートにバインドし、そのソケットの <code class="xref py py-meth docutils literal"><span class="pre">listen()</span></code> を呼び、クライアントからの接続を待ちます。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">Purpose</span><span class="o">.</span><span class="n">CLIENT_AUTH</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_cert_chain</span><span class="p">(</span><span class="n">certfile</span><span class="o">=</span><span class="s2">&quot;mycertfile&quot;</span><span class="p">,</span> <span class="n">keyfile</span><span class="o">=</span><span class="s2">&quot;mykeyfile&quot;</span><span class="p">)</span>

<span class="n">bindsocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;myaddr.mydomain.com&#39;</span><span class="p">,</span> <span class="mi">10023</span><span class="p">))</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>クライアントが接続してきた場合、 <code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code> を呼んで新しいソケットを作成し、接続のためにサーバサイドの SSL ソケットを、コンテキストの <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></code></a> メソッドで作ります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">newsocket</span><span class="p">,</span> <span class="n">fromaddr</span> <span class="o">=</span> <span class="n">bindsocket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="n">connstream</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">newsocket</span><span class="p">,</span> <span class="n">server_side</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SHUT_RDWR</span><span class="p">)</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>そして、 <code class="docutils literal"><span class="pre">connstream</span></code> からデータを読み、クライアントと切断する(あるいはクライアントが切断してくる)まで何か処理をします。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="c1"># null data means the client is finished with us</span>
    <span class="k">while</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_something</span><span class="p">(</span><span class="n">connstream</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="c1"># we&#39;ll assume do_something returns False</span>
            <span class="c1"># when we&#39;re finished with client</span>
            <span class="k">break</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="c1"># finished with client</span>
</pre></div>
</div>
<p>そして新しいクライアント接続のために listen に戻ります。 (もちろん現実のサーバは、おそらく個々のクライアント接続ごとに別のスレッドで処理するか、ソケットをノンブロッキングモードにし、イベントループを使うでしょう。)</p>
</div>
</div>
<div class="section" id="notes-on-non-blocking-sockets">
<span id="ssl-nonblocking"></span><h2>17.3.6. ノンブロッキングソケットについての注意事項<a class="headerlink" href="#notes-on-non-blocking-sockets" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ノンブロッキングソケットとともに使う場合、いくつか気をつけなければならない事項があります:</p>
<ul>
<li><p class="first"><a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select()</span></code></a> 呼び出しは OS レベルでのソケットが読み出し可能(または書き込み可能)になったことを教えてくれますが、上位の SSL レイヤーでの十分なデータがあることを意味するわけではありません。例えば、SSL フレームの一部が届いただけかもしれません。ですから、 <code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.recv()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.send()</span></code> の失敗を処理することに備え、ほかの <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select()</span></code></a> 呼び出し後にリトライしなければなりません。</p>
</li>
<li><p class="first">反対に、SSL レイヤーは自身で独自の枠組みを持っているために、読み出せるけれども <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select()</span></code></a> が気付くことのないデータを SSL ソケットが持っていることがあります。ですので、潜在的に入手可能なデータを飲み干すために最初に <code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.recv()</span></code> を呼び出すべきであり、そののちでそれでもまだ必要な場合にだけ <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select()</span></code></a> でブロックすべきです。</p>
<p>(当然のことながら、ほかのプリミティブ、例えば <a class="reference internal" href="select.html#select.poll" title="select.poll"><code class="xref py py-func docutils literal"><span class="pre">poll()</span></code></a> や <code class="xref py py-mod docutils literal"><span class="pre">selectors</span></code> モジュール内のものを使う際にも似た但し書きが付きます)</p>
</li>
<li><p class="first">SSL ハンドシェイクそのものがノンブロッキングになります: <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.do_handshake()</span></code></a> メソッドは成功するまでリトライしなければなりません。 <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select()</span></code></a> を用いてソケットの準備が整うのを待つためには、およそ以下のようにします:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">do_handshake</span><span class="p">()</span>
        <span class="k">break</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLWantReadError</span><span class="p">:</span>
        <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">sock</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[])</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLWantWriteError</span><span class="p">:</span>
        <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([],</span> <span class="p">[</span><span class="n">sock</span><span class="p">],</span> <span class="p">[])</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="security-considerations">
<span id="ssl-security"></span><h2>17.3.7. セキュリティで考慮すべき点<a class="headerlink" href="#security-considerations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="best-defaults">
<h3>17.3.7.1. 最善のデフォルト値<a class="headerlink" href="#best-defaults" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><strong>クライアントでの使用</strong> では、あなたのセキュリティポリシーによる特殊な要件がない限りは、SSL コンテキストを作成するためには <a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal"><span class="pre">create_default_context()</span></code></a> 関数を使用することを強くお勧めします。それはシステムが信頼した CA 証明書をロードし、証明書の検証を有効化し、ホスト名のチェックを行い、そしてセキュアなプロトコルとセキュアな暗号の分別ある設定を試みます。</p>
<p>接続にクライアントの証明書が必要な場合、 <a class="reference internal" href="#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_cert_chain()</span></code></a> によって追加出来ます。</p>
<p>対照的に、 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> クラスのコンストラクタを自身で呼び出すことによって SSL コンテキストを作ると、デフォルトでは証明書検証もホスト名チェックも行わないものになります。もしそうするのであれば、良いセキュリティレベルを知るために、どうか下の方にあるパラグラフをお読みください。</p>
</div>
<div class="section" id="manual-settings">
<h3>17.3.7.2. 手動での設定<a class="headerlink" href="#manual-settings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="verifying-certificates">
<h4>17.3.7.2.1. 証明書の検証<a class="headerlink" href="#verifying-certificates" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> のコンストラクタを直接呼び出した場合、 <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></code></a> がデフォルトとして使われます。これは接続先の身元特定をしないので安全ではありませんし、特にクライアントモードでは大抵相手となるサーバの信憑性を保障したいでしょう。ですから、クライアントモードでは <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></code></a> を強くお勧めします。ですが、それだけでは不十分です; <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.getpeercert()</span></code></a> を呼び出してサーバ証明書が望んだサービスと合致するかのチェックもしなければなりません。多くのプロトコルとアプリケーションにとって、サービスはホスト名で特定されます; この場合、 <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal"><span class="pre">match_hostname()</span></code></a> が使えます。これらの共通的なチェックは <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.check_hostname</span></code></a> が有効な場合、自動的に行われます。</p>
<p>サーバモードにおいて、(より上位のレベルでの認証メカニズムではなく) SSL レイヤーを使ってあなたのクライアントを認証したいならば、 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></code></a> を指定して同じようにクライアントの証明書を検証すべきでしょう。</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">クライアントモードでは anonymous ciphers が有効(デフォルトでは無効)でない限り、 <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal"><span class="pre">CERT_OPTIONAL</span></code></a> と <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></code></a> は同じ意味になります。</p>
</div>
</div></blockquote>
</div>
<div class="section" id="protocol-versions">
<h4>17.3.7.2.2. プロトコルのバージョン<a class="headerlink" href="#protocol-versions" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>SSL versions 2 と 3 は非セキュアと考えられており、それゆえその使用は危険です。クライアントとサーバの最大限の互換性が欲しいならば、 <a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-data docutils literal"><span class="pre">SSLContext.options</span></code></a> 属性で明示的に SSLv2, SSLv3 を無効にして <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a> を使ってください:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_SSLv23</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">options</span> <span class="o">|=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">OP_NO_SSLv2</span>
<span class="n">context</span><span class="o">.</span><span class="n">options</span> <span class="o">|=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">OP_NO_SSLv3</span>
</pre></div>
</div>
<p>上で作った SSL コンテキストは TLSv1 かそれ以降(あなたのシステムでサポートされていれば)だけでの接続を許可します。</p>
</div>
<div class="section" id="cipher-selection">
<h4>17.3.7.2.3. 暗号の選択<a class="headerlink" href="#cipher-selection" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>If you have advanced security requirements, fine-tuning of the ciphers
enabled when negotiating a SSL session is possible through the
<a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.set_ciphers()</span></code></a> method.  Starting from Python 2.7.9, the
ssl module disables certain weak ciphers by default, but you may want
to further restrict the cipher choice. Be sure to read OpenSSL&#8217;s documentation
about the <a class="reference external" href="https://www.openssl.org/docs/apps/ciphers.html#CIPHER-LIST-FORMAT">cipher list format</a>.
If you want to check which ciphers are enabled by a given cipher list, use the
<code class="docutils literal"><span class="pre">openssl</span> <span class="pre">ciphers</span></code> command on your system.</p>
</div>
</div>
<div class="section" id="multi-processing">
<h3>17.3.7.3. マルチプロセス化<a class="headerlink" href="#multi-processing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>(例えば <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based &quot;threading&quot; interface."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> や <code class="xref py py-mod docutils literal"><span class="pre">concurrent.futures</span></code> を使って、)マルチプロセスアプリケーションの一部としてこのモジュールを使う場合、OpenSSL の内部の乱数発生器は fork したプロセスを適切に処理しないことに気を付けて下さい。SSL の機能を <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">os.fork()</span></code></a> とともに使う場合、アプリケーションは親プロセスの PRNG 状態を変更しなければなりません。 <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal"><span class="pre">RAND_add()</span></code></a>, <code class="xref py py-func docutils literal"><span class="pre">RAND_bytes()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">RAND_pseudo_bytes()</span></code> のいずれかの呼び出し成功があれば十分です。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> クラス</dt>
<dd><p class="first last">下位レイヤーの <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> クラスのドキュメント</p>
</dd>
<dt><a class="reference external" href="https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html">SSL/TLS Strong Encryption: An Introduction</a></dt>
<dd><p class="first last">Apache WEBサーバのドキュメンテーションのイントロ</p>
</dd>
<dt><a class="reference external" href="https://www.ietf.org/rfc/rfc1422">RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management</a></dt>
<dd>Steve Kent</dd>
<dt><a class="reference external" href="https://www.ietf.org/rfc/rfc1750">RFC 1750: Randomness Recommendations for Security</a></dt>
<dd>D. Eastlake et. al.</dd>
<dt><a class="reference external" href="https://www.ietf.org/rfc/rfc3280">RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile</a></dt>
<dd>Housley et. al.</dd>
<dt><a class="reference external" href="https://www.ietf.org/rfc/rfc4366">RFC 4366: Transport Layer Security (TLS) Extensions</a></dt>
<dd>Blake-Wilson et. al.</dd>
<dt><a class="reference external" href="https://tools.ietf.org/html/rfc5246">RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2</a></dt>
<dd>T. Dierks et. al.</dd>
<dt><a class="reference external" href="https://tools.ietf.org/html/rfc6066">RFC 6066: Transport Layer Security (TLS) Extensions</a></dt>
<dd>D. Eastlake</dd>
<dt><a class="reference external" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml">IANA TLS: Transport Layer Security (TLS) Parameters</a></dt>
<dd>IANA</dd>
</dl>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">17.3. <code class="docutils literal"><span class="pre">ssl</span></code> &#8212; ソケットオブジェクトに対する TLS/SSL ラッパー</a><ul>
<li><a class="reference internal" href="#functions-constants-and-exceptions">17.3.1. 関数、定数、例外</a><ul>
<li><a class="reference internal" href="#socket-creation">17.3.1.1. ソケットの作成</a></li>
<li><a class="reference internal" href="#context-creation">17.3.1.2. コンテキストの作成</a></li>
<li><a class="reference internal" href="#random-generation">17.3.1.3. 乱数生成</a></li>
<li><a class="reference internal" href="#certificate-handling">17.3.1.4. 証明書の取り扱い</a></li>
<li><a class="reference internal" href="#constants">17.3.1.5. 定数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ssl-sockets">17.3.2. SSL ソケット</a></li>
<li><a class="reference internal" href="#ssl-contexts">17.3.3. SSL コンテキスト</a></li>
<li><a class="reference internal" href="#certificates">17.3.4. 証明書</a><ul>
<li><a class="reference internal" href="#certificate-chains">17.3.4.1. 証明書チェイン</a></li>
<li><a class="reference internal" href="#ca-certificates">17.3.4.2. CA 証明書</a></li>
<li><a class="reference internal" href="#combined-key-and-certificate">17.3.4.3. 秘密鍵と証明書を一緒にする</a></li>
<li><a class="reference internal" href="#self-signed-certificates">17.3.4.4. 自己署名証明書</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">17.3.5. 例</a><ul>
<li><a class="reference internal" href="#testing-for-ssl-support">17.3.5.1. SSLサポートをテストする</a></li>
<li><a class="reference internal" href="#client-side-operation">17.3.5.2. クライアントサイドの処理</a></li>
<li><a class="reference internal" href="#server-side-operation">17.3.5.3. サーバーサイドの処理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#notes-on-non-blocking-sockets">17.3.6. ノンブロッキングソケットについての注意事項</a></li>
<li><a class="reference internal" href="#security-considerations">17.3.7. セキュリティで考慮すべき点</a><ul>
<li><a class="reference internal" href="#best-defaults">17.3.7.1. 最善のデフォルト値</a></li>
<li><a class="reference internal" href="#manual-settings">17.3.7.2. 手動での設定</a><ul>
<li><a class="reference internal" href="#verifying-certificates">17.3.7.2.1. 証明書の検証</a></li>
<li><a class="reference internal" href="#protocol-versions">17.3.7.2.2. プロトコルのバージョン</a></li>
<li><a class="reference internal" href="#cipher-selection">17.3.7.2.3. 暗号の選択</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multi-processing">17.3.7.3. マルチプロセス化</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="socket.html"
                        title="前の章へ">17.2. <code class="docutils literal"><span class="pre">socket</span></code> &#8212; 低レベルネットワークインターフェース</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="signal.html"
                        title="次の章へ">17.4. <code class="docutils literal"><span class="pre">signal</span></code> &#8212; 非同期イベントにハンドラを設定する</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">バグ報告</a></li>
  <li><a href="https://github.com/python/cpython/blob/2.7/Doc/library/ssl.rst"
         rel="nofollow">ソースの表示</a>
  </li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="signal.html" title="17.4. signal — 非同期イベントにハンドラを設定する"
             >次へ</a> |</li>
        <li class="right" >
          <a href="socket.html" title="17.2. socket — 低レベルネットワークインターフェース"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.13</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >17. プロセス間通信とネットワーク</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト).
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    Last updated on 2017-03-24.
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>