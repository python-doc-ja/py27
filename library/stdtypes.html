
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>5. 組み込み型 &#8212; Python 2.7.14 ドキュメント</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.14',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7.14 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="6. 組み込み例外" href="exceptions.html" />
    <link rel="prev" title="4. 組み込み定数" href="constants.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/stdtypes.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="exceptions.html" title="6. 組み込み例外"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="constants.html" title="4. 組み込み定数"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.14</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 標準ライブラリ</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="built-in-types">
<span id="bltin-types"></span><h1>5. 組み込み型<a class="headerlink" href="#built-in-types" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>以下のセクションでは、インタプリタに組み込まれている標準型について記述します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">これまでの (リリース 2.2 までの) Python の歴史では、組み込み型はオブジェクト指向における継承を行う際に雛型にできないという点で、ユーザ定義型とは異なっていました。いまではこのような制限はなくなっています。</p>
</div>
<p id="index-0">主要な組み込み型は数値型、シーケンス型、マッピング型、ファイル、クラス、インスタンス型、および例外です。</p>
<p id="index-1">演算によっては、複数の型でサポートされているものがあります; 特に、ほぼ全てのオブジェクトについて、比較、真理値テスト、 (<a class="reference internal" href="functions.html#func-repr"><span class="std std-ref">repr()</span></a> 関数や、わずかに異なる <a class="reference internal" href="functions.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> 関数による) 文字列への変換を行うことができます。オブジェクトが <a class="reference internal" href="functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> 関数で印字されるとき、文字列に変換する関数が暗黙に使われます。</p>
<div class="section" id="truth-value-testing">
<span id="truth"></span><h2>5.1. 真理値判定<a class="headerlink" href="#truth-value-testing" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-2">どのオブジェクトも真理値を判定でき、 <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> や <a class="reference internal" href="../reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal"><span class="pre">while</span></code></a> 条件に、または以下のブール演算の被演算子に使えます。以下の値は偽と見なされます:</p>
<blockquote>
<div></div></blockquote>
<ul id="index-3">
<li><p class="first"><code class="docutils literal"><span class="pre">None</span></code></p>
</li>
<li id="index-4"><p class="first"><code class="docutils literal"><span class="pre">False</span></code></p>
</li>
<li><p class="first">数値型におけるゼロ。例えば <code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">0L</span></code>, <code class="docutils literal"><span class="pre">0.0</span></code>, <code class="docutils literal"><span class="pre">0j</span></code> 。</p>
</li>
<li><p class="first">空のシーケンス。例えば <code class="docutils literal"><span class="pre">''</span></code>, <code class="docutils literal"><span class="pre">()</span></code>, <code class="docutils literal"><span class="pre">[]</span></code> 。</p>
</li>
<li><p class="first">空のマッピング。例えば <code class="docutils literal"><span class="pre">{}</span></code> 。</p>
</li>
<li><p class="first">ユーザ定義クラスのインスタンスで、そのクラスが <a class="reference internal" href="../reference/datamodel.html#object.__nonzero__" title="object.__nonzero__"><code class="xref py py-meth docutils literal"><span class="pre">__nonzero__()</span></code></a> または <a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> メソッドを定義していれば、それらのメソッドが整数 0 または <a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-class docutils literal"><span class="pre">bool</span></code></a> 値 <code class="docutils literal"><span class="pre">False</span></code> を返すとき。 <a class="footnote-reference" href="#id12" id="id1">[1]</a></p>
</li>
</ul>
<p id="index-5">それ以外の全ての値は真と見なされます — 従って、多くの型のオブジェクトは常に真です。</p>
<p id="index-6">ブール値の結果を返す演算および組み込み関数は、特に注釈のない限り常に偽値として <code class="docutils literal"><span class="pre">0</span></code> または <code class="docutils literal"><span class="pre">False</span></code> を返し、真値として <code class="docutils literal"><span class="pre">1</span></code> または <code class="docutils literal"><span class="pre">True</span></code> を返します。 (重要な例外: ブール演算 <code class="docutils literal"><span class="pre">or</span></code> および <code class="docutils literal"><span class="pre">and</span></code> は常に被演算子のうちの一つを返します。)</p>
</div>
<div class="section" id="boolean-operations-and-or-not">
<span id="boolean"></span><h2>5.2. ブール演算 — <a class="reference internal" href="../reference/expressions.html#and"><code class="xref std std-keyword docutils literal"><span class="pre">and</span></code></a>, <a class="reference internal" href="../reference/expressions.html#or"><code class="xref std std-keyword docutils literal"><span class="pre">or</span></code></a>, <a class="reference internal" href="../reference/expressions.html#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a><a class="headerlink" href="#boolean-operations-and-or-not" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-7">以下にブール演算を、優先順位が低い順に示します:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="62%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code></td>
<td><em>x</em> が偽なら <em>y</em>, そうでなければ <em>x</em></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code></td>
<td><em>x</em> が偽なら <em>x</em>, そうでなければ <em>y</em></td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">not</span> <span class="pre">x</span></code></td>
<td><em>x</em> が偽なら <code class="docutils literal"><span class="pre">True</span></code>, そうでなければ <code class="docutils literal"><span class="pre">False</span></code></td>
<td>(3)</td>
</tr>
</tbody>
</table>
<p id="index-8">注釈:</p>
<ol class="arabic simple">
<li>この演算子は短絡評価されます。つまり第一引数が偽のときにのみ、第二引数が評価されます。</li>
<li>この演算子は短絡評価されます。つまり第一引数が真のときにのみ、第二引数が評価されます。</li>
<li><code class="docutils literal"><span class="pre">not</span></code> は非ブール演算子よりも優先度が低いので、 <code class="docutils literal"><span class="pre">not</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code> は <code class="docutils literal"><span class="pre">not</span> <span class="pre">(a</span> <span class="pre">==</span> <span class="pre">b)</span></code> と解釈され、 <code class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">not</span> <span class="pre">b</span></code> は構文エラーです。</li>
</ol>
</div>
<div class="section" id="comparisons">
<span id="stdcomparisons"></span><h2>5.3. 比較<a class="headerlink" href="#comparisons" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-9">比較演算は全てのオブジェクトでサポートされています。比較演算子は全て同じ演算優先度を持っています (ブール演算より高い演算優先度です)。比較は任意の形で連鎖させることができます; 例えば、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> と等価で、違うのは <em>y</em> が一度だけしか評価されないということです (どちらの場合でも、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> が偽となった場合には <em>z</em> は評価されません)。</p>
<p>以下の表に比較演算をまとめます:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="57%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">意味</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&lt;</span></code></td>
<td>より小さい</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;=</span></code></td>
<td>以下</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&gt;</span></code></td>
<td>より大きい</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&gt;=</span></code></td>
<td>以上</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">==</span></code></td>
<td>等しい</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">!=</span></code></td>
<td>等しくない</td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">is</span></code></td>
<td>同一のオブジェクトである</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></td>
<td>同一のオブジェクトでない</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>注釈:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">!=</span></code> は <code class="docutils literal"><span class="pre">&lt;&gt;</span></code> とも書けますがこれは時代遅れの書き方で、後方互換性維持のためだけに残されています。新しいコードでは常に <code class="docutils literal"><span class="pre">!=</span></code> を使うべきです。</li>
</ol>
<p id="index-10">数値型間の比較か文字列間の比較でないかぎり、異なる型のオブジェクトを比較しても等価になることはありません; これらのオブジェクトの順番付けは一貫してはいますが任意のものです (従って要素の型が一様でないシーケンスをソートした結果は一貫したものになります)。さらに、 (例えばファイルオブジェクトのように) 型によっては、その型の 2 つのオブジェクトの不等性だけの、縮退した比較の概念しかサポートしないものもあります。繰り返しますが、そのようなオブジェクトも任意の順番付けをされていますが、それは一貫したものです。被演算子が複素数の場合、演算子 <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code> および <code class="docutils literal"><span class="pre">&gt;=</span></code> は例外 <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出します。</p>
<p id="index-11">あるクラスの同一でないインスタンスは、通常等価でないとされますが、そのクラスが <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> メソッドか <a class="reference internal" href="../reference/datamodel.html#object.__cmp__" title="object.__cmp__"><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code></a> メソッドを定義している場合は除きます。</p>
<p>クラスのインスタンスは、そのクラスが十分なだけの拡張比較メソッド (<a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal"><span class="pre">__le__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal"><span class="pre">__gt__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal"><span class="pre">__ge__()</span></code></a>) または <a class="reference internal" href="../reference/datamodel.html#object.__cmp__" title="object.__cmp__"><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code></a> メソッドを定義していない限り、同じクラスの別のインスタンスや他の型のオブジェクトとは順序付けできません。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> 数値型を除き、異なる型のオブジェクトは型の名前で順番付けされます; 適当な比較をサポートしていないある型のオブジェクトはアドレスによって順番付けされます。</p>
</div>
<p id="index-12">同じ優先度を持つ演算子としてさらに 2 つ、シーケンス型でのみ <code class="docutils literal"><span class="pre">in</span></code> および <code class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></code> がサポートされています (以下を参照)。</p>
</div>
<div class="section" id="numeric-types-int-float-long-complex">
<span id="typesnumeric"></span><h2>5.4. 数値型 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#long" title="long"><code class="xref py py-class docutils literal"><span class="pre">long</span></code></a>, <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a><a class="headerlink" href="#numeric-types-int-float-long-complex" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-13">4 つの異なる数値型があります: <em class="dfn">通常の整数型</em>, <em class="dfn">長整数型</em>, <em class="dfn">浮動小数点型</em>, <em class="dfn">複素数型</em> です。さらに、真偽値(Boolean)型も通常の整数型のサブタイプです。通常の整数 (単に <em class="dfn">整数型</em> とも呼ばれます) は C言語の <code class="xref c c-type docutils literal"><span class="pre">long</span></code> 型を使って実装されており、少なくとも 32 ビットの精度があります (<code class="docutils literal"><span class="pre">sys.maxint</span></code> は常に通常の整数の各プラットフォームにおける最大値にセットされており、最小値は <code class="docutils literal"><span class="pre">-sys.maxint</span> <span class="pre">-</span> <span class="pre">1</span></code> になります)。長整数型には精度の制限がありません。浮動小数点型はたいていは C の <code class="xref c c-type docutils literal"><span class="pre">double</span></code> を使って実装されています; あなたのプログラムが動作するマシンでの浮動小数点型の精度と内部表現は、 <a class="reference internal" href="sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal"><span class="pre">sys.float_info</span></code></a> から利用できます。複素数型は実部と虚部を持ち、それぞれ浮動小数点数です。複素数 <em>z</em> から実部および虚部を取り出すには、 <code class="docutils literal"><span class="pre">z.real</span></code> および <code class="docutils literal"><span class="pre">z.imag</span></code> を使ってください。 (標準ライブラリには、追加の数値型、分数を保持する <a class="reference internal" href="fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal"><span class="pre">fractions</span></code></a> や、ユーザ定義の精度の浮動小数点数を保持する <a class="reference internal" href="decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> があります。)</p>
<p id="index-14">数値は、数値リテラルや組み込み関数や演算子の戻り値として生成されます。修飾のない整数リテラル ( 2 進表現や、 16 進表現や 8 進表現の値も含みます) は、通常の整数値を表します。値が通常の整数で表すには大きすぎる場合、 <code class="docutils literal"><span class="pre">'L'</span></code> または <code class="docutils literal"><span class="pre">'l'</span></code> が末尾につく整数リテラルは長整数型を表します (<code class="docutils literal"><span class="pre">'L'</span></code> が望ましいです。というのは <code class="docutils literal"><span class="pre">1l</span></code> は 11 と非常に紛らわしいからです!)。小数点または指数表記のある数値リテラルは浮動小数点数を表します。数値リテラルに <code class="docutils literal"><span class="pre">'j'</span></code> または <code class="docutils literal"><span class="pre">'J'</span></code> をつけると虚数 (実数部がゼロの複素数) を表し、それと整数や浮動小数点数を足すと実部と虚部を持つ複素数が得られます。</p>
<p id="index-15">Python は型混合の演算を完全にサポートします: ある 2 項演算子が互いに異なる数値型の被演算子を持つ場合、より &quot;制限された&quot; 型の被演算子は他方の型に合わせて広げられます。ここで通常の整数は長整数より制限されており、長整数は浮動小数点数より制限されており、浮動小数点は複素数より制限されています。型混合の数値間での比較も同じ規則に従います。 <a class="footnote-reference" href="#id13" id="id2">[2]</a> コンストラクタ <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a>, <a class="reference internal" href="functions.html#long" title="long"><code class="xref py py-func docutils literal"><span class="pre">long()</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a>, および <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a> を使って、特定の型の数を生成することができます。</p>
<p>全ての組み込み数値型は以下の演算をサポートします。演算子の優先度については、 <a class="reference internal" href="../reference/expressions.html#power"><span class="std std-ref">べき乗演算 (power operator)</span></a>,および、あとのセクションを参照下さい。</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="54%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> の和</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> の差</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> の積</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> の商</td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">//</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> の商 (を切り下げたもの)</td>
<td>(4)(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code></td>
<td><code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> の剰余</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">-x</span></code></td>
<td><em>x</em> の符号反転</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">+x</span></code></td>
<td><em>x</em> そのまま</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">abs(x)</span></code></td>
<td><em>x</em> の絶対値または大きさ</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">int(x)</span></code></td>
<td><em>x</em> の整数への変換</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">long(x)</span></code></td>
<td><em>x</em> の長整数への変換</td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">float(x)</span></code></td>
<td><em>x</em> の浮動小数点数への変換</td>
<td>(6)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">complex(re,im)</span></code></td>
<td>実部 <em>re</em>, 虚部 <em>im</em> の複素数。 <em>im</em> の既定値はゼロ。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">c.conjugate()</span></code></td>
<td>複素数 <em>c</em> の共役複素数 (実数に対しては同じ値を返す)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">divmod(x,</span> <span class="pre">y)</span></code></td>
<td><code class="docutils literal"><span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y,</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y)</span></code> からなるペア</td>
<td>(3)(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span></code></td>
<td><em>x</em> の <em>y</em> 乗</td>
<td>(3)(7)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">y</span></code></td>
<td><em>x</em> の <em>y</em> 乗</td>
<td>(7)</td>
</tr>
</tbody>
</table>
<p id="index-16">注釈:</p>
<ol class="arabic">
<li><p id="index-17">(通常および長) 整数の割り算では、結果は整数になります。この場合値は常にマイナス無限大の方向に丸められます: つまり、1/2 は 0、 (-1)/2 は -1、1/(-1) は -1、そして (-1)/(-2) は 0 になります。被演算子の両方が長整数の場合、計算値に関わらず結果は長整数で返されるので注意してください。</p>
</li>
<li><p id="index-18">浮動小数点数から <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a>,または、 <a class="reference internal" href="functions.html#long" title="long"><code class="xref py py-func docutils literal"><span class="pre">long()</span></code></a> を使った変換では、関連する関数、 <a class="reference internal" href="math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal"><span class="pre">math.trunc()</span></code></a> のようにゼロ方向へ丸められます。下方向への丸めには <a class="reference internal" href="math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal"><span class="pre">math.floor()</span></code></a> を使い、上方向への丸めには <a class="reference internal" href="math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal"><span class="pre">math.ceil()</span></code></a> を使って下さい。</p>
</li>
<li><p class="first">完全な記述については、 <a class="reference internal" href="functions.html#built-in-funcs"><span class="std std-ref">組み込み関数</span></a>,を参照してください。</p>
</li>
<li><div class="first deprecated">
<p><span class="versionmodified">バージョン 2.3 で撤廃: </span>切り捨て除算演算子、モジュロ演算子、および <a class="reference internal" href="functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a> 関数は、複素数に対してはもはや定義されていません。目的に合うならば、代わりに <a class="reference internal" href="functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a> を使って浮動小数点に変換してください。</p>
</div>
</li>
<li><p class="first">整数の除算とも呼ばれます。結果の型は整数型とは限りませんが、結果の値は整数です。</p>
</li>
<li><p class="first">浮動小数点数は、文字列 &quot;nan&quot; と &quot;inf&quot; を、必要なら接頭辞 &quot;+&quot; または &quot;-&quot; と共に、非数 (Not a Number (NaN)) や正、負の無限大として受け付けます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</li>
<li><p class="first">Python は、プログラム言語一般でそうであるように、 <code class="docutils literal"><span class="pre">pow(0,</span> <span class="pre">0)</span></code> および <code class="docutils literal"><span class="pre">0</span> <span class="pre">**</span> <span class="pre">0</span></code> を <code class="docutils literal"><span class="pre">1</span></code> と定義します。</p>
</li>
</ol>
<p>全ての <a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal"><span class="pre">numbers.Real</span></code></a> 型 (<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#long" title="long"><code class="xref py py-class docutils literal"><span class="pre">long</span></code></a>,および、 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>) は以下の演算を含みます。 :</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal"><span class="pre">math.trunc(x)</span></code></a></td>
<td><em>x</em> を <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a> (整数) に切り捨てます</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="functions.html#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round(x[,</span>
<span class="pre">n])</span></code></a></td>
<td><em>x</em> を <em>n</em> 桁に丸めます。丸め方は四捨五入です。 <em>n</em> が省略されれば 0 がデフォルトとなります。(–訳注: Python 3 と仕様が違うので注意してください。1.5 と 2.5 の round は、Python 2 ではそれぞれ 2、3 となり、Python 3 では 2、2 となります。後者の丸めは .5 を丸める際に偶数になる方へ丸めるので、「偶数丸め」と言います。–)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal"><span class="pre">math.floor(x)</span></code></a></td>
<td><em>x</em> 以下の最大の整数を浮動小数点数として返します</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal"><span class="pre">math.ceil(x)</span></code></a></td>
<td><em>x</em> 以上の最小の整数を浮動小数点数として返します</td>
</tr>
</tbody>
</table>
<div class="section" id="bitwise-operations-on-integer-types">
<span id="bitstring-ops"></span><h3>5.4.1. 整数型におけるビット単位演算<a class="headerlink" href="#bitwise-operations-on-integer-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-19">ビット単位演算は、整数に対してのみ意味があります。負の数は、その 2 の補数の値として扱われます (演算中にオーバフローが起こらないように十分なビット数があるものと仮定します) 。</p>
<p>二項ビット単位演算の優先順位は全て、数値演算よりも低く、比較よりも高いです; 単項演算 <code class="docutils literal"><span class="pre">~</span></code> の優先順位は他の単項数値演算 (<code class="docutils literal"><span class="pre">+</span></code> および <code class="docutils literal"><span class="pre">-</span></code>) と同じです。</p>
<p>以下の表では、ビット単位演算を優先順位が低い順に並べています:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="59%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">|</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> のビット単位 <em class="dfn">論理和</em></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">^</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> のビット単位 <em class="dfn">排他的論理和</em></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">&amp;</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> のビット単位 <em class="dfn">論理積</em></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">n</span></code></td>
<td><em>x</em> の <em>n</em> ビット左シフト</td>
<td>(1)(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">n</span></code></td>
<td><em>x</em> の <em>n</em> ビット右シフト</td>
<td>(1)(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">~x</span></code></td>
<td><em>x</em> のビット反転</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>注釈:</p>
<ol class="arabic simple">
<li>負値のシフト数は不正であり、 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。</li>
<li><em>n</em> ビットの左シフトは、 <code class="docutils literal"><span class="pre">pow(2,</span> <span class="pre">n)</span></code> による乗算と等価です。通常整数の範囲を超える結果になる場合は長整数で返されます。</li>
<li><em>n</em> ビットの右シフトは、 <code class="docutils literal"><span class="pre">pow(2,</span> <span class="pre">n)</span></code> による除算と等価です。</li>
</ol>
</div>
<div class="section" id="additional-methods-on-integer-types">
<h3>5.4.2. 整数型における追加のメソッド<a class="headerlink" href="#additional-methods-on-integer-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>整数型は <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">numbers.Integral</span></code></a> <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> を実装します。さらに、追加のメソッドを一つ提供します。</p>
<dl class="method">
<dt id="int.bit_length">
<code class="descclassname">int.</code><code class="descname">bit_length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#int.bit_length" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="long.bit_length">
<code class="descclassname">long.</code><code class="descname">bit_length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#long.bit_length" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>整数を、符号と先頭の 0 は除いて二進法で表すために必要なビットの数を返します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">&#39;-0b100101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>正確には、 <code class="docutils literal"><span class="pre">x</span></code> が非 0 なら、 <code class="docutils literal"><span class="pre">x.bit_length()</span></code> は <code class="docutils literal"><span class="pre">2**(k-1)</span> <span class="pre">&lt;=</span> <span class="pre">abs(x)</span> <span class="pre">&lt;</span> <span class="pre">2**k</span></code> を満たす唯一の正の整数 <code class="docutils literal"><span class="pre">k</span></code> です。同様に、 <code class="docutils literal"><span class="pre">abs(x)</span></code> が十分小さくて対数を適切に丸められるとき、 <code class="docutils literal"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">int(log(abs(x),</span> <span class="pre">2))</span></code> です。 <code class="docutils literal"><span class="pre">x</span></code> が 0 なら、 <code class="docutils literal"><span class="pre">x.bit_length()</span></code> は <code class="docutils literal"><span class="pre">0</span></code> を返します。</p>
<p>次と等価です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bit_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>       <span class="c1"># binary representation:  bin(-37) --&gt; &#39;-0b100101&#39;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;-0b&#39;</span><span class="p">)</span> <span class="c1"># remove leading zeros and minus sign</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>       <span class="c1"># len(&#39;100101&#39;) --&gt; 6</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="additional-methods-on-float">
<h3>5.4.3. 浮動小数点数に対する追加のメソッド<a class="headerlink" href="#additional-methods-on-float" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>浮動小数点数型は、 <a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal"><span class="pre">numbers.Real</span></code></a> 抽象基底クラス (<a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>) を実装しています。浮動小数点型はまた、以下の追加のメソッドを持ちます。</p>
<dl class="method">
<dt id="float.as_integer_ratio">
<code class="descclassname">float.</code><code class="descname">as_integer_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.as_integer_ratio" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>比が元の浮動小数点数とちょうど同じで分母が正である、一対の整数を返します。無限大に対しては <a class="reference internal" href="exceptions.html#exceptions.OverflowError" title="exceptions.OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> を、非数 (NaN) に対しては <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="float.is_integer">
<code class="descclassname">float.</code><code class="descname">is_integer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.is_integer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>浮動小数点数インスタンスが有限の整数値なら <code class="docutils literal"><span class="pre">True</span></code> を、そうでなければ <code class="docutils literal"><span class="pre">False</span></code> を返します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<p>16 進表記の文字列へ、または、 16 進表記からの変換をサポートする二つのメソッドがあります。 Python の浮動小数点数は内部的には2進数で保持されるので、浮動小数点数の <em>10進数</em> へまたは <em>10進数</em> から変換には若干の丸め誤差があります。それに対し、16 進表記では、浮動小数点数を正確に表現できます。これはデバッグのときや、数学的な用途 (numerical work) に便利でしょう。</p>
<dl class="method">
<dt id="float.hex">
<code class="descclassname">float.</code><code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.hex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>浮動小数点数の 16 進文字列表現を返します。有限の浮動小数点数に対し、この表現は常に <code class="docutils literal"><span class="pre">0x</span></code> で始まり <code class="docutils literal"><span class="pre">p</span></code> と指数が続きます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="float.fromhex">
<code class="descclassname">float.</code><code class="descname">fromhex</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#float.fromhex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>16 進文字列表現 <em>s</em> で表される、浮動小数点数を返すクラスメソッドです。文字列 <em>s</em> は、前や後にホワイトスペースを含んでいても構いません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<p><a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal"><span class="pre">float.fromhex()</span></code></a> はクラスメソッドですが、 <a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></code></a> はインスタンスメソッドであることに注意して下さい。</p>
<p>16 進文字列表現は以下の書式となります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="p">[</span><span class="s1">&#39;0x&#39;</span><span class="p">]</span> <span class="n">integer</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span> <span class="n">fraction</span><span class="p">]</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="n">exponent</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">sign</span></code> は必須ではなく、 <code class="docutils literal"><span class="pre">+</span></code> と <code class="docutils literal"><span class="pre">-</span></code> のどちらかです。 <code class="docutils literal"><span class="pre">integer</span></code> と <code class="docutils literal"><span class="pre">fraction</span></code> は 16 進数の文字列で、 <code class="docutils literal"><span class="pre">exponent</span></code> は 10 進数で符号もつけられます。大文字・小文字は区別されず、最低でも 1 つの 16 進数文字を整数部もしくは小数部に含む必要があります。この制限は C99 規格のセクション 6.4.4.2 で規定されていて、 Java 1.5 以降でも使われています。特に、 <a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></code></a> の出力は C や Java コード中で、浮動小数点数の 16 進表記として役に立つでしょう。また、 C の <code class="docutils literal"><span class="pre">%a</span></code> 書式や、 Java の <code class="docutils literal"><span class="pre">Double.toHexString</span></code> で書きだされた文字列は <a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal"><span class="pre">float.fromhex()</span></code></a> で受け付けられます。</p>
<p>なお、指数部は 16 進数ではなく 10 進数で書かれ、係数に掛けられる 2 の累乗を与えます。例えば、16 進文字列 <code class="docutils literal"><span class="pre">0x3.a7p10</span></code> は浮動小数点数 <code class="docutils literal"><span class="pre">(3</span> <span class="pre">+</span> <span class="pre">10./16</span> <span class="pre">+</span> <span class="pre">7./16**2)</span> <span class="pre">*</span> <span class="pre">2.0**10</span></code> すなわち <code class="docutils literal"><span class="pre">3740.0</span></code> を表します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;0x3.a7p10&#39;</span><span class="p">)</span>
<span class="go">3740.0</span>
</pre></div>
</div>
<p>逆変換を <code class="docutils literal"><span class="pre">3740.0</span></code> に適用すると、同じ数を表す異なる 16 進文字列表現を返します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="mf">3740.0</span><span class="p">)</span>
<span class="go">&#39;0x1.d380000000000p+11&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="iterator-types">
<span id="typeiter"></span><h2>5.5. イテレータ型<a class="headerlink" href="#iterator-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.2 で追加.</span></p>
</div>
<p id="index-20">Python はコンテナでの反復処理の概念をサポートしています。この概念は 2 つの別々のメソッドを使って実装されています; これらのメソッドを使ってユーザ定義のクラスで反復を行えるようにできます。後に詳しく述べるシーケンスは、必ず反復処理メソッドをサポートしています。</p>
<p>コンテナオブジェクトに反復処理をサポートさせるためには、以下のメソッドを定義しなければなりません:</p>
<dl class="method">
<dt id="container.__iter__">
<code class="descclassname">container.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#container.__iter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イテレータオブジェクトを返します。オブジェクトは後述するイテレータプロトコルをサポートする必要があります。もしコンテナが異なる型の反復処理をサポートするなら、それらの反復処理毎に追加のメソッドを提供しても構いません (複数の形式の反復処理を提供するオブジェクトの例として、幅優先探索と深さ優先探索をサポートする木構造が挙げられます)。このメソッドは Python/C API での Python オブジェクトの型構造体の <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a> スロットに対応します。</p>
</dd></dl>

<p>イテレータオブジェクト自体は以下の 2 のメソッドをサポートする必要があります。これらのメソッドは 2 つ合わせて <em class="dfn">イテレータプロトコル</em> を成します:</p>
<dl class="method">
<dt id="iterator.__iter__">
<code class="descclassname">iterator.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iterator.__iter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イテレータオブジェクト自体を返します。このメソッドはコンテナとイテ レータの両方を <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> および <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 文で使えるように するために必要です。このメソッドは Python/C API において Python オ ブジェクトを表す型構造体の <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a> スロットに対応します。</p>
</dd></dl>

<dl class="method">
<dt id="iterator.next">
<code class="descclassname">iterator.</code><code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iterator.next" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテナの次のアイテムを返します。もしそれ以上アイテム無ければ <a class="reference internal" href="exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 例外を送出します。 このメソッドは Python/C APIでのPythonオブジェクトの型構造体の <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal"><span class="pre">tp_iternext</span></code></a> スロットに対応します。</p>
</dd></dl>

<p>Python では、いくつかのイテレータオブジェクトを定義しています。これらは一般のおよび特殊なシーケンス型、辞書型、そして他のさらに特殊化された形式に渡る反復をサポートします。特殊型は、イテレータプロトコルの実装以外は重要ではありません。</p>
<p>このプロトコルでは、イテレータの <a class="reference internal" href="#iterator.next" title="iterator.next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a> メソッドが一旦 <a class="reference internal" href="exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> を送出したなら、以降の呼び出しでも例外を送出し続けることを期待します。この特性に従わない実装は壊れているとみなされます。(この制約は Python 2.3 で追加されました。Python 2.2 では色々なイテレータが、このルールによれば壊れています。)</p>
<div class="section" id="generator-types">
<span id="id3"></span><h3>5.5.1. ジェネレータ型<a class="headerlink" href="#generator-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python における <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> (ジェネレータ) は、イテレータプロトコルを実装する便利な方法を提供します。コンテナオブジェクトの <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> メソッドがジェネレータとして実装されていれば、そのメソッドは <a class="reference internal" href="#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> および <a class="reference internal" href="#iterator.next" title="iterator.next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a> メソッドを提供するイテレータオブジェクト (厳密にはジェネレータオブジェクト) を自動的に返します。ジェネレータに関する詳細な情報は、 <a class="reference internal" href="../reference/expressions.html#yieldexpr"><span class="std std-ref">yield 式のドキュメント</span></a> にあります。</p>
</div>
</div>
<div class="section" id="sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange">
<span id="typesseq"></span><h2>5.6. シーケンス型 — <a class="reference internal" href="functions.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="functions.html#unicode" title="unicode"><code class="xref py py-class docutils literal"><span class="pre">unicode</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">list</span></code>, <a class="reference internal" href="functions.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>, <a class="reference internal" href="functions.html#buffer" title="buffer"><code class="xref py py-class docutils literal"><span class="pre">buffer</span></code></a>, <a class="reference internal" href="functions.html#xrange" title="xrange"><code class="xref py py-class docutils literal"><span class="pre">xrange</span></code></a><a class="headerlink" href="#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>シーケンス型には 7 つあります: 文字列、Unicode 文字列、リスト、タプル、、バイト配列 (bytearray)、バッファ、そして xrange オブジェクトです。</p>
<p>他のコンテナ型については、組み込みクラスの <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> および <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> を参照下さい。</p>
<p id="index-21">文字列リテラルは <code class="docutils literal"><span class="pre">'xyzzy'</span></code> , <code class="docutils literal"><span class="pre">&quot;frobozz&quot;</span></code> といったように、単引用符または二重引用符の中に書かれます。文字列リテラルについての詳細は、 <a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">文字列リテラル</span></a> を参照下さい。 Unicode 文字列はほとんど文字列と同じですが、 <code class="docutils literal"><span class="pre">u'abc'</span></code> , <code class="docutils literal"><span class="pre">u&quot;def&quot;</span></code> といったように先頭に文字 <code class="docutils literal"><span class="pre">'u'</span></code> を付けて指定します。リストは <code class="docutils literal"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c]</span></code> のように要素をコンマで区切り角括弧で囲って生成します。タプルは <code class="docutils literal"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span></code> のようにコンマ演算子で区切って生成します (角括弧の中には入れません)。丸括弧で囲っても囲わなくてもかまいませんが、空のタプルは <code class="docutils literal"><span class="pre">()</span></code> のように丸括弧で囲わなければなりません。要素が一つのタプルでは、例えば <code class="docutils literal"><span class="pre">(d,)</span></code> のように、要素の後ろにコンマをつけなければなりません。</p>
<p>バイト配列は、組み込み関数 <a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal"><span class="pre">bytearray()</span></code></a> で構成されます。</p>
<p>バッファオブジェクトは Python の構文上では直接サポートされていませんが、組み込み関数 <a class="reference internal" href="functions.html#buffer" title="buffer"><code class="xref py py-func docutils literal"><span class="pre">buffer()</span></code></a> で生成することができます。バッファオブジェクトは結合や反復をサポートしていません。</p>
<p>xrange オブジェクトは、オブジェクトを生成するための特殊な構文がない点でバッファに似ていて、関数 <a class="reference internal" href="functions.html#xrange" title="xrange"><code class="xref py py-func docutils literal"><span class="pre">xrange()</span></code></a> で生成します。 xrange オブジェクトはスライス、結合、反復をサポートせず、 <code class="docutils literal"><span class="pre">in</span></code> , <code class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></code> , <a class="reference internal" href="functions.html#min" title="min"><code class="xref py py-func docutils literal"><span class="pre">min()</span></code></a> または <a class="reference internal" href="functions.html#max" title="max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a> は効率的ではありません。</p>
<p>ほとんどのシーケンス型は以下の演算操作をサポートします。 <code class="docutils literal"><span class="pre">in</span></code> および <code class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></code> は比較演算とおなじ優先度を持っています。 <code class="docutils literal"><span class="pre">+</span></code> および <code class="docutils literal"><span class="pre">*</span></code> は対応する数値演算とおなじ優先度です。 <a class="footnote-reference" href="#id14" id="id4">[3]</a> <a class="reference internal" href="#typesseq-mutable"><span class="std std-ref">ミュータブルなシーケンス型</span></a> で追加のメソッドが提供されています。</p>
<p>以下のテーブルはシーケンス型の演算を優先度の低いものから順に挙げたものです。テーブル内の <em>s</em> および <em>t</em> は同じ型のシーケンスです; <em>n</em> , <em>i</em> および <em>j</em> は整数です:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="53%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code></td>
<td><em>s</em> のある要素が <em>x</em> と等しければ <code class="docutils literal"><span class="pre">True</span></code> , そうでなければ <code class="docutils literal"><span class="pre">False</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code></td>
<td><em>s</em> のある要素が <em>x</em> と等しければ <code class="docutils literal"><span class="pre">False</span></code>, そうでなければ <code class="docutils literal"><span class="pre">True</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s</span> <span class="pre">+</span> <span class="pre">t</span></code></td>
<td><em>s</em> と <em>t</em> の結合</td>
<td>(6)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> または <code class="docutils literal"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">s</span></code></td>
<td><em>s</em> 自身を <em>n</em> 回足すのと同じ</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s[i]</span></code></td>
<td><em>s</em> の 0 から数えて <em>i</em> 番目の要素</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s[i:j]</span></code></td>
<td><em>s</em> の <em>i</em> から <em>j</em> までのスライス</td>
<td>(3)(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s[i:j:k]</span></code></td>
<td><em>s</em> の <em>i</em> から <em>j</em> まで、 <em>k</em> 毎のスライス</td>
<td>(3)(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">len(s)</span></code></td>
<td><em>s</em> の長さ</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">min(s)</span></code></td>
<td><em>s</em> の最小の要素</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">max(s)</span></code></td>
<td><em>s</em> の最大の要素</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.index(x)</span></code></td>
<td><em>s</em> 中で <em>x</em> が最初に出現するインデックス</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.count(x)</span></code></td>
<td><em>s</em> 中に <em>x</em> が出現する回数</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>シーケンス型は比較演算子もサポートします。特にタプルとリストは相当する要素による辞書編集方式的に比較されます。つまり、等しいということは、ふたつのシーケンスの長さ、型が同じであり、全ての要素が等しいということです (詳細は言語リファレンスの <a class="reference internal" href="../reference/expressions.html#comparisons"><span class="std std-ref">比較</span></a> を参照下さい) 。</p>
<p id="index-22">注釈:</p>
<ol class="arabic">
<li><p class="first"><em>s</em> が文字列または Unicode 文字列の場合、演算操作 <code class="docutils literal"><span class="pre">in</span></code> および <code class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></code> は部分文字列の一致テストと同じように動作します。バージョン 2.3 以前の Python では、 <em>x</em> は長さ 1 の文字列である必要がありました。 Python 2.3 以降では、 <em>x</em> はどんな長さでも構いません。</p>
</li>
<li><p class="first"><em>n</em> が <code class="docutils literal"><span class="pre">0</span></code> 以下の値の場合、 <code class="docutils literal"><span class="pre">0</span></code> として扱われます (これは <em>s</em> と同じ型の空のシーケンスを表します)。シーケンス <em>s</em> の要素はコピーされないので注意してください; コピーではなく要素に対する参照カウントが増えます。これは Python に慣れていないプログラマをよく悩ませます。例えば以下のコードを考えます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[], [], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [3], [3]]</span>
</pre></div>
</div>
<p>ここで、<code class="docutils literal"><span class="pre">[[]]</span></code> が空リストを含む 1 要素のリストなので、<code class="docutils literal"><span class="pre">[[]]</span> <span class="pre">*</span> <span class="pre">3</span></code> の 3 要素はこの一つの空リストへの参照です。<code class="docutils literal"><span class="pre">lists</span></code> のいずれかの要素を変更すると、その一つのリストが変更されます。別々のリストのリストを作るにはこうします:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [5], [7]]</span>
</pre></div>
</div>
<p>別の説明が FAQ エントリ <a class="reference internal" href="../faq/programming.html#faq-multidimensional-list"><span class="std std-ref">多次元のリストを作るにはどうしますか？</span></a> にあります。</p>
</li>
<li><p class="first"><em>i</em> または <em>j</em> が負の数の場合、インデクスはシーケンスの末端からの相対インデクスになります: <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">i</span></code> または <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">j</span></code> が代わりに使われます。ただし <code class="docutils literal"><span class="pre">-0</span></code> はやはり <code class="docutils literal"><span class="pre">0</span></code> であることに注意してください。</p>
</li>
<li><p class="first"><em>s</em> の <em>i</em> から <em>j</em> へのスライスは <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">j</span></code> となるようなインデクス <em>k</em> を持つ要素からなるシーケンスとして定義されます。 <em>i</em> または <em>j</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> よりも大きい場合、 <code class="docutils literal"><span class="pre">len(s)</span></code> を使います。 <em>i</em> が省略されるか <code class="docutils literal"><span class="pre">None</span></code> だった場合、 <code class="docutils literal"><span class="pre">0</span></code> を使います。 <em>j</em> が省略されるか <code class="docutils literal"><span class="pre">None</span></code> だった場合、 <code class="docutils literal"><span class="pre">len(s)</span></code> を使います。 <em>i</em> が <em>j</em> 以上の場合、スライスは空のシーケンスになります。</p>
</li>
<li><p class="first"><em>s</em> の「 <em>i</em> から <em>j</em> まででステップが <em>k</em> のスライス」は、インデックス <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code> （ただし n は <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">(j-i)/k</span></code> を満たす任意の整数）を持つ要素からなるシーケンスとして定義されます。言い換えるとインデックスは <code class="docutils literal"><span class="pre">i</span></code>, <code class="docutils literal"><span class="pre">i+k</span></code>, <code class="docutils literal"><span class="pre">i+2*k</span></code>, <code class="docutils literal"><span class="pre">i+3*k</span></code> と続き、 <em>j</em> に達したところでストップします (ただし <em>j</em> は含みません)。 <em>k</em> が正の数である場合、 <em>i</em> または <em>j</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> より大きければ <code class="docutils literal"><span class="pre">len(s)</span></code> を代わりに使用します。 <em>k</em> が負の数である場合、 <em>i</em> または <em>j</em> が <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">-</span> <span class="pre">1</span></code> より大きければ <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">-</span> <span class="pre">1</span></code> を代わりに使用します。 <em>i</em> または <em>j</em> を省略または <code class="docutils literal"><span class="pre">None</span></code> を指定すると、 &quot;端&quot; (どちらの端かは <em>k</em> の符号に依存) の値を代わりに使用します。なお <em>k</em> はゼロにできないので注意してください。また <em>k</em> に <code class="docutils literal"><span class="pre">None</span></code> を指定すると、 <code class="docutils literal"><span class="pre">1</span></code> が指定されたものとして扱われます。</p>
</li>
<li><div class="impl-detail first compound">
<p><strong>CPython 実装の詳細:</strong> <em>s</em> と <em>t</em> の両者が文字列であるとき、 CPython のようないくつかの Python 実装では、 <code class="docutils literal"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">s</span> <span class="pre">+</span> <span class="pre">t</span></code> や <code class="docutils literal"><span class="pre">s</span> <span class="pre">+=</span> <span class="pre">t</span></code> という書式で代入をするのに in-place optimization が働きます。このような時、最適化は二乗の実行時間の低減をもたらします。この最適化はバージョンや実装に依存します。実行効率が必要なコードでは、バージョンと実装が変わっても、連結の線形的実行効率を保証する <a class="reference internal" href="#str.join" title="str.join"><code class="xref py py-meth docutils literal"><span class="pre">str.join()</span></code></a> を使うのがより望ましいでしょう。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.4 で変更: </span>以前、文字列の連結はin-placeで再帰されませんでした.</p>
</div>
</li>
</ol>
<div class="section" id="string-methods">
<span id="id5"></span><h3>5.6.1. 文字列メソッド<a class="headerlink" href="#string-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-23">8-bit 文字列と Unicode オブジェクトは、どちらも以下に挙げるメソッドに対応しています。この中には、 <a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> オブジェクトで使えるものもあります。</p>
<p>さらに、 Python の文字列は <a class="reference internal" href="#typesseq"><span class="std std-ref">シーケンス型 — str, unicode, list, tuple, bytearray, buffer, xrange</span></a> に記載されるシーケンス型のメソッドもサポートします。書式指定して文字列を出力するためには、テンプレート文字列を使うか、 <a class="reference internal" href="#string-formatting"><span class="std std-ref">文字列フォーマット操作</span></a> に記載される <code class="docutils literal"><span class="pre">%</span></code> 演算子を使います。正規表現に基づく文字列操作関数については、 <a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> モジュールを参照下さい。</p>
<dl class="method">
<dt id="str.capitalize">
<code class="descclassname">str.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.capitalize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最初の文字を大文字にし、残りを小文字にした文字列のコピーを返します。</p>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.center">
<code class="descclassname">str.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.center" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>width</em> の長さをもつ中央寄せされた文字列を返します。パディングには <em>fillchar</em> で指定された値 (デフォルトではスペース) が使われます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.4 で変更: </span>引数 <em>fillchar</em> に対応.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.count">
<code class="descclassname">str.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.count" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>[<em>start</em>, <em>end</em>] の範囲に、部分文字列 <em>sub</em> が重複せず出現する回数を返します。オプション引数 <em>start</em> および <em>end</em> はスライス表記と同じように解釈されます。</p>
</dd></dl>

<dl class="method">
<dt id="str.decode">
<code class="descclassname">str.</code><code class="descname">decode</code><span class="sig-paren">(</span><span class="optional">[</span><em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.decode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>codec に登録された文字コード系 <em>encoding</em> を使って文字列をデコードします。 <em>encoding</em> は標準でデフォルトの文字列エンコーディングになります。標準とは異なるエラー処理を行うために <em>errors</em> を与えることができます。標準のエラー処理は <code class="docutils literal"><span class="pre">'strict'</span></code> で、エンコードに関するエラーは <a class="reference internal" href="exceptions.html#exceptions.UnicodeError" title="exceptions.UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> を送出します。他に利用できる値は <code class="docutils literal"><span class="pre">'ignore'</span></code>, <code class="docutils literal"><span class="pre">'replace'</span></code> および関数 <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></code></a> によって登録された名前です。これについてはセクション <a class="reference internal" href="codecs.html#codec-base-classes"><span class="std std-ref">Codec 基底クラス</span></a> 節を参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.2 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.3 で変更: </span>その他のエラーハンドリングスキーマがサポートされました.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span>キーワード引数のサポートが追加されました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.encode">
<code class="descclassname">str.</code><code class="descname">encode</code><span class="sig-paren">(</span><span class="optional">[</span><em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.encode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列のエンコードされたバージョンを返します。デフォルトのエンコーディングは現在の文字列エンコーディングのデフォルトです。標準とは異なるエラー処理を行うために <em>errors</em> を与えることができます。標準のエラー処理は <code class="docutils literal"><span class="pre">'strict'</span></code> で、エンコードに関するエラーは <a class="reference internal" href="exceptions.html#exceptions.UnicodeError" title="exceptions.UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> を送出します。他に利用できる値は <code class="docutils literal"><span class="pre">'ignore'</span></code>, <code class="docutils literal"><span class="pre">'replace'</span></code>, <code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code>, <code class="docutils literal"><span class="pre">'backslashreplace'</span></code> および関数 <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></code></a> によって登録された名前です。これについてはセクション <a class="reference internal" href="codecs.html#codec-base-classes"><span class="std std-ref">Codec 基底クラス</span></a> を参照してください。利用可能なエンコーディングの一覧は、セクション <a class="reference internal" href="codecs.html#standard-encodings"><span class="std std-ref">標準エンコーディング</span></a> を参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.0 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.3 で変更: </span><code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code>, <code class="docutils literal"><span class="pre">'backslashreplace'</span></code> およびその他のエラーハンドリングスキーマがサポートされました.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span>キーワード引数のサポートが追加されました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.endswith">
<code class="descclassname">str.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.endswith" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列が指定された <em>suffix</em> で終わるなら <code class="docutils literal"><span class="pre">True</span></code> を、そうでなければ <code class="docutils literal"><span class="pre">False</span></code> を返します。 <em>suffix</em> は見つけたい複数の接尾語のタプルでも構いません。オプションの <em>start</em> があれば、その位置から判定を始めます。オプションの <em>end</em> があれば、その位置で比較を止めます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.5 で変更: </span><em>suffix</em> でタプルを受け付けるようになりました.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.expandtabs">
<code class="descclassname">str.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><span class="optional">[</span><em>tabsize</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.expandtabs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列内の全てのタブ文字が 1 つ以上のスペースで置換された、文字列のコピーを返します。スペースの数は現在の桁 (column) 位置と <em>tabsize</em> に依存します。タブ位置は <em>tabsize</em> 文字毎に存在します (デフォルト値である 8 の場合、タブ位置は 0, 8, 16 などになります)。文字列を展開するため、まず現桁位置がゼロにセットされ、文字列が 1 文字ずつ調べられます。文字がタブ文字 (<code class="docutils literal"><span class="pre">\t</span></code>) であれば、現桁位置が次のタブ位置と一致するまで、1 つ以上のスペースが結果の文字列に挿入されます。(タブ文字自体はコピーされません。) 文字が改行文字 (<code class="docutils literal"><span class="pre">\n</span></code> もしくは <code class="docutils literal"><span class="pre">\r</span></code>) の場合、文字がコピーされ、現桁位置は 0 にリセットされます。その他の文字は変更されずにコピーされ、現桁位置は、その文字の表示のされ方 (訳注: 全角、半角など) に関係なく、1 ずつ増加します。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
<span class="go">&#39;01      012     0123    01234&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;01  012 0123    01234&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.find">
<code class="descclassname">str.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.find" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列のスライス <code class="docutils literal"><span class="pre">s[start:end]</span></code> に部分文字列 <em>sub</em> が含まれる場合、その最小のインデックスを返します。オプション引数 <em>start</em> および <em>end</em> はスライス表記と同様に解釈されます。 <em>sub</em> が見つからなかった場合 <code class="docutils literal"><span class="pre">-1</span></code> を返します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p><a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> メソッドは、 <em>sub</em> の位置を知りたいときにのみ使うべきです。 <em>sub</em> が部分文字列であるかどうかのみを調べるには、 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 演算子を使ってください:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Py&#39;</span> <span class="ow">in</span> <span class="s1">&#39;Python&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.format">
<code class="descclassname">str.</code><code class="descname">format</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#str.format" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の書式化操作を行います。このメソッドを呼び出す文字列は通常の文字、または、 <code class="docutils literal"><span class="pre">{}</span></code> で区切られた置換フィールドを含みます。それぞれの置換フィールドは位置引数のインデックスナンバー、または、キーワード引数の名前を含みます。返り値は、それぞれの置換フィールドが対応する引数の文字列値で置換された文字列のコピーです。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;The sum of 1 + 2 is </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;The sum of 1 + 2 is 3&#39;</span>
</pre></div>
</div>
<p>書式指定のオプションについては、書式指定文字列を規定する <a class="reference internal" href="string.html#formatstrings"><span class="std std-ref">書式指定文字列の文法</span></a> を参照下さい。</p>
<p>この文字列書式指定のメソッドは Python 3 での新しい標準であり、新しいコードでは、 <a class="reference internal" href="#string-formatting"><span class="std std-ref">文字列フォーマット操作</span></a> で規定される <code class="docutils literal"><span class="pre">%</span></code> を使った書式指定より好ましい書き方です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.index">
<code class="descclassname">str.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.index" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> と同様ですが、 <em>sub</em> が見つからなかった場合 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="str.isalnum">
<code class="descclassname">str.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isalnum" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の全ての文字が英数文字で、かつ 1 文字以上ある場合には真を返し、そうでない場合は偽を返します。</p>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.isalpha">
<code class="descclassname">str.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isalpha" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の全ての文字が英文字で、かつ 1 文字以上ある場合には真を返し、そうでない場合は偽を返します。</p>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.isdigit">
<code class="descclassname">str.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isdigit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中に数字しかない場合には真を返し、その他の場合は偽を返します。</p>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.islower">
<code class="descclassname">str.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.islower" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の大小文字の区別のある文字 <a class="footnote-reference" href="#id15" id="id6">[4]</a> 全てが小文字で、かつ大小文字の区別のある文字が 1 文字以上あるなら真を、そうでなければ偽を返します。</p>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.isspace">
<code class="descclassname">str.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isspace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列が空白文字だけからなり、かつ 1 文字以上ある場合には真を返し、そうでない場合は偽を返します。</p>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.istitle">
<code class="descclassname">str.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.istitle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列がタイトルケース文字列であり、かつ 1 文字以上ある場合、例えば大文字は大小文字の区別のない文字の後にのみ続き、小文字は大小文字の区別のある文字の後ろにのみ続く場合には真を返します。そうでない場合は偽を返します。</p>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.isupper">
<code class="descclassname">str.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isupper" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の大小文字の区別のある文字 <a class="footnote-reference" href="#id15" id="id7">[4]</a> 全てが大文字で、かつ大小文字の区別のある文字が 1 文字以上あるなら真を、そうでなければ偽を返します。</p>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.join">
<code class="descclassname">str.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#str.join" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>イテラブル</em> 中の文字列を結合した文字列オブジェクトを返します。
<em>iterable</em> に Unicode オブジェクトがある場合は、代わりに Unicode を返します。文字列でないあるいは Unicode オブジェクトでない値が存在する場合は、 <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出されます。要素間の区切り文字列は、このメソッドを提供する文字列です。</p>
</dd></dl>

<dl class="method">
<dt id="str.ljust">
<code class="descclassname">str.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.ljust" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>長さ <em>width</em> の左揃えした文字列を返します。パディングは指定された <em>fillchar</em> (デフォルトではスペース) を使って行われます。 <em>width</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> 以下ならば、元の文字列が返されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.4 で変更: </span>引数 <em>fillchar</em> に対応.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.lower">
<code class="descclassname">str.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.lower" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>全ての大小文字の区別のある文字 <a class="footnote-reference" href="#id15" id="id8">[4]</a> が小文字に変換された、文字列のコピーを返します。</p>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.lstrip">
<code class="descclassname">str.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.lstrip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の先頭の文字を除去したコピーを返します。引数 <em>chars</em> は除去される文字の集合を指定する文字列です。 <em>chars</em> が省略されるか <code class="docutils literal"><span class="pre">None</span></code> の場合、空白文字が除去されます。 <em>chars</em> 文字列は接頭辞ではなく、その値に含まれる文字の組み合わせ全てがはぎ取られます。 :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">&#39;spacious   &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example.com&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.2.2 で変更: </span>引数 <em>chars</em> をサポートしました.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.partition">
<code class="descclassname">str.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#str.partition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を <em>sep</em> の最初の出現位置で区切り、 3 要素のタプルを返します。タプルの内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分です。もし区切れなければ、タプルには元の文字列そのものとその後ろに二つの空文字列が入ります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.replace">
<code class="descclassname">str.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.replace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列をコピーし、現れる部分文字列 <em>old</em> 全てを <em>new</em> に置換して返します。オプション引数 <em>count</em> が与えられている場合、先頭から <em>count</em> 個の <em>old</em> だけを置換します。</p>
</dd></dl>

<dl class="method">
<dt id="str.rfind">
<code class="descclassname">str.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rfind" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の領域 <code class="docutils literal"><span class="pre">s[start:end]</span></code> に <em>sub</em> が含まれる場合、その最大のインデクスを返します。オプション引数 <em>start</em> および <em>end</em> はスライス表記と同様に解釈されます。 <em>sub</em> が見つからなかった場合 <code class="docutils literal"><span class="pre">-1</span></code>  を返します。</p>
</dd></dl>

<dl class="method">
<dt id="str.rindex">
<code class="descclassname">str.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rindex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#str.rfind" title="str.rfind"><code class="xref py py-meth docutils literal"><span class="pre">rfind()</span></code></a> と同様ですが、 <em>sub</em> が見つからなかった場合 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="str.rjust">
<code class="descclassname">str.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rjust" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>width</em> の長さをもつ右寄せした文字列を返します。パディングには <em>fillchar</em> で指定された文字(デフォルトではスペース)が使われます。 <em>width</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> 以下の場合、元の文字列が返されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.4 で変更: </span>引数 <em>fillchar</em> に対応.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.rpartition">
<code class="descclassname">str.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#str.rpartition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を <em>sep</em> の最後の出現位置で区切り、 3 要素のタプルを返します。タプルの内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分です。もし区切れなければ、タプルには二つの空文字列とその後ろに元の文字列そのものが入ります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.rsplit">
<code class="descclassname">str.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><span class="optional">[</span><em>sep</em><span class="optional">[</span>, <em>maxsplit</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rsplit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>sep</em> を区切り文字とした、文字列中の単語のリストを返します。 <em>maxsplit</em> が与えられた場合、文字列の <em>右端</em> から最大 <em>maxsplit</em> 回分割を行います。<em>sep</em> が指定されていない、あるいは <code class="docutils literal"><span class="pre">None</span></code> のとき、全ての空白文字が区切り文字となります。右から分割していくことを除けば、 <a class="reference internal" href="#str.rsplit" title="str.rsplit"><code class="xref py py-meth docutils literal"><span class="pre">rsplit()</span></code></a> は後ほど詳しく述べる <a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> と同様に振る舞います。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.rstrip">
<code class="descclassname">str.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rstrip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の末尾部分を除去したコピーを返します。引数 <em>chars</em> は除去される文字集合を指定する文字列です。 <em>chars</em> が省略されるか <code class="docutils literal"><span class="pre">None</span></code> の場合、空白文字が除去されます。 <em>chars</em> 文字列は接尾語ではなく、そこに含まれる文字の組み合わせ全てがはぎ取られます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">&#39;   spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;mississippi&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;ipz&#39;</span><span class="p">)</span>
<span class="go">&#39;mississ&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.2.2 で変更: </span>引数 <em>chars</em> をサポートしました.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.split">
<code class="descclassname">str.</code><code class="descname">split</code><span class="sig-paren">(</span><span class="optional">[</span><em>sep</em><span class="optional">[</span>, <em>maxsplit</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.split" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を <em>sep</em> をデリミタ文字列として区切った単語のリストを返します。<em>maxsplit</em> が与えられていれば、最大で <em>maxsplit</em> 回分割されます (つまり、リストは最大 <code class="docutils literal"><span class="pre">maxsplit+1</span></code> 要素になります)。 <em>maxsplit</em> が与えられないか <code class="docutils literal"><span class="pre">-1</span></code> なら、分割の回数に制限はありません (可能なだけ分割されます)。</p>
<p><em>sep</em> が与えられた場合、連続した区切り文字はまとめられず、空の文字列を区切っていると判断されます(例えば <code class="docutils literal"><span class="pre">'1,,2'.split(',')</span></code> は <code class="docutils literal"><span class="pre">['1',</span> <span class="pre">'',</span> <span class="pre">'2']</span></code> を返します)。引数 <em>sep</em> は複数の文字にもできます (例えば <code class="docutils literal"><span class="pre">'1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;')</span></code> は <code class="docutils literal"><span class="pre">['1',</span> <span class="pre">'2',</span> <span class="pre">'3']</span></code> を返します)。区切り文字を指定して空の文字列を分割すると、 <code class="docutils literal"><span class="pre">['']</span></code> を返します。</p>
<p><em>sep</em> が指定されていないか <code class="docutils literal"><span class="pre">None</span></code> であれば、異なる分割アルゴリズムが適用されます。 : 連続する空白文字はひとつのデリミタとみなされます。また、文字列の先頭や末尾に空白があっても、結果の最初や最後に空文字列は含まれません。よって、空文字列や空白だけの文字列を <code class="docutils literal"><span class="pre">None</span></code> デリミタで分割すると <code class="docutils literal"><span class="pre">[]</span></code> が返されます。</p>
<p>例えば、 <code class="docutils literal"><span class="pre">'</span> <span class="pre">1</span>&#160; <span class="pre">2</span>&#160;&#160; <span class="pre">3</span>&#160; <span class="pre">'.split()</span></code> は <code class="docutils literal"><span class="pre">['1',</span> <span class="pre">'2',</span> <span class="pre">'3']</span></code> を返し、 <code class="docutils literal"><span class="pre">'</span>&#160; <span class="pre">1</span>&#160; <span class="pre">2</span>&#160;&#160; <span class="pre">3</span>&#160; <span class="pre">'.split(None,</span> <span class="pre">1)</span></code> は <code class="docutils literal"><span class="pre">['1',</span> <span class="pre">'2</span>&#160;&#160; <span class="pre">3</span>&#160; <span class="pre">']</span></code> を返します。</p>
</dd></dl>

<span class="target" id="index-24"></span><dl class="method">
<dt id="str.splitlines">
<code class="descclassname">str.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><span class="optional">[</span><em>keepends</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.splitlines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を改行部分で分解し、各行からなるリストを返します。 このメソッドは、行の分割に <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> アプローチを使います。<em>keepends</em> に真が与えらない限り、返されるリストに改行は含まれません。</p>
<p>Python は <code class="docutils literal"><span class="pre">&quot;\r&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;\n&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;\r\n&quot;</span></code> を 8-bit 文字列の行の境界として認識します。</p>
<p>例えば:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[&#39;ab c&#39;, &#39;&#39;, &#39;de fg&#39;, &#39;kl&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[&#39;ab c\n&#39;, &#39;\n&#39;, &#39;de fg\r&#39;, &#39;kl\r\n&#39;]</span>
</pre></div>
</div>
<p><a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> とは違って、デリミタ文字列 <em>sep</em> が与えられたとき、このメソッドは空文字列に空リストを返し、終末の改行は結果に行を追加しません:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;One line</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[&#39;One line&#39;]</span>
</pre></div>
</div>
<p>比較のために <code class="docutils literal"><span class="pre">split('\n')</span></code> は以下のようになります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Two lines</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;Two lines&#39;, &#39;&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="unicode.splitlines">
<code class="descclassname">unicode.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><span class="optional">[</span><em>keepends</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#unicode.splitlines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#str.splitlines" title="str.splitlines"><code class="xref py py-meth docutils literal"><span class="pre">str.splitlines()</span></code></a> のように、文字列を行のリストにして返します。ただし Unicode のメソッドでは、8-bit 文字列の行の境界として認識される <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> よりも多くの次に挙げる行の境界で分割します。</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">表現</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\n</span></code></td>
<td>改行</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\r</span></code></td>
<td>復帰</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\r\n</span></code></td>
<td>改行 + 復帰</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\v</span></code> or <code class="docutils literal"><span class="pre">\x0b</span></code></td>
<td>垂直タブ</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\f</span></code> or <code class="docutils literal"><span class="pre">\x0c</span></code></td>
<td>改ページ</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\x1c</span></code></td>
<td>ファイル区切り</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\x1d</span></code></td>
<td>グループ区切り</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\x1e</span></code></td>
<td>レコード区切り</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\x85</span></code></td>
<td>改行 (C1 制御コード)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\u2028</span></code></td>
<td>行区切り</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\u2029</span></code></td>
<td>段落区切り</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span><code class="docutils literal"><span class="pre">\v</span></code> と <code class="docutils literal"><span class="pre">\f</span></code> が行境界のリストに追加されました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.startswith">
<code class="descclassname">str.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.startswith" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列が指定された <em>prefix</em> で始まるなら <code class="docutils literal"><span class="pre">True</span></code> を、そうでなければ <code class="docutils literal"><span class="pre">False</span></code> を返します。 <em>prefix</em> は見つけたい複数の接頭語のタプルでも構いません。オプションの <em>start</em> があれば、その位置から判定を始めます。オプションの <em>end</em> があれば、その位置で比較を止めます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.5 で変更: </span><em>prefix</em> でタプルを受け付けるようになりました.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.strip">
<code class="descclassname">str.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.strip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の先頭および末尾部分を除去したコピーを返します。引数 <em>chars</em> は除去される文字集合を指定する文字列です。 <em>chars</em> が省略されるか <code class="docutils literal"><span class="pre">None</span></code> の場合、空白文字が除去されます。 <em>chars</em> 文字列は接頭語でも接尾語でもなく、そこに含まれる文字の組み合わせ全てがはぎ取られます。 :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">&#39;spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.2.2 で変更: </span>引数 <em>chars</em> をサポートしました.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.swapcase">
<code class="descclassname">str.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.swapcase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列をコピーし、大文字は小文字に、小文字は大文字に変換して返します。</p>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.title">
<code class="descclassname">str.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.title" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を、単語ごとに大文字から始まり、残りの文字のうち大小文字の区別があるものは全て小文字にする、タイトルケースにして返します。</p>
<p>このアルゴリズムは、連続した文字の集まりという、言語から独立した単純な単語の定義を使います。この定義は多くの状況ではうまく機能しますが、短縮形や所有格のアポストロフィが単語の境界になってしまい、望みの結果を得られない場合があります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;they&#39;re bill&#39;s friends from the UK&quot;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">&quot;They&#39;Re Bill&#39;S Friends From The Uk&quot;</span>
</pre></div>
</div>
<p>正規表現を使うことでアポストロフィに対応できます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[A-Za-z]+(&#39;[A-Za-z]+)?&quot;</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="k">lambda</span> <span class="n">mo</span><span class="p">:</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span>
<span class="gp">... </span>                             <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
<span class="gp">... </span>                  <span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="s2">&quot;they&#39;re bill&#39;s friends.&quot;</span><span class="p">)</span>
<span class="go">&quot;They&#39;re Bill&#39;s Friends.&quot;</span>
</pre></div>
</div>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.translate">
<code class="descclassname">str.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em><span class="optional">[</span>, <em>deletechars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.translate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列をコピーし、オプション引数の文字列 <em>deletechars</em> の中に含まれる文字を全て除去します。その後、残った文字を変換テーブル <em>table</em> に従ってマップして返します。変換テーブルは長さ 256 の文字列でなければなりません。</p>
<p>トランスレーションテーブル作成のために、 <a class="reference internal" href="string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal"><span class="pre">string</span></code></a> モジュールの <a class="reference internal" href="string.html#string.maketrans" title="string.maketrans"><code class="xref py py-func docutils literal"><span class="pre">maketrans()</span></code></a> 補助関数を使うこともできます。文字列型オブジェクトに対しては、 <em>table</em> 引数に <code class="docutils literal"><span class="pre">None</span></code> を与えることで、文字の削除だけを実施します。:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;read this short text&#39;</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;aeiou&#39;</span><span class="p">)</span>
<span class="go">&#39;rd ths shrt txt&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加: </span><code class="docutils literal"><span class="pre">None</span></code> の <em>table</em> 引数をサポートしました。</p>
</div>
<p>Unicode オブジェクトの場合、 <a class="reference internal" href="#str.translate" title="str.translate"><code class="xref py py-meth docutils literal"><span class="pre">translate()</span></code></a> メソッドはオプションの <em>deletechars</em> 引数を受理しません。その代わり、メソッドはすべての文字が与えられた変換テーブルで対応付けされている <em>s</em> のコピーを返します。この変換テーブルは Unicode 順 (ordinal) から Unicode 順、 Unicode 文字列、または <code class="docutils literal"><span class="pre">None</span></code> への対応付けでなくてはなりません。対応付けされていない文字は何もせず放置されます。 <code class="docutils literal"><span class="pre">None</span></code> に対応付けられた文字は削除されます。ちなみに、より柔軟性のあるアプローチは、自作の文字対応付けを行う codec を <a class="reference internal" href="codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a> モジュールを使って作成することです (例えば <code class="xref py py-mod docutils literal"><span class="pre">encodings.cp1251</span></code> を参照してください。)</p>
</dd></dl>

<dl class="method">
<dt id="str.upper">
<code class="descclassname">str.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.upper" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>全ての大小文字の区別のある文字 <a class="footnote-reference" href="#id15" id="id9">[4]</a> が大文字に変換された、文字列のコピーを返します。なお <code class="docutils literal"><span class="pre">str.upper().isupper()</span></code> は、 <code class="docutils literal"><span class="pre">s</span></code> が大小文字の区別のある文字を含まなかったり、結果の文字の Unicode カテゴリが &quot;Lu&quot; ではなく例えば &quot;Lt&quot; (Letter, titlecase) などであったら、 <code class="docutils literal"><span class="pre">False</span></code> になりえます。</p>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.zfill">
<code class="descclassname">str.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#str.zfill" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>数値文字列の左側をゼロ詰めし、幅 <em>width</em> の文字列で返します。符号接頭辞も正しく扱われます。 <em>width</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> 以下の場合もとの文字列自体が返されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</div>
</dd></dl>

<p>以下のメソッドは、 Unicode オブジェクトにのみ実装されます:</p>
<dl class="method">
<dt id="unicode.isnumeric">
<code class="descclassname">unicode.</code><code class="descname">isnumeric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unicode.isnumeric" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>数字を表す文字のみで構成される場合、 <code class="docutils literal"><span class="pre">True</span></code> を返します。それ以外の場合は <code class="docutils literal"><span class="pre">False</span></code> を返します。数字を表す文字には、 0 から 9 までの数字と、 Unicode の数字プロパティを持つ全ての文字が含まれます。 (e.g. U+2155, VULGAR FRACTION ONE FIFTH)</p>
</dd></dl>

<dl class="method">
<dt id="unicode.isdecimal">
<code class="descclassname">unicode.</code><code class="descname">isdecimal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unicode.isdecimal" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>10 進数文字のみで構成される場合、 <code class="docutils literal"><span class="pre">True</span></code> を返します。それ以外の場合は、 <code class="docutils literal"><span class="pre">False</span></code> を返します。 10 進数文字には 0 から 9 までの数字と、 10 進基数表記に使われる全ての文字が含まれます。 (e.g. U+0660, ARABIC-INDIC DIGIT ZERO)</p>
</dd></dl>

</div>
<div class="section" id="string-formatting-operations">
<span id="string-formatting"></span><h3>5.6.2. 文字列フォーマット操作<a class="headerlink" href="#string-formatting-operations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-25">文字列および Unicode オブジェクトには固有の操作: <code class="docutils literal"><span class="pre">%</span></code> 演算子 (モジュロ) があります。この演算子は文字列 <em>フォーマット化</em> または <em>補間</em> 演算としても知られています。 <code class="docutils literal"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">values</span></code> (<em>format</em> は文字列または Unicode オブジェクト) とすると、 <em>format</em> 中の <code class="docutils literal"><span class="pre">%</span></code> 変換指定は <em>values</em> 中のゼロ個またはそれ以上の要素で置換されます。この動作は C 言語における <code class="xref c c-func docutils literal"><span class="pre">sprintf()</span></code> に似ています。 <em>format</em> が Unicode オブジェクトであるか、または <code class="docutils literal"><span class="pre">%s</span></code> 変換を使って Unicode オブジェクトが変換される場合、その結果も Unicode オブジェクトになります。</p>
<p><em>format</em> が単一の引数しか要求しない場合、 <em>values</em> はタプルでない単一のオブジェクトでもかまいません。 <a class="footnote-reference" href="#id16" id="id10">[5]</a> それ以外の場合、 <em>values</em> はフォーマット文字列中で指定された項目と正確に同じ数の要素からなるタプルか、単一のマップオブジェクトでなければなりません。</p>
<p>一つの変換指定子は 2 またはそれ以上の文字を含み、その構成要素は以下からなりますが、示した順に出現しなければなりません:</p>
<ol class="arabic simple">
<li>指定子の開始を示す文字 <code class="docutils literal"><span class="pre">'%'</span></code> 。</li>
<li>マップキー (オプション)。丸括弧で囲った文字列からなります (例えば <code class="docutils literal"><span class="pre">(somename)</span></code>) 。</li>
<li>変換フラグ (オプション)。一部の変換型の結果に影響します。</li>
<li>最小のフィールド幅 (オプション)。 <code class="docutils literal"><span class="pre">'*'</span></code> (アスタリスク) を指定した場合、実際の文字列幅が <em>values</em> タプルの次の要素から読み出されます。タプルには最小フィールド幅やオプションの精度指定の後に変換したいオブジェクトがくるようにします。</li>
<li>精度 (オプション)。 <code class="docutils literal"><span class="pre">'.'</span></code> (ドット) とその後に続く精度で与えられます。 <code class="docutils literal"><span class="pre">'*'</span></code> (アスタリスク) を指定した場合、精度の桁数は <em>values</em> タプルの次の要素から読み出されます。タプルには精度指定の後に変換したい値がくるようにします。</li>
<li>精度長変換子 (オプション)。</li>
<li>変換型。</li>
</ol>
<p><code class="docutils literal"><span class="pre">%</span></code> 演算子の右側の引数が辞書の場合 (またはその他のマップ型の場合), 文字列中のフォーマットには、辞書に挿入されているキーを丸括弧で囲い、文字 <code class="docutils literal"><span class="pre">'%'</span></code> の直後にくるようにしたものが含まれていなければ <em>なりません</em> 。マップキーはフォーマット化したい値をマップから選び出します。例えば:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s1">&#39;</span><span class="si">%(language)s</span><span class="s1"> has </span><span class="si">%(number)03d</span><span class="s1"> quote types.&#39;</span> <span class="o">%</span> \
<span class="gp">... </span>      <span class="p">{</span><span class="s2">&quot;language&quot;</span><span class="p">:</span> <span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="go">Python has 002 quote types.</span>
</pre></div>
</div>
<p>この場合、 <code class="docutils literal"><span class="pre">*</span></code> 指定子をフォーマットに含めてはいけません (<code class="docutils literal"><span class="pre">*</span></code> 指定子は順番付けされたパラメタのリストが必要だからです)。</p>
<p>変換フラグ文字を以下に示します:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">フラグ</th>
<th class="head">意味</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'#'</span></code></td>
<td>値の変換に (下で定義されている) &quot;別の形式&quot; を使います。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'0'</span></code></td>
<td>数値型に対してゼロによるパディングを行います。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'-'</span></code></td>
<td>変換された値を左寄せにします (<code class="docutils literal"><span class="pre">'0'</span></code> と同時に与えた場合、 <code class="docutils literal"><span class="pre">'0'</span></code> を上書きします) 。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code></td>
<td>(スペース) 符号付きの変換で正の数の場合、前に一つスペースを空けます (そうでない場合は空文字になります) 。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'+'</span></code></td>
<td>変換の先頭に符号文字 (<code class="docutils literal"><span class="pre">'+'</span></code> または <code class="docutils literal"><span class="pre">'-'</span></code>) を付けます(&quot;スペース&quot; フラグを上書きします) 。</td>
</tr>
</tbody>
</table>
<p>精度長変換子(<code class="docutils literal"><span class="pre">h</span></code>, <code class="docutils literal"><span class="pre">l</span></code>,または <code class="docutils literal"><span class="pre">L</span></code>) を使うことができますが、 Python では必要ないため無視されます。 – つまり、例えば <code class="docutils literal"><span class="pre">%ld</span></code> は <code class="docutils literal"><span class="pre">%d</span></code> と等価です。</p>
<p>変換型を以下に示します:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="74%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">変換</th>
<th class="head">意味</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'d'</span></code></td>
<td>符号付き 10 進整数。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'i'</span></code></td>
<td>符号付き 10 進整数。</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'o'</span></code></td>
<td>符号付き 8 進数。</td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'u'</span></code></td>
<td>旧式の型 – <code class="docutils literal"><span class="pre">'d'</span></code> と同じです。</td>
<td>(7)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'x'</span></code></td>
<td>符号付き 16 進数 (小文字)。</td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'X'</span></code></td>
<td>符号付き 16 進数 (大文字)。</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'e'</span></code></td>
<td>指数表記の浮動小数点数 (小文字)。</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'E'</span></code></td>
<td>指数表記の浮動小数点数 (大文字)。</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'f'</span></code></td>
<td>10 進浮動小数点数。</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'F'</span></code></td>
<td>10 進浮動小数点数。</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'g'</span></code></td>
<td>浮動小数点数。指数部が -4 以上または精度以下の場合には小文字指数表記、それ以外の場合には10進表記。</td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'G'</span></code></td>
<td>浮動小数点数。指数部が -4 以上または精度以下の場合には大文字指数表記、それ以外の場合には10進表記。</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'c'</span></code></td>
<td>文字一文字 (整数または一文字からなる文字列を受理します)。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'r'</span></code></td>
<td>文字列 (Python オブジェクトを <a class="reference internal" href="functions.html#func-repr"><span class="std std-ref">repr()</span></a> で変換します)。</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'s'</span></code></td>
<td>文字列 (Python オブジェクトを <a class="reference internal" href="functions.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> で変換します)。</td>
<td>(6)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'%'</span></code></td>
<td>引数を変換せず、返される文字列中では文字 <code class="docutils literal"><span class="pre">'%'</span></code> になります。</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>注釈:</p>
<ol class="arabic">
<li><p class="first">この形式の出力にした場合、変換結果の先頭の数字がゼロ (<code class="docutils literal"><span class="pre">'0'</span></code>) でないときには、数字の先頭と左側のパディングとの間にゼロを挿入します。</p>
</li>
<li><p class="first">別の形式を指定（訳注: 変換フラグ <code class="docutils literal"><span class="pre">#</span></code> を使用）すると 16 進数を表す接頭辞 <code class="docutils literal"><span class="pre">'0x'</span></code> または <code class="docutils literal"><span class="pre">'0X'</span></code> (使用するフォーマット文字が <code class="docutils literal"><span class="pre">'x'</span></code> か <code class="docutils literal"><span class="pre">'X'</span></code> に依存します) が最初の数字の前に挿入されます。</p>
</li>
<li><p class="first">この形式にした場合、変換結果には常に小数点が含まれ、それはその後ろに数字が続かない場合にも適用されます。</p>
<p>指定精度は小数点の後の桁数を決定し、そのデフォルトは 6 です。</p>
</li>
<li><p class="first">この形式にした場合、変換結果には常に小数点が含まれ他の形式とは違って末尾の 0 は取り除かれません。</p>
<p>指定精度は小数点の前後の有効桁数を決定し、そのデフォルトは 6 です。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">%r</span></code> 変換は Python 2.0 で追加されました。</p>
<p>指定精度は最大文字数を決定します。</p>
</li>
<li><p class="first">オブジェクトや与えられた書式が <a class="reference internal" href="functions.html#unicode" title="unicode"><code class="xref py py-class docutils literal"><span class="pre">unicode</span></code></a> 文字列の場合、変換後の文字列も <a class="reference internal" href="functions.html#unicode" title="unicode"><code class="xref py py-class docutils literal"><span class="pre">unicode</span></code></a> になります。</p>
<p>指定精度は最大文字数を決定します。</p>
</li>
<li><p class="first"><span class="target" id="index-45"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a> を参照してください。</p>
</li>
</ol>
<p>Python 文字列には明示的な長さ情報があるので、 <code class="docutils literal"><span class="pre">%s</span></code> 変換において <code class="docutils literal"><span class="pre">'\0'</span></code> を文字列の末端と仮定したりはしません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span>絶対値が 1e50 を超える数値の <code class="docutils literal"><span class="pre">%f</span></code> 変換が <code class="docutils literal"><span class="pre">%g</span></code> 変換に置き換えられなくなりました。</p>
</div>
<p id="index-27">その他の文字列操作は標準モジュール <a class="reference internal" href="string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal"><span class="pre">string</span></code></a> および <a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> で定義されています。</p>
</div>
<div class="section" id="xrange-type">
<span id="typesseq-xrange"></span><h3>5.6.3. XRange 型<a class="headerlink" href="#xrange-type" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-28"><a class="reference internal" href="functions.html#xrange" title="xrange"><code class="xref py py-class docutils literal"><span class="pre">xrange</span></code></a> 型は値の変更不能なシーケンスで、広範なループ処理に使われています。 <a class="reference internal" href="functions.html#xrange" title="xrange"><code class="xref py py-class docutils literal"><span class="pre">xrange</span></code></a> 型の利点は、 <a class="reference internal" href="functions.html#xrange" title="xrange"><code class="xref py py-class docutils literal"><span class="pre">xrange</span></code></a> オブジェクトは表現する値域の大きさにかかわらず常に同じ量のメモリしか占めないということです。はっきりしたパフォーマンス上の利点はありません。</p>
<p>XRange オブジェクトは非常に限られた振る舞い、すなわち、インデクス検索、反復、 <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> 関数のみをサポートしています。</p>
</div>
<div class="section" id="mutable-sequence-types">
<span id="typesseq-mutable"></span><h3>5.6.4. ミュータブルなシーケンス型<a class="headerlink" href="#mutable-sequence-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-29">リストとバイト配列 (<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>) オブジェクトは、オブジェクトをインプレースに変更できるようにする追加の操作をサポートします。他のミュータブルなシーケンス型 (を言語に追加するとき) も、それらの操作をサポートするべきです。文字列およびタプルはイミュータブルなシーケンス型です: これらのオブジェクトは一度生成されたら変更できません。ミュータブルなシーケンス型では以下の操作が定義されています (ここで <em>x</em> は任意のオブジェクトとします)。</p>
<table border="1" class="docutils" id="index-30">
<colgroup>
<col width="36%" />
<col width="39%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s[i]</span> <span class="pre">=</span> <span class="pre">x</span></code></td>
<td><em>s</em> の要素 <em>i</em> を <em>x</em> と入れ替えます</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">t</span></code></td>
<td><em>s</em> の <em>i</em> から <em>j</em> 番目までのスライスをイテラブル <em>t</em> の内容に入れ替えます</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">del</span> <span class="pre">s[i:j]</span></code></td>
<td><code class="docutils literal"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">[]</span></code> と同じです</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s[i:j:k]</span> <span class="pre">=</span> <span class="pre">t</span></code></td>
<td><code class="docutils literal"><span class="pre">s[i:j:k]</span></code> の要素を <em>t</em> の要素と入れ替えます</td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">del</span> <span class="pre">s[i:j:k]</span></code></td>
<td>リストから <code class="docutils literal"><span class="pre">s[i:j:k]</span></code> の要素を削除します</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.append(x)</span></code></td>
<td><code class="docutils literal"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">[x]</span></code> と同じです</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.extend(t)</span></code> または <code class="docutils literal"><span class="pre">s</span> <span class="pre">+=</span> <span class="pre">t</span></code></td>
<td><code class="docutils literal"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">t</span></code> とほとんど同じです</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s</span> <span class="pre">*=</span> <span class="pre">n</span></code></td>
<td><em>s</em> をその内容を <em>n</em>  回繰り返したもので更新</td>
<td>(11)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.count(x)</span></code></td>
<td><code class="docutils literal"><span class="pre">s[i]</span> <span class="pre">==</span> <span class="pre">x</span></code> となる <em>i</em> の個数を返します</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.index(x[,</span> <span class="pre">i[,</span> <span class="pre">j]])</span></code></td>
<td><code class="docutils literal"><span class="pre">s[k]</span> <span class="pre">==</span> <span class="pre">x</span></code> かつ <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">j</span></code> となる最小の <em>k</em> を返します</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.insert(i,</span> <span class="pre">x)</span></code></td>
<td><code class="docutils literal"><span class="pre">s[i:i]</span> <span class="pre">=</span> <span class="pre">[x]</span></code> と同じです</td>
<td>(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.pop([i])</span></code></td>
<td><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">s[i];</span> <span class="pre">del</span> <span class="pre">s[i];</span> <span class="pre">return</span> <span class="pre">x</span></code> と同じです</td>
<td>(6)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.remove(x)</span></code></td>
<td><code class="docutils literal"><span class="pre">del</span> <span class="pre">s[s.index(x)]</span></code> と同じです</td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.reverse()</span></code></td>
<td><em>s</em> をインプレースに逆転させます</td>
<td>(7)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.sort([cmp[,</span> <span class="pre">key[,</span>
<span class="pre">reverse]]])</span></code></td>
<td><em>s</em> の要素をインプレースに並べ替えます</td>
<td>(7)(8)(9)(10)</td>
</tr>
</tbody>
</table>
<p>注釈:</p>
<ol class="arabic">
<li><p class="first"><em>t</em> は置き換えるスライスと同じ長さでなければいけません。</p>
</li>
<li><p class="first">かつての Python の C 実装では、複数パラメタを受理し、暗黙にそれらをタプルに結合していました。この間違った機能は Python 1.4 で撤廃され、 Python 2.0 の導入とともにエラーにするようになりました。</p>
</li>
<li><p class="first"><em>x</em> は任意のイテラブルオブジェクトにできます。</p>
</li>
<li><p class="first"><em>x</em> が <em>s</em> 中に見つからなかった場合 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。負のインデクスが二番目または三番目のパラメタとして <code class="xref py py-meth docutils literal"><span class="pre">index()</span></code> メソッドに渡されると、これらの値にはスライスのインデクスと同様にリストの長さが加算されます。加算後もまだ負の場合、その値はスライスのインデクスと同様にゼロに切り詰められます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.3 で変更: </span>以前は <code class="xref py py-meth docutils literal"><span class="pre">index()</span></code> には開始と終了位置を指定する引数がありませんでした。</p>
</div>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">insert()</span></code> の最初のパラメタとして負のインデクスが渡された場合、スライスのインデクスと同じく、リストの長さが加算されます。それでも負の値を取る場合、スライスのインデクスと同じく、 0 に丸められます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.3 で変更: </span>以前は、すべての負値は 0 に丸められていました。</p>
</div>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">pop()</span></code> メソッドのオプションの引数 <em>i</em> は標準で <code class="docutils literal"><span class="pre">-1</span></code> なので、標準では最後の要素をリストから除去して返します。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code> および <code class="xref py py-meth docutils literal"><span class="pre">reverse()</span></code> メソッドは大きなリストを並べ替えたり反転したりする際、容量の節約のためにリストを直接変更します。副作用があることをユーザに思い出させるために、これらの操作は並べ替えまたは反転されたリストを返しません。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code> メソッドは、比較を制御するためにオプションの引数をとります。</p>
<p><em>cmp</em> は2つの引数 (リストの要素) からなるカスタムの比較関数を指定します。 これは始めの引数が 2 つ目の引数に比べて小さい、等しい、大きいかに応じて負数、ゼロ、正数を返します。 <code class="docutils literal"><span class="pre">cmp=lambda</span> <span class="pre">x,y:</span> <span class="pre">cmp(x.lower(),</span> <span class="pre">y.lower())</span></code> 。デフォルト値は <code class="docutils literal"><span class="pre">None</span></code> です。</p>
<p><em>key</em> は 1 つの引数からなる関数を指定します。これはリストの各要素から比較のキーを取り出すのに使われます: <code class="docutils literal"><span class="pre">key=str.lower</span></code>。デフォルト値は <code class="docutils literal"><span class="pre">None</span></code> です。</p>
<p><em>reverse</em> はブール値です。<code class="docutils literal"><span class="pre">True</span></code> に設定された場合、リストの要素は各比較が反転したように並び替えられます。</p>
<p>一般的に、 <em>key</em> および <em>reverse</em> の変換プロセスは同等の <em>cmp</em> 関数を指定するより早く動作します。これは <em>key</em> および <em>reverse</em> がそれぞれの要素に一度だけ触れる間に、 <em>cmp</em> はリストのそれぞれの要素に対して複数回呼ばれることによるものです。旧式の <em>cmp</em> 関数を <em>key</em> 関数に変換するには <a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal"><span class="pre">functools.cmp_to_key()</span></code></a> を使用してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.3 で変更: </span><code class="docutils literal"><span class="pre">None</span></code> を渡すのと、 <em>cmp</em> を省略した場合とで、同等に扱うサポートを追加.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.4 で変更: </span><em>key</em> および <em>reverse</em> のサポートを追加.</p>
</div>
</li>
<li><p class="first">Python 2.3 より、 <code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code> メソッドは安定していることが保証されています。ソートは、等しい要素の相対順序が変更されないことが保証されていれば、安定しています — これは複合的なパスでソートを行なう（例えば部署でソートして、それから給与の等級でソートする）のに役立ちます。</p>
</li>
<li><div class="impl-detail first compound">
<p><strong>CPython 実装の詳細:</strong> リストがソートされている間、または変更しようとする試みの影響中、あるいは検査中でさえ、リストは未定義です。Python 2.3 とそれ以降の C 実装では、それらが続いている間、リストは空として出力され、リストがソート中に変更されていることを検知できたら <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
</div>
</li>
<li><p class="first">値 <em>n</em> は整数または <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> を実装したオブジェクトです。 <em>n</em> にゼロや負数を与えると、シーケンスをクリアします。シーケンス内の要素はコピーされません; コピーではなく要素に対する参照カウントが増えます。 <code class="docutils literal"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> について <a class="reference internal" href="#typesseq"><span class="std std-ref">シーケンス型 — str, unicode, list, tuple, bytearray, buffer, xrange</span></a> で説明したとおりです。</p>
</li>
</ol>
</div>
</div>
<div class="section" id="set-types-set-frozenset">
<span id="types-set"></span><h2>5.7. set（集合）型 — <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a><a class="headerlink" href="#set-types-set-frozenset" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-31"><em class="dfn">set</em> オブジェクトは順序付けされていない <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> (ハッシュ可能な) オブジェクトのコレクションです。よくある使い方には、メンバーシップのテスト、数列から重複を削除する、そして論理積、論理和、差集合、対称差など数学的演算の計算が含まれます。 (他のコンテナ型については、組み込みクラスの <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">list</span></code>, <a class="reference internal" href="functions.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>,および、モジュール <a class="reference internal" href="collections.html#module-collections" title="collections: High-performance datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> を参照下さい)</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.4 で追加.</span></p>
</div>
<p>集合は、他のコレクションと同様、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></code>, <code class="docutils literal"><span class="pre">len(set)</span></code>, <code class="docutils literal"><span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></code> をサポートします。コレクションには順序がないので、集合は挿入の順序や要素の位置を記録しません。従って、集合はインデクシング、スライシング、その他のシーケンス的な振舞いをサポートしません。</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> および <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> という、2つの組み込みの集合型があります。 <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> はミュータブルで、<code class="xref py py-meth docutils literal"><span class="pre">add()</span></code> や <code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code> のようなメソッドを使って内容を変更できます。ミュータブルなため、ハッシュ値を持たず、また辞書のキーや他の集合の要素として用いることができません。一方、<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 型はイミュータブルで、<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">ハッシュ可能</span></a> です。作成後に内容を改変できないため、辞書のキーや他の集合の要素として用いることができます。</p>
<p>Python 2.7 では、空でない set (frozenset ではない) は、 <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> コンストラクタに加え、要素を波カッコ中にカンマで区切って列挙することでも生成できます。例: <code class="docutils literal"><span class="pre">{'jack',</span> <span class="pre">'sjoerd'}</span></code>.</p>
<p>どちらのクラスのコンストラクタも同様に働きます:</p>
<dl class="class">
<dt id="set">
<em class="property">class </em><code class="descname">set</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#set" title="この定義へのパーマリンク">¶</a></dt>
<dt id="frozenset">
<em class="property">class </em><code class="descname">frozenset</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> から要素を取り込んだ、新しい <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> もしくは <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> オブジェクトを返します。 集合の要素は <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">ハッシュ可能</span></a> なものでなくてはなりません。集合の集合を表現するためには、内側の集合は <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> オブジェクトでなくてはなりません。<em>iterable</em> が指定されない場合、新しい空の集合が返されます。</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> および <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> のインスタンスは以下の操作を提供します:</p>
<dl class="describe">
<dt>
<code class="descname">len(s)</code></dt>
<dd><p>集合 <em>s</em> の要素数 (<em>s</em> の濃度) を返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x in s</code></dt>
<dd><p><em>x</em> が <em>s</em> のメンバーに含まれるか判定します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x not in s</code></dt>
<dd><p><em>x</em> が <em>s</em> のメンバーに含まれていないことを判定します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.isdisjoint">
<code class="descname">isdisjoint</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.isdisjoint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>集合が <em>other</em> と共通の要素を持たないとき、<code class="docutils literal"><span class="pre">True</span></code> を返します。集合はそれらの積集合が空集合となるときのみ、互いに素 (disjoint) となります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="frozenset.issubset">
<code class="descname">issubset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issubset" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set &lt;= other</code></dt>
<dd><p>set の全ての要素が <em>other</em> に含まれるか判定します。</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set &lt; other</code></dt>
<dd><p>set が <em>other</em> の真部分集合であるかを判定します。つまり、 <code class="docutils literal"><span class="pre">set</span> <span class="pre">&lt;=</span> <span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code> と等価です。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.issuperset">
<code class="descname">issuperset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issuperset" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set &gt;= other</code></dt>
<dd><p><em>other</em> の全ての要素が set に含まれるか判定します。</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set &gt; other</code></dt>
<dd><p>set が <em>other</em> の真上位集合であるかを判定します。つまり、 <code class="docutils literal"><span class="pre">set</span> <span class="pre">&gt;=</span> <span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code> と等価です。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.union">
<code class="descname">union</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.union" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set | other | ...</code></dt>
<dd><p>set と全ての other の要素からなる新しい集合を返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>複数のイテラブルからの入力を受け入れるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="frozenset.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set &amp; other &amp; ...</code></dt>
<dd><p>set と全ての other に共通する要素を持つ、新しい集合を返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>複数のイテラブルからの入力を受け入れるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="frozenset.difference">
<code class="descname">difference</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set - other - ...</code></dt>
<dd><p>set に含まれて、かつ、全ての other に含まれない要素を持つ、新しい集合を返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>複数のイテラブルからの入力を受け入れるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="frozenset.symmetric_difference">
<code class="descname">symmetric_difference</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set ^ other</code></dt>
<dd><p>set と <em>other</em> のいずれか一方だけに含まれる要素を持つ新しい集合を返します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.copy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>s</em> の浅いコピーを新しい集合として返します。</p>
</dd></dl>

<p>なお、演算子でない版の <a class="reference internal" href="#frozenset.union" title="frozenset.union"><code class="xref py py-meth docutils literal"><span class="pre">union()</span></code></a>, <a class="reference internal" href="#frozenset.intersection" title="frozenset.intersection"><code class="xref py py-meth docutils literal"><span class="pre">intersection()</span></code></a>, <a class="reference internal" href="#frozenset.difference" title="frozenset.difference"><code class="xref py py-meth docutils literal"><span class="pre">difference()</span></code></a>, <a class="reference internal" href="#frozenset.symmetric_difference" title="frozenset.symmetric_difference"><code class="xref py py-meth docutils literal"><span class="pre">symmetric_difference()</span></code></a>, <a class="reference internal" href="#frozenset.issubset" title="frozenset.issubset"><code class="xref py py-meth docutils literal"><span class="pre">issubset()</span></code></a>, <a class="reference internal" href="#frozenset.issuperset" title="frozenset.issuperset"><code class="xref py py-meth docutils literal"><span class="pre">issuperset()</span></code></a> メソッドは、任意のイテラブルを引数として受け付けます。対して、演算子を使う版では、引数は集合でなくてはなりません。これは、<code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">&amp;</span> <span class="pre">'cbs'</span></code> のような誤りがちな構文を予防し、より読みやすい <code class="docutils literal"><span class="pre">set('abc').intersection('cbs')</span></code> を支持します。</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> と <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> のどちらも、集合同士の比較をサポートします。二つの集合は、それぞれの集合の要素全てが他方にも含まれている (互いに他方の部分集合である) とき、かつそのときに限り等しいです。一方の集合が他方の集合の真部分集合である (部分集合であるが等しくない) とき、かつそのときに限り一方の集合は他方の集合より小さいです。一方の集合が他方の集合の真上位集合である (上位集合であるが等しくない) とき、かつそのときに限り一方の集合は他方の集合より大きいです。</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> のインスタンスは、 <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> のインスタンスと、要素に基づいて比較されます。例えば、 <code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">==</span> <span class="pre">frozenset('abc')</span></code> や <code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">in</span> <span class="pre">set([frozenset('abc')])</span></code> は <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
<p>部分集合と等価性の比較は全順序付けを行う関数へと一般化することはできません。例えば、互いに素である二つの非空集合は、等しくなく、他方の部分集合でもありませんから、以下の <em>すべて</em> に <code class="docutils literal"><span class="pre">False</span></code> を返します: <code class="docutils literal"><span class="pre">a&lt;b</span></code>, <code class="docutils literal"><span class="pre">a==b</span></code>, そして <code class="docutils literal"><span class="pre">a&gt;b</span></code> 。そのため、 set は <a class="reference internal" href="../reference/datamodel.html#object.__cmp__" title="object.__cmp__"><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code></a> メソッドを実装しません。</p>
<p>集合は半順序（部分集合関係）しか定義しないので、集合のリストにおける <code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code> メソッドの出力は未定義です。</p>
<p>集合の要素は、辞書のキーのように、ハッシュ可能 (<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>) でなければなりません。</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> インスタンスと <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> インスタンスを取り混ぜての二項演算は、第一被演算子の型を返します。例えば: <code class="docutils literal"><span class="pre">frozenset('ab')</span> <span class="pre">|</span> <span class="pre">set('bc')</span></code> は <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> インスタンスを返します。</p>
<p>以下の表に挙げる演算は <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> に適用されますが、<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> のイミュータブルなインスタンスには適用されません:</p>
<dl class="method">
<dt id="frozenset.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.update" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set |= other | ...</code></dt>
<dd><p>全ての other の要素を追加し、 set を更新します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>複数のイテラブルからの入力を受け入れるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="frozenset.intersection_update">
<code class="descname">intersection_update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection_update" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set &amp;= other &amp; ...</code></dt>
<dd><p>元の set と全ての other に共通する要素だけを残して set を更新します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>複数のイテラブルからの入力を受け入れるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="frozenset.difference_update">
<code class="descname">difference_update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference_update" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set -= other | ...</code></dt>
<dd><p><em>other</em> に含まれる要素を取り除き、 set を更新します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>複数のイテラブルからの入力を受け入れるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="frozenset.symmetric_difference_update">
<code class="descname">symmetric_difference_update</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference_update" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set ^= other</code></dt>
<dd><p>どちらかにのみ含まれて、共通には持たない要素のみで set を更新します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.add" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要素 <em>elem</em> を set に追加します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.remove" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要素 <em>elem</em> を set から取り除きます。<em>elem</em> が set に含まれていなければ <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.discard">
<code class="descname">discard</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.discard" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要素 <em>elem</em> が set に含まれていれば、取り除きます。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.pop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>任意に要素をから返し、それを set から取り除きます。set が空であれば、 <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>set の全ての要素を取り除きます。</p>
</dd></dl>

<p>なお、演算子でない版の <a class="reference internal" href="#frozenset.update" title="frozenset.update"><code class="xref py py-meth docutils literal"><span class="pre">update()</span></code></a>, <a class="reference internal" href="#frozenset.intersection_update" title="frozenset.intersection_update"><code class="xref py py-meth docutils literal"><span class="pre">intersection_update()</span></code></a>, <a class="reference internal" href="#frozenset.difference_update" title="frozenset.difference_update"><code class="xref py py-meth docutils literal"><span class="pre">difference_update()</span></code></a>, および <a class="reference internal" href="#frozenset.symmetric_difference_update" title="frozenset.symmetric_difference_update"><code class="xref py py-meth docutils literal"><span class="pre">symmetric_difference_update()</span></code></a> メソッドは、任意のイテラブルを引数として受け付けます。</p>
<p><a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a>, <a class="reference internal" href="#frozenset.remove" title="frozenset.remove"><code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code></a>, <a class="reference internal" href="#frozenset.discard" title="frozenset.discard"><code class="xref py py-meth docutils literal"><span class="pre">discard()</span></code></a> メソッドの引数 <em>elem</em> は集合かもしれないことに注意してください。その集合と等価な <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> の検索をサポートするために、 <em>elem</em> から一時的な frozenset を作成します。</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference internal" href="sets.html#comparison-to-builtin-set"><span class="std std-ref">組み込み set 型との比較</span></a></dt>
<dd><a class="reference internal" href="sets.html#module-sets" title="sets: Implementation of sets of unique elements. (非推奨)"><code class="xref py py-mod docutils literal"><span class="pre">sets</span></code></a> モジュールと組み込み set 型の違い</dd>
</dl>
</div>
</div>
<div class="section" id="mapping-types-dict">
<span id="typesmapping"></span><h2>5.8. マッピング型 — <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a><a class="headerlink" href="#mapping-types-dict" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-32">マッピング (<a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>) オブジェクトは、ハッシュ可能 (<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>) な値を任意のオブジェクトに対応付けます。マッピングはミュータブルなオブジェクトです。現在、標準マッピング型は辞書 (<em class="dfn">dictionary</em>) だけです。 (他のコンテナについては組み込みの <code class="xref py py-class docutils literal"><span class="pre">list</span></code>, <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, および <a class="reference internal" href="functions.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> クラスと、 <a class="reference internal" href="collections.html#module-collections" title="collections: High-performance datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールを参照下さい。)</p>
<p>辞書のキーは <em>ほぼ</em> 任意の値です。ハッシュ可能 (<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>) でない値、つまり、リストや辞書その他のミュータブルな型 (オブジェクトの同一性ではなく値で比較されるもの) はキーとして使用できません。キーとして使われる数値型は通常の数値比較のルールに従います: もしふたつの数値が (例えば <code class="docutils literal"><span class="pre">1</span></code> と <code class="docutils literal"><span class="pre">1.0</span></code> のように) 等しければ、同じ辞書の項目として互換的に使用できます。 (ただし、コンピュータは浮動小数点数を近似値として保管するので、辞書型のキーとして使用するのはたいてい賢くありません。)</p>
<p>辞書は <code class="docutils literal"><span class="pre">key:</span> <span class="pre">value</span></code> 対のカンマ区切りのリストを波括弧でくくることで作成できます。例えば: <code class="docutils literal"><span class="pre">{'jack':</span> <span class="pre">4098,</span> <span class="pre">'sjoerd':</span> <span class="pre">4127}</span></code> あるいは <code class="docutils literal"><span class="pre">{4098:</span> <span class="pre">'jack',</span> <span class="pre">4127:</span> <span class="pre">'sjoerd'}</span></code> 。あるいは、 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> コンストラクタでも作成できます。</p>
<dl class="class">
<dt id="dict">
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>**kwarg</em><span class="sig-paren">)</span><a class="headerlink" href="#dict" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>mapping</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>iterable</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dd><p>オプションの位置引数と空集合の可能性もあるキーワード引数から初期化された新しい辞書を返します。</p>
<p>位置引数が何も与えられなかった場合、空の辞書が作成されます。位置引数が与えられ、それがマッピングオブジェクトだった場合、そのマッピングオブジェクトと同じキーと値のペアを持つ辞書が作成されます。それ以外の場合、位置引数は <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> オブジェクトでなければなりません。iterable のそれぞれの要素自身は、ちょうど 2 個のオブジェクトを持つイテラブルでなければなりません。それぞれの要素の最初のオブジェクトは新しい辞書のキーになり、2 番目のオブジェクトはそれに対応する値になります。同一のキーが 2 回以上現れた場合は、そのキーの最後の値が新しい辞書での対応する値になります。</p>
<p>キーワード引数が与えられた場合、キーワード引数とその値が位置引数から作られた辞書に追加されます。既に存在しているキーが追加された場合、キーワード引数の値は位置引数の値を置き換えます。</p>
<p>例を出すと、次の例は全て <code class="docutils literal"><span class="pre">{&quot;one&quot;:</span> <span class="pre">1,</span> <span class="pre">&quot;two&quot;:</span> <span class="pre">2,</span> <span class="pre">&quot;three&quot;:</span> <span class="pre">3}</span></code> に等しい辞書を返します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">one</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">three</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span> <span class="o">==</span> <span class="n">d</span> <span class="o">==</span> <span class="n">e</span>
<span class="go">True</span>
</pre></div>
</div>
<p>最初の例のようにキーワード引数を与える方法では、キーは有効な Python の識別子でなければなりません。それ以外の方法では、辞書のキーとして有効などんなキーでも使えます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.2 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.3 で変更: </span>キーワード引数からの辞書型の作成のサポートが追加されました。</p>
</div>
<p>以下は辞書型がサポートする操作です (それゆえ、カスタムのマップ型もこれらの操作をサポートするべきです):</p>
<dl class="describe">
<dt>
<code class="descname">len(d)</code></dt>
<dd><p>辞書 <em>d</em> の項目数を返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">d[key]</code></dt>
<dd><p><em>d</em> のキー <em>key</em> の項目を返します。マップに <em>key</em> が存在しなければ、 <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出します。</p>
<p id="index-33">辞書のサブクラスが <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> メソッドを定義しておらず、 <em>key</em> が存在しないなら、 <code class="docutils literal"><span class="pre">d[key]</span></code> 演算はこのメソッドをキー <em>key</em> を引数として呼び出します。結果として、 <code class="docutils literal"><span class="pre">d[key]</span></code> 演算は、キーが存在しなければ、 <code class="docutils literal"><span class="pre">__missing__(key)</span></code> の呼び出しによって返されまたは送出されたものを何でも、返しまたは送出します。他の演算やメソッドは <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> を呼び出しません。 <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> が定義されていなければ、 <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> が送出されます。 <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> はメソッドでなければならず、インスタンス変数であってはなりません:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Counter</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
<p>ここでお見せした例は <a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal"><span class="pre">collections.Counter</span></code></a> 実装の一部です。これとは違った <code class="docutils literal"><span class="pre">__missing__</span></code> が:class:<cite>collections.defaultdict</cite> で使われています。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加: </span>辞書のサブクラスで __missing__ メソッドを認識するようになりました。</p>
</div>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">d[key] = value</code></dt>
<dd><p><code class="docutils literal"><span class="pre">d[key]</span></code> に <em>value</em> を設定します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">del d[key]</code></dt>
<dd><p><em>d</em> から <code class="docutils literal"><span class="pre">d[key]</span></code> を削除します。マップに <em>key</em> が存在しなければ、 <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">key in d</code></dt>
<dd><p><em>d</em> がキー <em>key</em> を持っていれば <code class="docutils literal"><span class="pre">True</span></code> を、そうでなければ、 <code class="docutils literal"><span class="pre">False</span></code> を返します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">key not in d</code></dt>
<dd><p><code class="docutils literal"><span class="pre">not</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">d</span></code> と等価です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">iter(d)</code></dt>
<dd><p>辞書のキーに渡るイテレータを返します。これは  <a class="reference internal" href="#dict.iterkeys" title="dict.iterkeys"><code class="xref py py-meth docutils literal"><span class="pre">iterkeys()</span></code></a> へのショートカットです。</p>
</dd></dl>

<dl class="method">
<dt id="dict.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の全ての項目を消去します。</p>
</dd></dl>

<dl class="method">
<dt id="dict.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.copy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の浅いコピーを返します。</p>
</dd></dl>

<dl class="method">
<dt id="dict.fromkeys">
<code class="descname">fromkeys</code><span class="sig-paren">(</span><em>seq</em><span class="optional">[</span>, <em>value</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.fromkeys" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>seq</em> からキーを取り、値を <em>value</em> に設定した、新しい辞書を作成します。</p>
<p><a class="reference internal" href="#dict.fromkeys" title="dict.fromkeys"><code class="xref py py-func docutils literal"><span class="pre">fromkeys()</span></code></a> は新しい辞書を返すクラスメソッドです。 <em>value</em> のデフォルト値は <code class="docutils literal"><span class="pre">None</span></code> です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dict.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.get" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>key</em> が辞書にあれば <em>key</em> に対する値を、そうでなければ <em>default</em> を返します。 <em>default</em> が与えられなかった場合、デフォルトでは <code class="docutils literal"><span class="pre">None</span></code> となります。そのため、このメソッドは <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出することはありません。</p>
</dd></dl>

<dl class="method">
<dt id="dict.has_key">
<code class="descname">has_key</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#dict.has_key" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書に <em>key</em> が存在するかを確認します。 <code class="docutils literal"><span class="pre">key</span> <span class="pre">in</span> <span class="pre">d</span></code> が可能になっているので、 <a class="reference internal" href="#dict.has_key" title="dict.has_key"><code class="xref py py-meth docutils literal"><span class="pre">has_key()</span></code></a> は廃れた用法です。</p>
</dd></dl>

<dl class="method">
<dt id="dict.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.items" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書のコピーを <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> の対のリストとして返します。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> キーと値のリストは任意の順序で返されますが、ランダムではなく、 Python の実装と、辞書への挿入、および、削除操作の来歴によって決まります。</p>
</div>
<p><a class="reference internal" href="#dict.items" title="dict.items"><code class="xref py py-meth docutils literal"><span class="pre">items()</span></code></a>, <a class="reference internal" href="#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal"><span class="pre">keys()</span></code></a>, <a class="reference internal" href="#dict.values" title="dict.values"><code class="xref py py-meth docutils literal"><span class="pre">values()</span></code></a>, <a class="reference internal" href="#dict.iteritems" title="dict.iteritems"><code class="xref py py-meth docutils literal"><span class="pre">iteritems()</span></code></a>, <a class="reference internal" href="#dict.iterkeys" title="dict.iterkeys"><code class="xref py py-meth docutils literal"><span class="pre">iterkeys()</span></code></a> および <a class="reference internal" href="#dict.itervalues" title="dict.itervalues"><code class="xref py py-meth docutils literal"><span class="pre">itervalues()</span></code></a> は辞書に干渉して更新しなければ、返却順は直接対応関係にあります。つまり <code class="docutils literal"><span class="pre">(value,</span> <span class="pre">key)</span></code> の対を <a class="reference internal" href="functions.html#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a> を使って生成するとができます: <code class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">zip(d.values(),</span> <span class="pre">d.keys())</span></code> 。 <a class="reference internal" href="#dict.iterkeys" title="dict.iterkeys"><code class="xref py py-meth docutils literal"><span class="pre">iterkeys()</span></code></a> と <a class="reference internal" href="#dict.itervalues" title="dict.itervalues"><code class="xref py py-meth docutils literal"><span class="pre">itervalues()</span></code></a> でも同じです: <code class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">zip(d.itervalues(),</span> <span class="pre">d.iterkeys())</span></code> は先と同じ値を返します。同じリストを得るには <code class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">[(v,</span> <span class="pre">k)</span> <span class="pre">for</span> <span class="pre">(k,</span> <span class="pre">v)</span> <span class="pre">in</span> <span class="pre">d.iteritems()]</span></code> としても出来ます。</p>
</dd></dl>

<dl class="method">
<dt id="dict.iteritems">
<code class="descname">iteritems</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.iteritems" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> の対をイテレータで返します。 <a class="reference internal" href="#dict.items" title="dict.items"><code class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></code></a> の記述も参照下さい。</p>
<p><a class="reference internal" href="#dict.iteritems" title="dict.iteritems"><code class="xref py py-meth docutils literal"><span class="pre">iteritems()</span></code></a> を辞書の項目の追加や削除と同時に行うと、 <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を送出されるか全ての項目に対する反復に失敗することになります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dict.iterkeys">
<code class="descname">iterkeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.iterkeys" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書のキーをイテレータで返します。 <a class="reference internal" href="#dict.items" title="dict.items"><code class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></code></a> の記述も参照下さい。</p>
<p><a class="reference internal" href="#dict.iterkeys" title="dict.iterkeys"><code class="xref py py-meth docutils literal"><span class="pre">iterkeys()</span></code></a> を辞書の項目の追加や削除と同時に行うと、 <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を送出されるか全ての項目に対する反復に失敗することになります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dict.itervalues">
<code class="descname">itervalues</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.itervalues" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の値をイテレータで返します。 <a class="reference internal" href="#dict.items" title="dict.items"><code class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></code></a> の記述も参照下さい。</p>
<p><a class="reference internal" href="#dict.itervalues" title="dict.itervalues"><code class="xref py py-meth docutils literal"><span class="pre">itervalues()</span></code></a> を辞書の項目の追加や削除と同時に行うと、 <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を送出されるか全ての項目に対する反復に失敗することになります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dict.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.keys" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書のキーのリストのコピーを返します。 <a class="reference internal" href="#dict.items" title="dict.items"><code class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></code></a> の記述も参照下さい。</p>
</dd></dl>

<dl class="method">
<dt id="dict.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.pop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>key</em> が辞書に存在すればその値を辞書から消去して返し、そうでなければ <em>default</em> を返します。 <em>default</em> が与えらず、かつ <em>key</em> が辞書に存在しなければ <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dict.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.popitem" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>任意の <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> 対を辞書から消去して返します。</p>
<p>集合のアルゴリズムで使われるのと同じように、 <a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-func docutils literal"><span class="pre">popitem()</span></code></a> は辞書を破壊的にイテレートするのに便利です。辞書が空であれば、 <a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-func docutils literal"><span class="pre">popitem()</span></code></a> の呼び出しは <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="dict.setdefault">
<code class="descname">setdefault</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.setdefault" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>もし、 <em>key</em> が辞書に存在すれば、その値を返します。そうでなければ、値を <em>default</em> として <em>key</em> を挿入し、 <em>default</em> を返します。 <em>default</em> のデフォルトは <code class="docutils literal"><span class="pre">None</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="dict.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em>other</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.update" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の内容を <em>other</em> のキーと値で更新します。既存のキーは上書きされます。返り値は <code class="docutils literal"><span class="pre">None</span></code> です。</p>
<p><a class="reference internal" href="#dict.update" title="dict.update"><code class="xref py py-func docutils literal"><span class="pre">update()</span></code></a> は、他の辞書オブジェクトでもキー/値の対のイテラブル (タプル、もしくは、長さが2のイテラブル) でも、どちらでも受け付けます。キーワード引数が指定されれば、そのキー/値の対で辞書を更新します: <code class="docutils literal"><span class="pre">d.update(red=1,</span> <span class="pre">blue=2)</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.4 で変更: </span>キーと値の対のイテラブル、および、キーワード引数を引数として与えることができるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="dict.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.values" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の値のリストのコピーを返します。 <a class="reference internal" href="#dict.items" title="dict.items"><code class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></code></a> の記述も参照下さい。</p>
</dd></dl>

<dl class="method">
<dt id="dict.viewitems">
<code class="descname">viewitems</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.viewitems" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書のアイテム (<code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> のペア) の新しいビューを返します。ビューオブジェクトについては下に説明があります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dict.viewkeys">
<code class="descname">viewkeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.viewkeys" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書のキーの新しいビューを返します。ビューオブジェクトについては下に説明があります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dict.viewvalues">
<code class="descname">viewvalues</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.viewvalues" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の値の新しいビューを返します。ビューオブジェクトについては下に説明があります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<p>辞書は、同じ <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> の対を持つときのみ等しくなります。</p>
</dd></dl>

<div class="section" id="dictionary-view-objects">
<span id="dict-views"></span><h3>5.8.1. 辞書ビューオブジェクト<a class="headerlink" href="#dictionary-view-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#dict.viewkeys" title="dict.viewkeys"><code class="xref py py-meth docutils literal"><span class="pre">dict.viewkeys()</span></code></a>, <a class="reference internal" href="#dict.viewvalues" title="dict.viewvalues"><code class="xref py py-meth docutils literal"><span class="pre">dict.viewvalues()</span></code></a>, <a class="reference internal" href="#dict.viewitems" title="dict.viewitems"><code class="xref py py-meth docutils literal"><span class="pre">dict.viewitems()</span></code></a> によって返されるオブジェクトは、 <em>ビューオブジェクト</em> です。これらは、辞書の項目の動的なビューを提供し、辞書が変更された時、ビューはその変更を反映します。</p>
<p>辞書ビューは、イテレートすることで対応するデータを yield できます。また、帰属判定をサポートします:</p>
<dl class="describe">
<dt>
<code class="descname">len(dictview)</code></dt>
<dd><p>辞書の項目数を返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">iter(dictview)</code></dt>
<dd><p>辞書のキー、値、または (<code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> のタプルとして表される) 項目に渡るイテレータを返します。</p>
<p>キーと値のリストはある任意の順序でイテレートされますが、ランダムではなく、 Python の実装によって変わり、辞書への挿入や削除の履歴に依存します。キー、値、要素のビューを通して、辞書の変更を挟まずにイテレートされたら、その要素の順序は完全に一致します。これにより、 <code class="docutils literal"><span class="pre">(value,</span> <span class="pre">key)</span></code> の対を <a class="reference internal" href="functions.html#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a> で作成できます: <code class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">zip(d.values(),</span> <span class="pre">d.keys())</span></code> 。同じリストを作成する他の方法は、 <code class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">[(v,</span> <span class="pre">k)</span> <span class="pre">for</span> <span class="pre">(k,</span> <span class="pre">v)</span> <span class="pre">in</span> <span class="pre">d.items()]</span></code> です。</p>
<p>辞書の項目の追加や削除中にビューをイテレートすると、 <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を送出したり、すべての項目に渡ってイテレートできなかったりします。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x in dictview</code></dt>
<dd><p><em>x</em> が下にある辞書のキー、値、または項目 (項目の場合、 <em>x</em> は <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> タプルであるべきです) にあるとき <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
</dd></dl>

<p>キーのビューは、項目が一意的でハッシュ可能であるという点で、集合に似ています。すべての値がハッシュ可能なら、 <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> 対も一意的でハッシュ可能なので、要素のビューも集合に似ています。(値のビューは、要素が一般に一意的でないことから、集合に似ているとは考えられません。) これによりこれらへの集合演算が利用出来ます (&quot;other&quot; はもう一つのビューか集合です):</p>
<dl class="describe">
<dt>
<code class="descname">dictview &amp; other</code></dt>
<dd><p>辞書ビューと別のオブジェクトの共通部分を新しい集合として返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">dictview | other</code></dt>
<dd><p>辞書ビューと別のオブジェクトの合併集合を新しい集合として返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">dictview - other</code></dt>
<dd><p>辞書ビューと別のオブジェクトの差集合 (<em>dictview</em> に属して <em>other</em> に属さないすべての要素) を新しい集合として返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">dictview ^ other</code></dt>
<dd><p>辞書ビューと別のオブジェクトの対称差 (<em>dictview</em> と <em>other</em> のどちらかに属すが両方には属さないすべての要素) を新しい集合として返します。</p>
</dd></dl>

<p>辞書ビューの使用法の例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dishes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">viewkeys</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">viewvalues</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># iteration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">+=</span> <span class="n">val</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">504</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># keys and values are iterated over in the same order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;eggs&#39;, &#39;bacon&#39;, &#39;sausage&#39;, &#39;spam&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">[2, 1, 1, 500]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view objects are dynamic and reflect dict changes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">&#39;eggs&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">&#39;sausage&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;spam&#39;, &#39;bacon&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># set operations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s1">&#39;eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">,</span> <span class="s1">&#39;salad&#39;</span><span class="p">}</span>
<span class="go">{&#39;bacon&#39;}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="file-objects">
<span id="bltin-file-objects"></span><h2>5.9. ファイルオブジェクト<a class="headerlink" href="#file-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-34">ファイルオブジェクトは C の <code class="docutils literal"><span class="pre">stdio</span></code> パッケージを使って実装されており、組み込み関数の <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> で生成することができます。ファイルオブジェクトはまた、 <a class="reference internal" href="os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">os.popen()</span></code></a> や <a class="reference internal" href="os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">os.fdopen()</span></code></a>, ソケットオブジェクトの <code class="xref py py-meth docutils literal"><span class="pre">makefile()</span></code> メソッドのような、他の組み込み関数およびメソッドによっても返されます。一時ファイルは <a class="reference internal" href="tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal"><span class="pre">tempfile</span></code></a> モジュールを使って生成でき、ファイルやディレクトリのコピー、移動、消去などの高次の操作は <a class="reference internal" href="shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal"><span class="pre">shutil</span></code></a> モジュールで行えます。</p>
<p>ファイル操作が I/O 関連の理由で失敗した場合例外 <a class="reference internal" href="exceptions.html#exceptions.IOError" title="exceptions.IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a> が送出されます。この理由には例えば <code class="xref py py-meth docutils literal"><span class="pre">seek()</span></code> を端末デバイスに行ったり、読み出し専用で開いたファイルに書き込みを行うといった、何らかの理由によってそのファイルで定義されていない操作を行ったような場合も含まれます。</p>
<p>ファイルは以下のメソッドを持ちます:</p>
<dl class="method">
<dt id="file.close">
<code class="descclassname">file.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#file.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルを閉じます。閉じられたファイルはそれ以後読み書きすることはできません。ファイルが開かれていることが必要な操作は、ファイルが閉じられた後はすべて <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。 <a class="reference internal" href="#file.close" title="file.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> を一度以上呼び出してもかまいません。</p>
<p>Python 2.5 から <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文を使えばこのメソッドを直接呼び出す必要はなくなりました。たとえば、以下のコードは <em>f</em> を <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> ブロックを抜ける際に自動的に閉じます。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">with_statement</span> <span class="c1"># This isn&#39;t required in Python 2.6</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;hello.txt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="nb">print</span> <span class="n">line</span><span class="p">,</span>
</pre></div>
</div>
<p>古いバージョンの Python では同じ効果を得るために次のようにしなければいけませんでした。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;hello.txt&quot;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="nb">print</span> <span class="n">line</span><span class="p">,</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">全ての Python の &quot;ファイル的&quot; 型が <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文用のコンテキストマネージャとして使えるわけではありません。もし、全てのファイル的オブジェクトで動くようにコードを書きたいのならば、オブジェクトを直接使うのではなく <a class="reference internal" href="contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> にある <a class="reference internal" href="contextlib.html#contextlib.closing" title="contextlib.closing"><code class="xref py py-func docutils literal"><span class="pre">contextlib.closing()</span></code></a> 関数を使うと良いでしょう。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.flush">
<code class="descclassname">file.</code><code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#file.flush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">stdio</span></code> の <code class="xref c c-func docutils literal"><span class="pre">fflush()</span></code> のように、内部バッファをフラッシュします。ファイル類似のオブジェクトによっては、この操作は何も行いません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#file.flush" title="file.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a> は必ずしもファイルのデータをディスクに書き込むとは限りません。そのような挙動を保証するには <a class="reference internal" href="#file.flush" title="file.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a> の後に <a class="reference internal" href="os.html#os.fsync" title="os.fsync"><code class="xref py py-func docutils literal"><span class="pre">os.fsync()</span></code></a> を使って下さい。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.fileno">
<code class="descclassname">file.</code><code class="descname">fileno</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#file.fileno" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-35">背後にある実装系がオペレーティングシステムに I/O 操作を要求するために用いる、整数の &quot;ファイル記述子&quot; (ファイルデスクリプタ) を返します。この値は他の用途として、 <a class="reference internal" href="fcntl.html#module-fcntl" title="fcntl: The fcntl() and ioctl() system calls. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">fcntl</span></code></a> モジュールや <a class="reference internal" href="os.html#os.read" title="os.read"><code class="xref py py-func docutils literal"><span class="pre">os.read()</span></code></a> やその仲間のような、ファイル記述子を必要とする低レベルのインタフェースで役に立ちます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">本物のファイルデスクリプタを持たないファイル類似のオブジェクトは、このメソッドを提供すべきでは <em>ありません</em> 。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.isatty">
<code class="descclassname">file.</code><code class="descname">isatty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#file.isatty" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルが tty (または類似の) デバイスに接続されている場合 <code class="docutils literal"><span class="pre">True</span></code> を返し、そうでない場合 <code class="docutils literal"><span class="pre">False</span></code> を返します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">ファイル類似のオブジェクトが実際のファイルに関連付けられていない場合、このメソッドを実装すべきでは <em>ありません</em> 。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.next">
<code class="descclassname">file.</code><code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#file.next" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルオブジェクトはそれ自身がイテレータです。すなわち、 <code class="docutils literal"><span class="pre">iter(f)</span></code> は (<em>f</em> が閉じられていない限り) <em>f</em> を返します。 <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループ (例えば <code class="docutils literal"><span class="pre">for</span> <span class="pre">line</span> <span class="pre">in</span> <span class="pre">f:</span> <span class="pre">print</span> <span class="pre">line.strip()</span></code>) のようにファイルがイテレータとして使われた場合、 <a class="reference internal" href="#file.next" title="file.next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a> メソッドが繰り返し呼び出されます。ファイルが読み込みのために開かれている場合、このメソッドは次の入力行を返すか、または、 EOF に到達したときに <a class="reference internal" href="exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> を送出します (ファイルが書き込みモードで開かれている場合、動作は未定義です) 。ファイル内の各行に対する <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループ (非常によくある操作です) を効率的な方法で行うために、 <a class="reference internal" href="#file.next" title="file.next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a> メソッドは隠蔽された先読みバッファを使います。先読みバッファを使った結果として、 (<a class="reference internal" href="#file.readline" title="file.readline"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a> のような) 他のファイルメソッドと <a class="reference internal" href="#file.next" title="file.next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a> を組み合わせて使うとうまく動作しません。しかし、 <a class="reference internal" href="#file.seek" title="file.seek"><code class="xref py py-meth docutils literal"><span class="pre">seek()</span></code></a> を使ってファイル位置を絶対指定しなおすと、先読みバッファは消去されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.read">
<code class="descclassname">file.</code><code class="descname">read</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#file.read" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最大で <em>size</em> バイトをファイルから読み込みます (<em>size</em> バイトを取得する前に EOF に到達した場合、それ以下の長さになります) 。 <em>size</em> 引数が負であるか省略された場合、 EOF に到達するまでの全てのデータを読み込みます。読み出されたバイト列は文字列オブジェクトとして返されます。直後に EOF に到達した場合、空の文字列が返されます。 (端末のようなある種のファイルでは、 EOF に到達した後でファイルを読みつづけることにも意味があります) 。このメソッドは、 <em>size</em> バイトに可能な限り近くデータを取得するために、背後の C 関数 <code class="xref c c-func docutils literal"><span class="pre">fread()</span></code> を 1 度以上呼び出すかもしれないので注意してください。また、非ブロック・モードでは、 <em>size</em> パラメータが与えられなくても、要求されたよりも少ないデータが返される場合があることに注意してください。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">この関数は単純に、背後の C 関数 <code class="xref c c-func docutils literal"><span class="pre">fread()</span></code> のラッパーです。そのため、 EOF が予期せず検出されたりされなかったりといった個別の事情があっても同じように振舞うだけです。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.readline">
<code class="descclassname">file.</code><code class="descname">readline</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#file.readline" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルから一行全部を読み込みます。行末の改行文字は文字列に残ります (だだし、ファイルが不完全な行で終わっていたら、存在しないかもしれません)。 <a class="footnote-reference" href="#id17" id="id11">[6]</a> <em>size</em> 引数が与えられ、負でなければ、それが (行末の改行文字を含む) 最大バイト数となり、不完全な行でも返されます。 <em>size</em> が 0 でなければ、空の文字列が返されるのは、即座に EOF に到達したとき <em>だけ</em> です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">C <code class="docutils literal"><span class="pre">stdio</span></code> の <code class="xref c c-func docutils literal"><span class="pre">fgets()</span></code> と違い、入力中にヌル文字 (<code class="docutils literal"><span class="pre">'\0'</span></code>) が含まれていれば、ヌル文字を含んだ文字列が返されます。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.readlines">
<code class="descclassname">file.</code><code class="descname">readlines</code><span class="sig-paren">(</span><span class="optional">[</span><em>sizehint</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#file.readlines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#file.readline" title="file.readline"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a> を使ってに到達するまで読み出し、 EOF 読み出された行を含むリストを返します。オプションの <em>sizehint</em> 引数が存在すれば、 EOF まで読み出す代わりに完全な行を全体で大体 <em>sizehint</em> バイトになるように (おそらく内部バッファサイズを切り詰めて) 読み出します。ファイル類似のインタフェースを実装しているオブジェクトは、 <em>sizehint</em> を実装できないか効率的に実装できない場合には無視してもかまいません。</p>
</dd></dl>

<dl class="method">
<dt id="file.xreadlines">
<code class="descclassname">file.</code><code class="descname">xreadlines</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#file.xreadlines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <code class="docutils literal"><span class="pre">iter(f)</span></code> と同じ結果を返します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.1 で追加.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 2.3 で撤廃: </span>代わりに <code class="docutils literal"><span class="pre">for</span> <span class="pre">line</span> <span class="pre">in</span> <span class="pre">file</span></code> を使ってください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.seek">
<code class="descclassname">file.</code><code class="descname">seek</code><span class="sig-paren">(</span><em>offset</em><span class="optional">[</span>, <em>whence</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#file.seek" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="docutils literal"><span class="pre">stdio</span></code> の <code class="xref c c-func docutils literal"><span class="pre">fseek()</span></code> が行うように、ファイルの現在位置を設定します。 <em>whence</em> 引数はオプションで、標準の値は <code class="docutils literal"><span class="pre">os.SEEK_SET</span></code> もしくは <code class="docutils literal"><span class="pre">0</span></code> (絶対位置指定) です; 他に取り得る値は <code class="docutils literal"><span class="pre">os.SEEK_CUR</span></code> もしくは <code class="docutils literal"><span class="pre">1</span></code> (現在のファイル位置から相対的に seek する) および <code class="docutils literal"><span class="pre">os.SEEK_END</span></code> もしくは <code class="docutils literal"><span class="pre">2</span></code> (ファイルの末端から相対的に seek する) です。戻り値はありません。</p>
<p>例えば、 <code class="docutils literal"><span class="pre">f.seek(2,</span> <span class="pre">os.SEEK_CUR)</span></code> 位置を2つ進めます。 <code class="docutils literal"><span class="pre">f.seek(-3,</span> <span class="pre">os.SEEK_END)</span></code> では終端の3つ手前に設定します。</p>
<p>ファイルを追記モード (モード <code class="docutils literal"><span class="pre">'a'</span></code> または <code class="docutils literal"><span class="pre">'a+'</span></code>) で開いた場合、書き込みを行うまでに行った <a class="reference internal" href="#file.seek" title="file.seek"><code class="xref py py-meth docutils literal"><span class="pre">seek()</span></code></a> 操作はすべて元に戻されるので注意してください。ファイルが追記のみの書き込みモード (<code class="docutils literal"><span class="pre">'a'</span></code>) で開かれた場合、このメソッドは実質何も行いませんが、読み込みが可能な追記モード (<code class="docutils literal"><span class="pre">'a+'</span></code>) で開かれたファイルでは役に立ちます。ファイルをテキストモードで (<code class="docutils literal"><span class="pre">'b'</span></code> なしで) 開いた場合、 <a class="reference internal" href="#file.tell" title="file.tell"><code class="xref py py-meth docutils literal"><span class="pre">tell()</span></code></a> が返すオフセットのみが正しい値になります。他のオフセット値を使った場合、その振る舞いは未定義です。</p>
<p>全てのファイルオブジェクトが seek できるとは限らないので注意してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>オフセットに浮動小数点数を渡すことは非推奨となりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.tell">
<code class="descclassname">file.</code><code class="descname">tell</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#file.tell" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C の <code class="docutils literal"><span class="pre">stdio</span></code> の <code class="xref c c-func docutils literal"><span class="pre">ftell()</span></code> のように、ファイルの現在位置を返します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Windows では、(<code class="xref c c-func docutils literal"><span class="pre">fgets()</span></code> の後で) Unix スタイルの改行のファイルを読むときに <a class="reference internal" href="#file.tell" title="file.tell"><code class="xref py py-meth docutils literal"><span class="pre">tell()</span></code></a> が不正な値を返すことがあります。この問題に遭遇しないためにはバイナリーモード (<code class="docutils literal"><span class="pre">'rb'</span></code>) を使うようにしてください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.truncate">
<code class="descclassname">file.</code><code class="descname">truncate</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#file.truncate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルのサイズを切り詰めます。オプションの <em>size</em> が存在すれば、ファイルは (最大で) 指定されたサイズに切り詰められます。標準設定のサイズの値は、現在のファイル位置までのファイルサイズです。現在のファイル位置は変更されません。指定されたサイズがファイルの現在のサイズを越える場合、その結果はプラットフォーム依存なので注意してください: 可能性としては、ファイルは変更されないか、指定されたサイズまでゼロで埋められるか、指定されたサイズまで未定義の新たな内容で埋められるか、があります。利用可能な環境: Windows, 多くの Unix 系。</p>
</dd></dl>

<dl class="method">
<dt id="file.write">
<code class="descclassname">file.</code><code class="descname">write</code><span class="sig-paren">(</span><em>str</em><span class="sig-paren">)</span><a class="headerlink" href="#file.write" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列をファイルに書き込みます。戻り値はありません。バッファリングによって、 <a class="reference internal" href="#file.flush" title="file.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a> または <a class="reference internal" href="#file.close" title="file.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> が呼び出されるまで実際にファイル中に文字列が書き込まれないこともあります。</p>
</dd></dl>

<dl class="method">
<dt id="file.writelines">
<code class="descclassname">file.</code><code class="descname">writelines</code><span class="sig-paren">(</span><em>sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#file.writelines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列からなるシーケンスをファイルに書き込みます。シーケンスは文字列を生成する反復可能なオブジェクトなら何でもかまいません。よくあるのは文字列からなるリストです。戻り値はありません。 (関数の名前は <a class="reference internal" href="#file.readlines" title="file.readlines"><code class="xref py py-meth docutils literal"><span class="pre">readlines()</span></code></a> と対応づけてつけられました; <a class="reference internal" href="#file.writelines" title="file.writelines"><code class="xref py py-meth docutils literal"><span class="pre">writelines()</span></code></a> は行間の区切りを追加しません。)</p>
</dd></dl>

<p>ファイルはイテレータプロトコルをサポートします。各反復操作では <a class="reference internal" href="#file.readline" title="file.readline"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a> と同じ結果を返し、反復は <a class="reference internal" href="#file.readline" title="file.readline"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a> メソッドが空文字列を返した際に終了します。</p>
<p>ファイルオブジェクトはまた、多くの興味深い属性を提供します。これらはファイル類似オブジェクトでは必要ではありませんが、特定のオブジェクトにとって意味を持たせたいなら実装しなければなりません。</p>
<dl class="attribute">
<dt id="file.closed">
<code class="descclassname">file.</code><code class="descname">closed</code><a class="headerlink" href="#file.closed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のファイルオブジェクトの状態を示すブール値です。この値は読み出し専用の属性です; <a class="reference internal" href="#file.close" title="file.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> メソッドがこの値を変更します。全てのファイル類似オブジェクトで利用可能とは限りません。</p>
</dd></dl>

<dl class="attribute">
<dt id="file.encoding">
<code class="descclassname">file.</code><code class="descname">encoding</code><a class="headerlink" href="#file.encoding" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このファイルが使っているエンコーディングです。 Unicode 文字列がファイルに書き込まれる際、 Unicode 文字列はこのエンコーディングを使ってバイト文字列に変換されます。さらに、ファイルが端末に接続されている場合、この属性は端末が使っているとおぼしきエンコーディング (この情報は端末がうまく設定されていない場合には不正確なこともあります) を与えます。この属性は読み出し専用で、すべてのファイル類似オブジェクトにあるとは限りません。またこの値は <code class="docutils literal"><span class="pre">None</span></code> のこともあり、この場合、ファイルは Unicode 文字列の変換のためにシステムのデフォルトエンコーディングを使います。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="file.errors">
<code class="descclassname">file.</code><code class="descname">errors</code><a class="headerlink" href="#file.errors" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>エンコーディングに用いられる、 Unicode エラーハンドラです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="file.mode">
<code class="descclassname">file.</code><code class="descname">mode</code><a class="headerlink" href="#file.mode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルの I/O モードです。ファイルが組み込み関数 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> で作成された場合、この値は引数 <em>mode</em> の値になります。この値は読み出し専用の属性で、全てのファイル類似オブジェクトに存在するとは限りません。</p>
</dd></dl>

<dl class="attribute">
<dt id="file.name">
<code class="descclassname">file.</code><code class="descname">name</code><a class="headerlink" href="#file.name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルオブジェクトが <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> を使って生成された場合は、そのファイル名です。そうでなければ、ファイルオブジェクト生成の起源を示す何らかの文字列になり、 <code class="docutils literal"><span class="pre">&lt;...&gt;</span></code> の形式をとります。この値は読み出し専用の属性で、全てのファイル類似オブジェクトに存在するとは限りません。</p>
<span class="target" id="index-36"></span></dd></dl>

<dl class="attribute">
<dt id="file.newlines">
<code class="descclassname">file.</code><code class="descname">newlines</code><a class="headerlink" href="#file.newlines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python が <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> を (デフォルトどおり) 有効にしてビルドされているなら、この読み込み専用属性が存在し、ファイルが universal newlines で開かれたファイルで、ファイルの読み込み中にあった改行の種類を記録します。取り得る値は <code class="docutils literal"><span class="pre">'\r'</span></code>, <code class="docutils literal"><span class="pre">'\n'</span></code>, <code class="docutils literal"><span class="pre">'\r\n'</span></code>, <code class="docutils literal"><span class="pre">None</span></code> (不明であるか、まだ改行を読み込んでいない)、または、複数の改行方式の種類が存在したことを表す、見つかったすべての改行の種類を含むタプルです。 universal newlines で開かれたのでないファイルに対しては、この属性の値は <code class="docutils literal"><span class="pre">None</span></code> になります。</p>
</dd></dl>

<dl class="attribute">
<dt id="file.softspace">
<code class="descclassname">file.</code><code class="descname">softspace</code><a class="headerlink" href="#file.softspace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../reference/simple_stmts.html#print"><code class="xref std std-keyword docutils literal"><span class="pre">print</span></code></a> 文を使った場合、他の値を出力する前にスペース文字を出力する必要があるかどうかを示すブール値です。ファイルオブジェクトをシミュレート仕様とするクラスは書き込み可能な <a class="reference internal" href="#file.softspace" title="file.softspace"><code class="xref py py-attr docutils literal"><span class="pre">softspace</span></code></a> 属性を持たなければならず、この値はゼロに初期化されなければなりません。この値は Python で実装されているほとんどのクラスで自動的に初期化されます (属性へのアクセス手段を上書きするようなオブジェクトでは注意が必要です); C で実装された型では、書き込み可能な <a class="reference internal" href="#file.softspace" title="file.softspace"><code class="xref py py-attr docutils literal"><span class="pre">softspace</span></code></a> 属性を提供しなければなりません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">この属性は <a class="reference internal" href="../reference/simple_stmts.html#print"><code class="xref std std-keyword docutils literal"><span class="pre">print</span></code></a> 文を制御するために用いられるのではなく、 <a class="reference internal" href="../reference/simple_stmts.html#print"><code class="xref std std-keyword docutils literal"><span class="pre">print</span></code></a> の実装にその内部状態を追跡させるためにあります。</p>
</div>
</dd></dl>

</div>
<div class="section" id="memoryview-type">
<span id="typememoryview"></span><h2>5.10. メモリビュー型<a class="headerlink" href="#memoryview-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> オブジェクトは、Python コードが、バッファプロトコルをサポートするオブジェクトの内部データへ、コピーすることなくアクセスすることを可能にします。メモリは通常、単純なバイト列として解釈されます。</p>
<dl class="class">
<dt id="memoryview">
<em class="property">class </em><code class="descname">memoryview</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>obj</em> を参照する <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> を作成します。 <em>obj</em> はバッファプロトコルをサポートしていなければなりません。バッファプロトコルをサポートする組み込みオブジェクトには、 <a class="reference internal" href="functions.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 、 <a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> などがあります (ただし、 <a class="reference internal" href="functions.html#unicode" title="unicode"><code class="xref py py-class docutils literal"><span class="pre">unicode</span></code></a> は違います)。</p>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> には <em>要素</em> の概念があり、それが起源のオブジェクト <em>obj</em> によって扱われる原子的なメモリの単位になります。多くの単純な型、例えば <a class="reference internal" href="functions.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> や <a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> では、要素は単バイトになりますが、他のサードパーティの型では、要素はより大きくなりえます。</p>
<p><code class="docutils literal"><span class="pre">len(view)</span></code> は、メモリビュー <em>view</em> の要素の総数を返します。 <a class="reference internal" href="#memoryview.itemsize" title="memoryview.itemsize"><code class="xref py py-class docutils literal"><span class="pre">itemsize</span></code></a> 属性で一つの要素内のバイト数を取得できます。</p>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> はスライスしてデータを晒すことに対応しています。一つのインデクスを渡すと一つの要素を <a class="reference internal" href="functions.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> オブジェクトとして返します。完全なスライシングは部分ビューになります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;g&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">&lt;memory at 0x77ab28&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">&#39;bce&#39;</span>
</pre></div>
</div>
<p>メモリビューが基にしているオブジェクトがデータの変更に対応していれば、メモリビューはスライス代入に対応します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">readonly</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;z&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;zbcefg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;123&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;z123fg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;spam&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">cannot modify size of memoryview object</span>
</pre></div>
</div>
<p>この通り、メモリビューオブジェクトの長さは変えられません。</p>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> には 2 つのメソッドがあります。</p>
<dl class="method">
<dt id="memoryview.tobytes">
<code class="descname">tobytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tobytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バッファ中のデータをバイト文字列 (クラス <a class="reference internal" href="functions.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> のオブジェクト) として返します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">&#39;abc&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.tolist">
<code class="descname">tolist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tolist" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バッファ中のデータを整数のリストとして返します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">memoryview</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[97, 98, 99]</span>
</pre></div>
</div>
</dd></dl>

<p>読み込み専用の属性もいくつか使えます:</p>
<dl class="attribute">
<dt id="memoryview.format">
<code class="descname">format</code><a class="headerlink" href="#memoryview.format" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ビューのそれぞれの要素に対する、(<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret strings as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> モジュールのスタイルでの) フォーマットを含む文字列です。デフォルトは <code class="docutils literal"><span class="pre">'B'</span></code> で、単純なバイト文字列です。</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.itemsize">
<code class="descname">itemsize</code><a class="headerlink" href="#memoryview.itemsize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリビューのそれぞれの要素のバイト数です。</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.shape">
<code class="descname">shape</code><a class="headerlink" href="#memoryview.shape" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリの形状を N 次元配列として与える、長さ <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal"><span class="pre">ndim</span></code></a> の整数のタプルです。</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#memoryview.ndim" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリが表す多次元配列が何次元かを示す整数です。</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.strides">
<code class="descname">strides</code><a class="headerlink" href="#memoryview.strides" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>配列のそれぞれの次元に対して、それぞれの要素にアクセスするのに必要なバイト数を表す、長さ <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal"><span class="pre">ndim</span></code></a> の整数のタプルです。</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.readonly">
<code class="descname">readonly</code><a class="headerlink" href="#memoryview.readonly" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリが読み込み専用かを表すブールです。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="context-manager-types">
<span id="typecontextmanager"></span><h2>5.11. コンテキストマネージャ型<a class="headerlink" href="#context-manager-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加.</span></p>
</div>
<p id="index-37">Python の <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文は、コンテキストマネージャによって定義される実行時コンテキストの概念をサポートします。これは、ユーザ定義クラスが文の本体が実行される前に進入し文の終わりで脱出する実行時コンテキストを定義できるようにする一対のメソッドを使って実装されます:</p>
<p><em class="dfn">コンテキスト管理プロトコル</em> (<em class="dfn">context management protocol</em>) は実行時コンテキストを定義するコンテキストマネージャオブジェクトが提供すべき一対のメソッドから成ります:</p>
<dl class="method">
<dt id="contextmanager.__enter__">
<code class="descclassname">contextmanager.</code><code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#contextmanager.__enter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行時コンテキストに入り、このオブジェクトまたは他の実行時コンテキストに関連したオブジェクトを返します。このメソッドが返す値はこのコンテキストマネージャを使う <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の <a class="reference internal" href="../reference/compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> 節の識別子に束縛されます。</p>
<p>自分自身を返すコンテキストマネージャの例としてファイルオブジェクトがあります。ファイルオブジェクトは <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> から自分自身を返して <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> が <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文のコンテキスト式として使われるようにします。</p>
<p>関連オブジェクトを返すコンテキストマネージャの例としては <a class="reference internal" href="decimal.html#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal"><span class="pre">decimal.localcontext()</span></code></a> が返すものがあります。このマネージャはアクティブな10進数コンテキストをオリジナルのコンテキストのコピーにセットしてそのコピーを返します。こうすることで, <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の本体の内部で、外側のコードに影響を与えずに、 10進数コンテキストを変更できます。</p>
</dd></dl>

<dl class="method">
<dt id="contextmanager.__exit__">
<code class="descclassname">contextmanager.</code><code class="descname">__exit__</code><span class="sig-paren">(</span><em>exc_type</em>, <em>exc_val</em>, <em>exc_tb</em><span class="sig-paren">)</span><a class="headerlink" href="#contextmanager.__exit__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行時コンテキストから抜け、例外 (がもし起こっていたとしても) を抑制することを示すブール値フラグを返します。 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の本体を実行中に例外が起こったならば、引数にはその例外の型と値とトレースバック情報を渡します。そうでなければ、引数は全て <code class="docutils literal"><span class="pre">None</span></code> です。</p>
<p>このメソッドから真値が返されると <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文は例外の発生を抑え、 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の直後の文に実行を続けます。そうでなければ、このメソッドの実行を終えると例外の伝播が続きます。このメソッドの実行中に起きた例外は <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の本体の実行中に起こった例外を置き換えてしまいます。</p>
<p>渡された例外を明示的に再送出すべきではありません。その代わりに、このメソッドが偽の値を返すことでメソッドの正常終了と送出された例外を抑制しないことを伝えるべきです。このようにすれば (<code class="docutils literal"><span class="pre">contextlib.nested</span></code> のような) コンテキストマネージャは <a class="reference internal" href="#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッド自体が失敗したのかどうかを簡単に見分けることができます。</p>
</dd></dl>

<p>Python は幾つかのコンテキストマネージャを、易しいスレッド同期・ファイルなどのオブジェクトの即時クローズ・単純化されたアクティブな10進算術コンテキストのサポートのために用意しています。各型はコンテキスト管理プロトコルを実装しているという以上の特別の取り扱いを受けるわけではありません。例については <a class="reference internal" href="contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> モジュールを参照下さい。</p>
<p>Python のジェネレータ (<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>) と <code class="docutils literal"><span class="pre">contextlib.contextmanager</span></code> デコレータ (<a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>) はこのプロトコルの簡便な実装方法を提供します。ジェネレータ関数を <code class="docutils literal"><span class="pre">contextlib.contextmanager</span></code> でデコレートすると、デコレートしなければ返されるイテレータを返す代わりに、必要な <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> および <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドを実装したコンテキストマネージャを返すようになります。</p>
<p>これらのメソッドのために Python/C API の中の Python オブジェクトの型構造体に特別なスロットが作られたわけではないことに注意してください。これらのメソッドを定義したい拡張型はこれらを通常の Python からアクセスできるメソッドとして提供しなければなりません。実行時コンテキストを準備するオーバーヘッドに比べたら、一回のクラス辞書の探索のオーバーヘッドは無視できます。</p>
</div>
<div class="section" id="other-built-in-types">
<span id="typesother"></span><h2>5.12. その他の組み込み型<a class="headerlink" href="#other-built-in-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>インタプリタは、その他いくつかの種類のオブジェクトをサポートします。これらのほとんどは 1 または 2 つの演算だけをサポートします。</p>
<div class="section" id="modules">
<span id="typesmodules"></span><h3>5.12.1. モジュール<a class="headerlink" href="#modules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールに対する唯一の特殊な演算は属性アクセス: <code class="docutils literal"><span class="pre">m.name</span></code> です。ここで <em>m</em> はモジュールで、 <em>name</em> は <em>m</em> のシンボルテーブル上に定義された名前にアクセスします。モジュール属性に代入することもできます。 (なお、<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文は、厳密にいえば、モジュールオブジェクトに対する演算ではありません; <code class="docutils literal"><span class="pre">import</span> <span class="pre">foo</span></code> は <em>foo</em> と名づけられたモジュールオブジェクトの存在を必要とはせず、<em>foo</em> と名づけられたモジュールの (外部の) <em>定義</em> を必要とします。)</p>
<p>全てのモジュールにある特殊属性が <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> です。これはモジュールのシンボルテーブルを含む辞書です。この辞書を書き換えると実際にモジュールのシンボルテーブルを変更することができますが、<a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> 属性を直接代入することはできません (<code class="docutils literal"><span class="pre">m.__dict__['a']</span> <span class="pre">=</span> <span class="pre">1</span></code> と書いて <code class="docutils literal"><span class="pre">m.a</span></code> を <code class="docutils literal"><span class="pre">1</span></code> に定義することはできますが、<code class="docutils literal"><span class="pre">m.__dict__</span> <span class="pre">=</span> <span class="pre">{}</span></code> と書くことはできません)。 <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> を直接書き換えることは推奨されません。</p>
<p>インタプリタ内に組み込まれたモジュールは、 <code class="docutils literal"><span class="pre">&lt;module</span> <span class="pre">'sys'</span> <span class="pre">(built-in)&gt;</span></code> のように書かれます。ファイルから読み出された場合、 <code class="docutils literal"><span class="pre">&lt;module</span> <span class="pre">'os'</span> <span class="pre">from</span> <span class="pre">'/usr/local/lib/pythonX.Y/os.pyc'&gt;</span></code> と書かれます。</p>
</div>
<div class="section" id="classes-and-class-instances">
<span id="typesobjects"></span><h3>5.12.2. クラスおよびクラスインスタンス<a class="headerlink" href="#classes-and-class-instances" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらについては <a class="reference internal" href="../reference/datamodel.html#objects"><span class="std std-ref">オブジェクト、値、および型</span></a> および <a class="reference internal" href="../reference/compound_stmts.html#class"><span class="std std-ref">クラス定義</span></a> を参照下さい。</p>
</div>
<div class="section" id="functions">
<span id="typesfunctions"></span><h3>5.12.3. 関数<a class="headerlink" href="#functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>関数オブジェクトは関数定義によって生成されます。関数オブジェクトに対する唯一の操作は、それを呼び出すことです: <code class="docutils literal"><span class="pre">func(argument-list)</span></code> 。</p>
<p>関数オブジェクトには実際には二種類あります: 組み込み関数とユーザ定義関数です。どちらも同じ操作 (関数の呼び出し) をサポートしますが、実装は異なるので、オブジェクトの型も異なります。</p>
<p>詳細は、 <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> を参照下さい。</p>
</div>
<div class="section" id="methods">
<span id="typesmethods"></span><h3>5.12.4. メソッド<a class="headerlink" href="#methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-38">メソッドは属性表記を使って呼び出される関数です。メソッドには二種類あります: (リストの <code class="xref py py-meth docutils literal"><span class="pre">append()</span></code> のような) 組み込みメソッドと、クラスインスタンスのメソッドです。組み込みメソッドは、それをサポートする型と一緒に記述されています。</p>
<p>実装では、クラスインスタンスのメソッドに 2 つの読み込み専用の属性を追加しています: <code class="docutils literal"><span class="pre">m.im_self</span></code> はメソッドが操作するオブジェクトで、 <code class="docutils literal"><span class="pre">m.im_func</span></code> はメソッドを実装している関数です。 <code class="docutils literal"><span class="pre">m(arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span> <span class="pre">arg-n)</span></code> の呼び出しは、 <code class="docutils literal"><span class="pre">m.im_func(m.im_self,</span> <span class="pre">arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span> <span class="pre">arg-n)</span></code> の呼び出しと完全に等価です。</p>
<p>クラスインスタンスメソッドには、メソッドがインスタンスからアクセスされるかクラスからアクセスされるかによって、それぞれ <em>バインド</em> (束縛) または <em>非バインド</em> (非束縛) があります。メソッドが非バインドメソッドの場合、 <code class="docutils literal"><span class="pre">im_self</span></code> 属性は <code class="docutils literal"><span class="pre">None</span></code> になるため、呼び出す際には <code class="docutils literal"><span class="pre">self</span></code> オブジェクトを明示的に第一引数として指定しなければなりません。この場合、 <code class="docutils literal"><span class="pre">self</span></code> は非バインドメソッドのクラス (またはそのサブクラス) のインスタンスでなければならず、そうでなければ <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出されます。</p>
<p>関数オブジェクトと同じく、メソッドオブジェクトは任意の属性を取得できます。しかし、メソッド属性は実際には背後の関数オブジェクト (<code class="docutils literal"><span class="pre">meth.im_func</span></code>) に記憶されているので、バインドメソッド、非バインドメソッドへのメソッド属性の設定は許されていません。メソッドへの属性の設定を試みると <a class="reference internal" href="exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> が送出されます。メソッド属性を設定するためには、その背後の関数オブジェクトで明示的にセットする必要があります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">&#39;my name is method&#39;</span>  <span class="c1"># can&#39;t set on the method</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;instancemethod&#39; object has no attribute &#39;whoami&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">im_func</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">&#39;my name is method&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span>
<span class="go">&#39;my name is method&#39;</span>
</pre></div>
</div>
<p>詳細は、 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> を参照下さい。</p>
</div>
<div class="section" id="code-objects">
<span id="bltin-code-objects"></span><span id="index-39"></span><h3>5.12.5. コードオブジェクト<a class="headerlink" href="#code-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-40">コードオブジェクトは、関数本体のような &quot;擬似コンパイルされた&quot; Python の実行可能コードを表すために実装系によって使われます。コードオブジェクトはグローバルな実行環境への参照を持たない点で関数オブジェクトとは異なります。コードオブジェクトは組み込み関数 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a> によって返され、また関数オブジェクトの <code class="xref py py-attr docutils literal"><span class="pre">func_code</span></code> 属性として取り出せます。 <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal"><span class="pre">code</span></code></a> モジュールも参照下さい。</p>
<p id="index-41">コードオブジェクトは、 <code class="xref py py-func docutils literal"><span class="pre">exec()</span></code> 文や組み込み関数 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> に (ソース文字列の代わりに) 渡すことで、実行や評価できます。</p>
<p>詳細は、 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> を参照下さい。</p>
</div>
<div class="section" id="type-objects">
<span id="bltin-type-objects"></span><h3>5.12.6. 型オブジェクト<a class="headerlink" href="#type-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-42">型オブジェクトは様々なオブジェクト型を表します。オブジェクトの型は組み込み関数 <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a> でアクセスされます。型オブジェクトには特有の操作はありません。標準モジュール <a class="reference internal" href="types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal"><span class="pre">types</span></code></a> には全ての組み込み型名が定義されています。</p>
<p>型はこのように書き表されます: <code class="docutils literal"><span class="pre">&lt;type</span> <span class="pre">'int'&gt;</span></code> 。</p>
</div>
<div class="section" id="the-null-object">
<span id="bltin-null-object"></span><h3>5.12.7. ヌルオブジェクト<a class="headerlink" href="#the-null-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このオブジェクトは明示的に値を返さない関数によって返されます。このオブジェクトには特有の操作はありません。ヌルオブジェクトは一つだけで、 <code class="docutils literal"><span class="pre">None</span></code> (組み込み名) と名づけられています。</p>
<p><code class="docutils literal"><span class="pre">None</span></code> と書き表されます。</p>
</div>
<div class="section" id="the-ellipsis-object">
<span id="bltin-ellipsis-object"></span><h3>5.12.8. Ellipsis オブジェクト<a class="headerlink" href="#the-ellipsis-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このオブジェクトは拡張スライス表記によって使われます (<a class="reference internal" href="../reference/expressions.html#slicings"><span class="std std-ref">スライス表記 (slicing)</span></a> を参照下さい)。特殊な操作は何もサポートしていません。省略表記オブジェクトは一つだけで、その名前は <a class="reference internal" href="constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal"><span class="pre">Ellipsis</span></code></a> (組み込み名) です。</p>
<p><code class="docutils literal"><span class="pre">Ellipsis</span></code> と書き表されます。添え字として使う場合 <code class="docutils literal"><span class="pre">...</span></code> とも書けます。例えば <code class="docutils literal"><span class="pre">seq[...]</span></code> のように。</p>
</div>
<div class="section" id="the-notimplemented-object">
<h3>5.12.9. NotImplemented オブジェクト<a class="headerlink" href="#the-notimplemented-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このオブジェクトは、対応していない型の演算を求められたとき、比較や二項演算から返されます。詳細は <a class="reference internal" href="../reference/expressions.html#comparisons"><span class="std std-ref">比較</span></a> を参照してください。</p>
<p><code class="docutils literal"><span class="pre">NotImplemented</span></code> と書き表されます。</p>
</div>
<div class="section" id="boolean-values">
<h3>5.12.10. ブール値<a class="headerlink" href="#boolean-values" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ブール値は二つの定数オブジェクト <code class="docutils literal"><span class="pre">False</span></code> および <code class="docutils literal"><span class="pre">True</span></code> です。これらは真理値を表すのに使われます (ただし他の値も偽や真とみなされます)。 数値処理のコンテキスト (例えば算術演算子の引数として使われた場合) では、これらはそれぞれ 0 および 1 と同様に振舞います。任意の値に対して、真理値と解釈できる場合、組み込み関数 <a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-func docutils literal"><span class="pre">bool()</span></code></a> は値をブール値に変換するのに使われます (上述の <a class="reference internal" href="#truth"><span class="std std-ref">真理値判定</span></a> の節を参照してください)。</p>
<p id="index-43">それぞれ <code class="docutils literal"><span class="pre">False</span></code> および <code class="docutils literal"><span class="pre">True</span></code> と書き表されます。</p>
</div>
<div class="section" id="internal-objects">
<span id="typesinternal"></span><h3>5.12.11. 内部オブジェクト<a class="headerlink" href="#internal-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この情報は <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> を参照下さい。スタックフレームオブジェクト、トレースバックオブジェクト、スライスオブジェクトについて記述されています。</p>
</div>
</div>
<div class="section" id="special-attributes">
<span id="specialattrs"></span><h2>5.13. 特殊属性<a class="headerlink" href="#special-attributes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>実装は、いくつかのオブジェクト型に対して、適切な場合には特殊な読み出し専用の属性を追加します。そのうちいくつかは <a class="reference internal" href="functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> 組込み関数で報告されません。</p>
<dl class="attribute">
<dt id="object.__dict__">
<code class="descclassname">object.</code><code class="descname">__dict__</code><a class="headerlink" href="#object.__dict__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトの (書き込み可能な) 属性を保存するために使われる辞書またはその他のマッピングオブジェクトです。</p>
</dd></dl>

<dl class="attribute">
<dt id="object.__methods__">
<code class="descclassname">object.</code><code class="descname">__methods__</code><a class="headerlink" href="#object.__methods__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">バージョン 2.2 で撤廃: </span>オブジェクトの属性からなるリストを取得するには、組み込み関数 <a class="reference internal" href="functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> を使ってください。この属性はもう利用できません。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="object.__members__">
<code class="descclassname">object.</code><code class="descname">__members__</code><a class="headerlink" href="#object.__members__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">バージョン 2.2 で撤廃: </span>オブジェクトの属性からなるリストを取得するには、組み込み関数 <a class="reference internal" href="functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> を使ってください。この属性はもう利用できません。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="instance.__class__">
<code class="descclassname">instance.</code><code class="descname">__class__</code><a class="headerlink" href="#instance.__class__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラスインスタンスが属しているクラスです。</p>
</dd></dl>

<dl class="attribute">
<dt id="class.__bases__">
<code class="descclassname">class.</code><code class="descname">__bases__</code><a class="headerlink" href="#class.__bases__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラスオブジェクトの基底クラスのタプルです。</p>
</dd></dl>

<dl class="attribute">
<dt id="definition.__name__">
<code class="descclassname">definition.</code><code class="descname">__name__</code><a class="headerlink" href="#definition.__name__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラス、型、関数、メソッド、デスクリプタ、ジェネレータインスタンスの名前です。</p>
</dd></dl>

<p>以下の属性は、新スタイルクラス (<a class="reference internal" href="../glossary.html#term-new-style-class"><span class="xref std std-term">new-style class</span></a>) でのみサポートされます。</p>
<dl class="attribute">
<dt id="class.__mro__">
<code class="descclassname">class.</code><code class="descname">__mro__</code><a class="headerlink" href="#class.__mro__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性はメソッドの解決時に基底クラスを探索するときに考慮されるクラスのタプルです。</p>
</dd></dl>

<dl class="method">
<dt id="class.mro">
<code class="descclassname">class.</code><code class="descname">mro</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#class.mro" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、メタクラスによって、そのインスタンスのメソッド解決の順序をカスタマイズするために、上書きされるかも知れません。このメソッドはクラスのインスタンス化時に呼ばれ、その結果は <a class="reference internal" href="#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal"><span class="pre">__mro__</span></code></a> に格納されます。</p>
</dd></dl>

<dl class="method">
<dt id="class.__subclasses__">
<code class="descclassname">class.</code><code class="descname">__subclasses__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasses__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>それぞれの新スタイルクラスは、それ自身の直接のサブクラスへの弱参照を保持します。このメソッドはそれらの参照のうち、生存しているもののリストを返します。例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>
<span class="go">[&lt;type &#39;bool&#39;&gt;]</span>
</pre></div>
</div>
</dd></dl>

<p class="rubric">注記</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>これらの特殊なメソッドのさらなる情報は、 Python リファレンスマニュアル (<a class="reference internal" href="../reference/datamodel.html#customization"><span class="std std-ref">基本的なカスタマイズ</span></a>) を参照下さい。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>この結果として、リスト <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2]</span></code> は <code class="docutils literal"><span class="pre">[1.0,</span> <span class="pre">2.0]</span></code> と等しいと見なされます。タプルの場合も同様です。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>パーザが演算対象の型を識別できるようにするために、このような優先順位でなければならないのです。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id7">2</a>, <a class="fn-backref" href="#id8">3</a>, <a class="fn-backref" href="#id9">4</a>)</em> 大小文字の区別のある文字とは、一般カテゴリプロパティが &quot;Lu&quot; (Letter, uppercase (大文字))、 &quot;Ll&quot; (Letter, lowercase (小文字))、 &quot;Lt&quot; (Letter、titlecase (先頭が大文字)) のいずれかであるものです。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[5]</a></td><td>従って、一個のタプルだけをフォーマット出力したい場合には出力したいタプルを唯一の要素とする単一のタプルを <em>values</em> に与えなくてはなりません。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[6]</a></td><td>改行を残す利点は、空の文字列が返ると EOF を示し、紛らわしくなくなるからです。また、ファイルの最後の行が改行で終わっているかそうでない (ありえることです!) か (例えば、ファイルを行単位で読みながらその完全なコピーを作成した場合には問題になります) を調べることができます。</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. 組み込み型</a><ul>
<li><a class="reference internal" href="#truth-value-testing">5.1. 真理値判定</a></li>
<li><a class="reference internal" href="#boolean-operations-and-or-not">5.2. ブール演算 — <code class="docutils literal"><span class="pre">and</span></code>, <code class="docutils literal"><span class="pre">or</span></code>, <code class="docutils literal"><span class="pre">not</span></code></a></li>
<li><a class="reference internal" href="#comparisons">5.3. 比較</a></li>
<li><a class="reference internal" href="#numeric-types-int-float-long-complex">5.4. 数値型 <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">float</span></code>, <code class="docutils literal"><span class="pre">long</span></code>, <code class="docutils literal"><span class="pre">complex</span></code></a><ul>
<li><a class="reference internal" href="#bitwise-operations-on-integer-types">5.4.1. 整数型におけるビット単位演算</a></li>
<li><a class="reference internal" href="#additional-methods-on-integer-types">5.4.2. 整数型における追加のメソッド</a></li>
<li><a class="reference internal" href="#additional-methods-on-float">5.4.3. 浮動小数点数に対する追加のメソッド</a></li>
</ul>
</li>
<li><a class="reference internal" href="#iterator-types">5.5. イテレータ型</a><ul>
<li><a class="reference internal" href="#generator-types">5.5.1. ジェネレータ型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange">5.6. シーケンス型 — <code class="docutils literal"><span class="pre">str</span></code>, <code class="docutils literal"><span class="pre">unicode</span></code>, <code class="docutils literal"><span class="pre">list</span></code>, <code class="docutils literal"><span class="pre">tuple</span></code>, <code class="docutils literal"><span class="pre">bytearray</span></code>, <code class="docutils literal"><span class="pre">buffer</span></code>, <code class="docutils literal"><span class="pre">xrange</span></code></a><ul>
<li><a class="reference internal" href="#string-methods">5.6.1. 文字列メソッド</a></li>
<li><a class="reference internal" href="#string-formatting-operations">5.6.2. 文字列フォーマット操作</a></li>
<li><a class="reference internal" href="#xrange-type">5.6.3. XRange 型</a></li>
<li><a class="reference internal" href="#mutable-sequence-types">5.6.4. ミュータブルなシーケンス型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-types-set-frozenset">5.7. set（集合）型 — <code class="docutils literal"><span class="pre">set</span></code>, <code class="docutils literal"><span class="pre">frozenset</span></code></a></li>
<li><a class="reference internal" href="#mapping-types-dict">5.8. マッピング型 — <code class="docutils literal"><span class="pre">dict</span></code></a><ul>
<li><a class="reference internal" href="#dictionary-view-objects">5.8.1. 辞書ビューオブジェクト</a></li>
</ul>
</li>
<li><a class="reference internal" href="#file-objects">5.9. ファイルオブジェクト</a></li>
<li><a class="reference internal" href="#memoryview-type">5.10. メモリビュー型</a></li>
<li><a class="reference internal" href="#context-manager-types">5.11. コンテキストマネージャ型</a></li>
<li><a class="reference internal" href="#other-built-in-types">5.12. その他の組み込み型</a><ul>
<li><a class="reference internal" href="#modules">5.12.1. モジュール</a></li>
<li><a class="reference internal" href="#classes-and-class-instances">5.12.2. クラスおよびクラスインスタンス</a></li>
<li><a class="reference internal" href="#functions">5.12.3. 関数</a></li>
<li><a class="reference internal" href="#methods">5.12.4. メソッド</a></li>
<li><a class="reference internal" href="#code-objects">5.12.5. コードオブジェクト</a></li>
<li><a class="reference internal" href="#type-objects">5.12.6. 型オブジェクト</a></li>
<li><a class="reference internal" href="#the-null-object">5.12.7. ヌルオブジェクト</a></li>
<li><a class="reference internal" href="#the-ellipsis-object">5.12.8. Ellipsis オブジェクト</a></li>
<li><a class="reference internal" href="#the-notimplemented-object">5.12.9. NotImplemented オブジェクト</a></li>
<li><a class="reference internal" href="#boolean-values">5.12.10. ブール値</a></li>
<li><a class="reference internal" href="#internal-objects">5.12.11. 内部オブジェクト</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-attributes">5.13. 特殊属性</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="constants.html"
                        title="前の章へ">4. 組み込み定数</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="exceptions.html"
                        title="次の章へ">6. 組み込み例外</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">バグ報告</a></li>
  <li><a href="https://github.com/python/cpython/blob/2.7/Doc/library/stdtypes.rst"
         rel="nofollow">ソースの表示</a>
  </li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="exceptions.html" title="6. 組み込み例外"
             >次へ</a> |</li>
        <li class="right" >
          <a href="constants.html" title="4. 組み込み定数"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.14</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2018, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト).
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 2018-04-18
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>