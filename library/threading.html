<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>16.2. threading — 高水準のスレッドインタフェース &#8212; Python 2.7.13 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.13',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7.13 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 2.7.13 ドキュメント" href="../contents.html" />
    <link rel="up" title="16. オプションのオペレーティングシステムサービス" href="someos.html" />
    <link rel="next" title="16.3. thread — マルチスレッドのコントロール" href="thread.html" />
    <link rel="prev" title="16.1. select — I/O 処理の完了を待機する" href="select.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/threading.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="thread.html" title="16.3. thread — マルチスレッドのコントロール"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="select.html" title="16.1. select — I/O 処理の完了を待機する"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.13</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="someos.html" accesskey="U">16. オプションのオペレーティングシステムサービス</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-threading">
<span id="threading-higher-level-threading-interface"></span><h1>16.2. <a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> &#8212; 高水準のスレッドインタフェース<a class="headerlink" href="#module-threading" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/2.7/Lib/threading.py">Lib/threading.py</a></p>
<hr class="docutils" />
<p>このモジュールでは、高水準のスレッドインタフェースをより低水準な <a class="reference internal" href="thread.html#module-thread" title="thread: Create multiple threads of control within one interpreter."><code class="xref py py-mod docutils literal"><span class="pre">thread</span></code></a> モジュールの上に構築しています。 <a class="reference internal" href="mutex.html#module-mutex" title="mutex: Lock and queue for mutual exclusion. (撤廃)"><code class="xref py py-mod docutils literal"><span class="pre">mutex</span></code></a> と <a class="reference internal" href="queue.html#module-Queue" title="Queue: A synchronized queue class."><code class="xref py py-mod docutils literal"><span class="pre">Queue</span></code></a> モジュールのドキュメントも参照下さい。</p>
<p>また、 <a class="reference internal" href="thread.html#module-thread" title="thread: Create multiple threads of control within one interpreter."><code class="xref py py-mod docutils literal"><span class="pre">thread</span></code></a> がないために <a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> を使えないような状況向けに <a class="reference internal" href="dummy_threading.html#module-dummy_threading" title="dummy_threading: Drop-in replacement for the threading module."><code class="xref py py-mod docutils literal"><span class="pre">dummy_threading</span></code></a> を提供しています。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Python 2.6 からこのモジュールは Java のスレッディング API の影響を受けた <code class="docutils literal"><span class="pre">camelCase</span></code> のプロパティを置き換える <span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a> に準拠したエイリアスを提供します。この更新された API は <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based &quot;threading&quot; interface."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> モジュールのものと互換です。しかしながら、 <code class="docutils literal"><span class="pre">camelCase</span></code> の名称の廃止の予定は決まっておらず、 Python 2.x と 3.x の両方でサポートされ続けます。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Python 2.5 から, 幾つかの Thread のメソッドは間違った呼び出しに対して <a class="reference internal" href="exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code></a> の代わりに <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を返します。</p>
</div>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> CPython は <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">Global Interpreter Lock</span></a> のため、ある時点で Python コードを実行できるスレッドは1つに限られます (ただし、いくつかのパフォーマンスが強く求められるライブラリはこの制限を克服しています)。アプリケーションにマルチコアマシンの計算能力をより良く利用させたい場合は、 <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based &quot;threading&quot; interface."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> モジュールの利用をお勧めします。 ただし、I/Oバウンドなタスクを並行して複数走らせたい場合においては、 マルチスレッドは正しい選択肢です。</p>
</div>
<p>このモジュールでは以下のような関数とオブジェクトを定義しています:</p>
<dl class="function">
<dt id="threading.active_count">
<code class="descclassname">threading.</code><code class="descname">active_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.active_count" title="この定義へのパーマリンク">¶</a></dt>
<dt id="threading.activeCount">
<code class="descclassname">threading.</code><code class="descname">activeCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.activeCount" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>生存中の <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">Thread</span></code></a> オブジェクトの数を返します。この数は <a class="reference internal" href="#threading.enumerate" title="threading.enumerate"><code class="xref py py-func docutils literal"><span class="pre">enumerate()</span></code></a> の返すリストの長さと同じです。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>新たに <code class="docutils literal"><span class="pre">active_count()</span></code> として使えるようになりました。</p>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">threading.</code><code class="descname">Condition</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>新しい条件変数 (condition variable) オブジェクトを返すファクトリ関数です。条件変数を使うと、ある複数のスレッドを別のスレッドの通知があるまで待機させられます。</p>
<p><a class="reference internal" href="#condition-objects"><span class="std std-ref">Condition オブジェクト</span></a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="threading.current_thread">
<code class="descclassname">threading.</code><code class="descname">current_thread</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.current_thread" title="この定義へのパーマリンク">¶</a></dt>
<dt id="threading.currentThread">
<code class="descclassname">threading.</code><code class="descname">currentThread</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.currentThread" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>関数を呼び出している処理のスレッドに対応する <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">Thread</span></code></a> オブジェクトを返します。関数を呼び出している処理のスレッドが <a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールで生成したものでない場合、限定的な機能しかもたないダミースレッドオブジェクトを返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>新たに <code class="docutils literal"><span class="pre">current_thread()</span></code> として使えるようになりました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="threading.enumerate">
<code class="descclassname">threading.</code><code class="descname">enumerate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.enumerate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在、生存中の <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">Thread</span></code></a> オブジェクト全てのリストを返します。リストには、デーモンスレッド (daemonic thread)、 <a class="reference internal" href="#threading.current_thread" title="threading.current_thread"><code class="xref py py-func docutils literal"><span class="pre">current_thread()</span></code></a> の生成するダミースレッドオブジェクト、そして主スレッドが入ります。終了したスレッドとまだ開始していないスレッドは入りません。</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">threading.</code><code class="descname">Event</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>新たなイベントオブジェクトを返すファクトリ関数です。イベントは <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code class="xref py py-meth docutils literal"><span class="pre">set()</span></code></a> メソッドを使うと <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> に、 <code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code> メソッドを使うと <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> にセットされるようなフラグを管理します。 <code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code> メソッドは、全てのフラグが真になるまでブロックするようになっています。</p>
<p><a class="reference internal" href="#event-objects"><span class="std std-ref">Event オブジェクト</span></a> を参照してください。</p>
</dd></dl>

<dl class="class">
<dt id="threading.local">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">local</code><a class="headerlink" href="#threading.local" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッドローカルデータ (thread-local data) を表現するためのクラスです。スレッドローカルデータとは、値が各スレッド固有になるようなデータです。スレッドローカルデータを管理するには、 <a class="reference internal" href="#threading.local" title="threading.local"><code class="xref py py-class docutils literal"><span class="pre">local</span></code></a> (または <a class="reference internal" href="#threading.local" title="threading.local"><code class="xref py py-class docutils literal"><span class="pre">local</span></code></a> のサブクラス) のインスタンスを作成して、その属性に値を代入します</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mydata</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>
<span class="n">mydata</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>インスタンスの値はスレッドごとに違った値になります。</p>
<p>詳細と例題については、 <code class="xref py py-mod docutils literal"><span class="pre">_threading_local</span></code> モジュールのドキュメンテーション文字列を参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="threading.Lock">
<code class="descclassname">threading.</code><code class="descname">Lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Lock" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しいプリミティブロック (primitive lock) オブジェクトを返すファクトリ関数です。スレッドが一度プリミティブロックを獲得すると、それ以後のロック獲得の試みはロックが解放されるまでブロックします。どのスレッドでもロックを解放できます。</p>
<p><a class="reference internal" href="#lock-objects"><span class="std std-ref">Lock オブジェクト</span></a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="threading.RLock">
<code class="descclassname">threading.</code><code class="descname">RLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.RLock" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しい再入可能ロックオブジェクトを返すファクトリ関数です。再入可能ロックはそれを獲得したスレッドによって解放されなければなりません。いったんスレッドが再入可能ロックを獲得すると、同じスレッドはブロックされずにもう一度それを獲得できます ; そのスレッドは獲得した回数だけ解放しなければいけません。</p>
<p><a class="reference internal" href="#rlock-objects"><span class="std std-ref">RLock オブジェクト</span></a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">threading.</code><code class="descname">Semaphore</code><span class="sig-paren">(</span><span class="optional">[</span><em>value</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>新しいセマフォ (semaphore) オブジェクトを返すファクトリ関数です。セマフォは、 <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> を呼び出した数から <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> を呼び出した数を引き、初期値を足した値を表すカウンタを管理します。 <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> メソッドは、カウンタの値を負にせずに処理を戻せるまで必要ならば処理をブロックします。 <em>value</em> を指定しない場合、デフォルトの値は 1 になります。</p>
<p><a class="reference internal" href="#semaphore-objects"><span class="std std-ref">Semaphore オブジェクト</span></a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="threading.BoundedSemaphore">
<code class="descclassname">threading.</code><code class="descname">BoundedSemaphore</code><span class="sig-paren">(</span><span class="optional">[</span><em>value</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.BoundedSemaphore" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しい有限セマフォ (bounded semaphore) オブジェクトを返すファクトリ関数です。有限セマフォは、現在の値が初期値を超過しないようチェックを行います。超過を起こした場合、 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。たいていの場合、セマフォは限られた容量のリソースを保護するために使われるものです。従って、あまりにも頻繁なセマフォの解放はバグが生じているしるしです。 <em>value</em> を指定しない場合、デフォルトの値は 1 になります。</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Thread</code></dt>
<dd><p>処理中のスレッドを表すクラスです。このクラスは制限のある範囲内で安全にサブクラス化できます。</p>
<p><a class="reference internal" href="#thread-objects"><span class="std std-ref">Thread オブジェクト</span></a> を参照してください。</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Timer</code></dt>
<dd><p>指定時間経過後に関数を実行するスレッドです。</p>
<p><a class="reference internal" href="#timer-objects"><span class="std std-ref">Timer オブジェクト</span></a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="threading.settrace">
<code class="descclassname">threading.</code><code class="descname">settrace</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.settrace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-1"><a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールを使って開始した全てのスレッドにトレース関数を設定します。 <em>func</em> は各スレッドの <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> を呼び出す前にスレッドの <a class="reference internal" href="sys.html#sys.settrace" title="sys.settrace"><code class="xref py py-func docutils literal"><span class="pre">sys.settrace()</span></code></a> に渡されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="threading.setprofile">
<code class="descclassname">threading.</code><code class="descname">setprofile</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.setprofile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-2"><a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールを使って開始した全てのスレッドにプロファイル関数を設定します。 <em>func</em> は各スレッドの <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> を呼び出す前にスレッドの <a class="reference internal" href="sys.html#sys.setprofile" title="sys.setprofile"><code class="xref py py-func docutils literal"><span class="pre">sys.setprofile()</span></code></a> に渡されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="threading.stack_size">
<code class="descclassname">threading.</code><code class="descname">stack_size</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.stack_size" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しいスレッドを作るときのスレッドスタックサイズを返します。オプションの <em>size</em> 引数は、これ以降に作成するスレッドのスタックサイズを指定するもので、 0 (プラットフォームか設定されたデフォルト値) か、 32,768 (32 KiB) 以上の正の整数である必要があります。 <em>size</em> を指定しない場合、0 が使われます。スレッドのスタックサイズの変更がサポートされていない場合、 <a class="reference internal" href="#threading.ThreadError" title="threading.ThreadError"><code class="xref py py-exc docutils literal"><span class="pre">ThreadError</span></code></a> を発生させます。不正なスタックサイズが指定された場合、 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を発生させて、スタックサイズを変更しません。 32 KiB が現在のインタープリター自体のために十分であると保証された最小のスタックサイズです。いくつかのプラットフォームではスタックサイズに対して制限があることに注意してください。例えば最小のスタックサイズが 32 KiB より大きかったり、システムのメモリページサイズ の整数倍の必要があるなどです。この制限についてはプラットフォームのドキュメントを参照する必要があります。 (一般的なページサイズは 4 KiB なので、プラットフォームに関する情報がない場合は 4096 の整数倍のスタックサイズを選ぶといいかもしれません)。利用可能な環境: Windows, POSIX スレッドに対応したシステム。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="threading.ThreadError">
<em class="property">exception </em><code class="descclassname">threading.</code><code class="descname">ThreadError</code><a class="headerlink" href="#threading.ThreadError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>下記で記述するスレッド関連の様々なエラーで送出されます。多くのインターフェイスが <a class="reference internal" href="#threading.ThreadError" title="threading.ThreadError"><code class="xref py py-exc docutils literal"><span class="pre">ThreadError</span></code></a> ではなく <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を使っていることに注意してください。</p>
</dd></dl>

<p>オブジェクトの詳細なインターフェースを以下に説明します。</p>
<p>このモジュールのおおまかな設計は Java のスレッドモデルに基づいています。とはいえ、 Java がロックと条件変数を全てのオブジェクトの基本的な挙動にしているのに対し、 Python ではこれらを別個のオブジェクトに分けています。 Python の <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">Thread</span></code></a> クラスがサポートしているのは Java の Thread クラスの挙動のサブセットにすぎません; 現状では、優先度 (priority)やスレッドグループがなく、スレッドの破壊 (destroy)、中断 (stop)、一時停止 (suspend)、復帰 (resume)、割り込み (interrupt) は行えません。 Java の Thread クラスにおける静的メソッドに対応する機能が実装されている場合にはモジュールレベルの関数になっています。</p>
<p>以下に説明するメソッドは全て原子的 (atomic) に実行されます。</p>
<div class="section" id="thread-objects">
<span id="id1"></span><h2>16.2.1. Thread オブジェクト<a class="headerlink" href="#thread-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このクラスは個別のスレッド中で実行される活動 (activity) を表現します。活動を決める方法は 2 つあり、一つは呼出し可能オブジェクトをコンストラクタへ渡す方法、もう一つはサブクラスで <code class="xref py py-meth docutils literal"><span class="pre">run()</span></code> メソッドをオーバライドする方法です。 (コンストラクタを除く) その他のメソッドは一切サブクラスでオーバライドしてはなりません。言い換えるならば、このクラスの <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> と <code class="xref py py-meth docutils literal"><span class="pre">run()</span></code> メソッド <em>だけ</em> をオーバライドしてくださいということです。</p>
<p>ひとたびスレッドオブジェクトを生成すると、スレッドの <code class="xref py py-meth docutils literal"><span class="pre">start()</span></code> メソッドを呼び出して活動を開始せねばなりません。 <code class="xref py py-meth docutils literal"><span class="pre">start()</span></code> メソッドはそれぞれのスレッドの <code class="xref py py-meth docutils literal"><span class="pre">run()</span></code> メソッドを起動します。</p>
<p>スレッドの活動が始まると、スレッドは &#8216;生存中 (alive)&#8217; とみなされます。スレッドは通常 <code class="xref py py-meth docutils literal"><span class="pre">run()</span></code> メソッドが終了するまで生存中となります。もしくは、捕捉されない例外が送出されるまでです。 <code class="xref py py-meth docutils literal"><span class="pre">is_alive()</span></code> メソッドはスレッドが生存中であるかどうか調べます。</p>
<p>他のスレッドはスレッドの <code class="xref py py-meth docutils literal"><span class="pre">join()</span></code> メソッドを呼び出せます。このメソッドは、 <code class="xref py py-meth docutils literal"><span class="pre">join()</span></code> を呼び出されたスレッドが終了するまで、メソッドの呼び出し手となるスレッドをブロックします。</p>
<p>スレッドには名前があります。名前はコンストラクタに渡したり、または、 <code class="xref py py-attr docutils literal"><span class="pre">name</span></code> 属性を通して読み出したり、変更したりできます。</p>
<p>スレッドには &#8220;デーモンスレッド (daemon thread)&#8221; であるというフラグを立てられます。このフラグには、残っているスレッドがデーモンスレッドだけになった時に Python プログラム全体を終了させるという意味があります。フラグの初期値はスレッドを生成する側のスレッドから継承します。フラグの値は <code class="xref py py-attr docutils literal"><span class="pre">daemon</span></code> 属性を通して設定できます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">デーモンスレッドは終了時にいきなり停止されます。デーモンスレッドで使われたリソース (開いているファイル、データベースのトランザクションなど) は適切に解放されないかもしれません。きちんと (gracefully) スレッドを停止したい場合は、スレッドを非デーモンスレッドにして、<a class="reference internal" href="#threading.Event" title="threading.Event"><code class="xref py py-class docutils literal"><span class="pre">Event</span></code></a> のような適切なシグナル送信機構を使用してください。</p>
</div>
<p>スレッドには &#8220;主スレッド (main thread)&#8221; オブジェクトがあります。主スレッドは Python プログラムを最初に制御していたスレッドです。主スレッドはデーモンスレッドではありません。</p>
<p>&#8220;ダミースレッド (dummy thread)&#8221; オブジェクトを作成できる場合があります。ダミースレッドは、 &#8220;外来スレッド (alien thread)&#8221; に相当するスレッドオブジェクトです。ダミースレッドは、C コードから直接生成されたスレッドのような、 <a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールの外で開始された処理スレッドです。ダミースレッドオブジェクトには限られた機能しかなく、常に生存中、かつデーモンスレッドであるとみなされ、 <code class="xref py py-meth docutils literal"><span class="pre">join()</span></code> できません。また、外来スレッドの終了を検出するのは不可能なので、ダミースレッドは削除できません。</p>
<dl class="class">
<dt id="threading.Thread">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Thread</code><span class="sig-paren">(</span><em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンストラクタは常にキーワード引数を使って呼び出さなければなりません。各引数は以下の通りです:</p>
<p><em>group</em> は <code class="docutils literal"><span class="pre">None</span></code> でなければなりません。将来 <code class="xref py py-class docutils literal"><span class="pre">ThreadGroup</span></code> クラスが実装されたときの拡張用に予約されている引数です。</p>
<p><em>target</em> は <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドによって起動される呼び出し可能オブジェクトです。デフォルトでは何も呼び出さないことを示す <code class="docutils literal"><span class="pre">None</span></code> になっています。</p>
<p><em>name</em> はスレッドの名前です。デフォルトでは、 <em>N</em> を小さな 10 進数として、 &#8220;Thread- <em>N</em>&#8221; という形式の一意な名前を生成します。</p>
<p><em>args</em> は <em>target</em> を呼び出すときの引数タプルです。デフォルトは <code class="docutils literal"><span class="pre">()</span></code> です。</p>
<p><em>kwargs</em> は <em>target</em> を呼び出すときのキーワード引数の辞書です。デフォルトは <code class="docutils literal"><span class="pre">{}</span></code> です。</p>
<p>サブクラスでコンストラクタをオーバライドした場合、必ずスレッドが何かを始める前に基底クラスのコンストラクタ (<code class="docutils literal"><span class="pre">Thread.__init__()</span></code>) を呼び出しておかなくてはなりません。</p>
<dl class="method">
<dt id="threading.Thread.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.start" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッドの活動を開始します。</p>
<p>このメソッドは、スレッドオブジェクトあたり一度しか呼び出してはなりません。 <code class="xref py py-meth docutils literal"><span class="pre">start()</span></code> は、オブジェクトの <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドが個別の処理スレッド中で呼び出されるように調整します。</p>
<p>同じスレッドオブジェクトに対し、このメソッドを2回以上呼び出した場合、 <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.run" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッドの活動をもたらすメソッドです。</p>
<p>このメソッドはサブクラスでオーバライドできます。標準の <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドでは、オブジェクトのコンストラクタの <em>target</em> 引数に呼び出し可能オブジェクトを指定した場合、 <em>args</em> および <em>kwargs</em> の引数列およびキーワード引数とともに呼び出します。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.join">
<code class="descname">join</code><span class="sig-paren">(</span><span class="optional">[</span><em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.join" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッドが終了するまで待機します。このメソッドは、 <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> を呼び出されたスレッドが、正常終了あるいは処理されない例外によって終了するか、オプションのタイムアウトが発生するまで、メソッドの呼び出し手となるスレッドをブロックします。</p>
<p><em>timeout</em> 引数を指定して、 <code class="docutils literal"><span class="pre">None</span></code> 以外の値にする場合、タイムアウトを秒 (または端数秒) を表す浮動小数点数でなければなりません。 <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> はいつでも <code class="docutils literal"><span class="pre">None</span></code> を返すので、 <a class="reference internal" href="#threading.Thread.isAlive" title="threading.Thread.isAlive"><code class="xref py py-meth docutils literal"><span class="pre">isAlive()</span></code></a> を呼び出してタイムアウトしたかどうかを確認しなければなりません。もしスレッドがまだ生存中であれば、 <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> はタイムアウトしています。</p>
<p><em>timeout</em> が指定されないかまたは <code class="docutils literal"><span class="pre">None</span></code> であるときは、この操作はスレッドが終了するまでブロックします。</p>
<p>一つのスレッドに対して何度でも <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> できます。</p>
<p>実行中のスレッドに対し、 <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> を呼び出そうとすると、デッドロックを引き起こすため、 <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。スレッドが開始される前に <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> を呼び出そうとしても、同じ例外が送出されます。</p>
</dd></dl>

<dl class="attribute">
<dt id="threading.Thread.name">
<code class="descname">name</code><a class="headerlink" href="#threading.Thread.name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>識別のためにのみ用いられる文字列です。名前には機能上の意味づけ (semantics) はありません。複数のスレッドに同じ名前をつけてもかまいません。名前の初期値はコンストラクタで設定されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.getName">
<code class="descname">getName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.getName" title="この定義へのパーマリンク">¶</a></dt>
<dt id="threading.Thread.setName">
<code class="descname">setName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.setName" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#threading.Thread.name" title="threading.Thread.name"><code class="xref py py-attr docutils literal"><span class="pre">name</span></code></a> の、Python 2.6 以前の API です。</p>
</dd></dl>

<dl class="attribute">
<dt id="threading.Thread.ident">
<code class="descname">ident</code><a class="headerlink" href="#threading.Thread.ident" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>&#8216;スレッド識別子&#8217; 、または、スレッドが開始されていなければ <code class="docutils literal"><span class="pre">None</span></code> です。非ゼロの整数です。 <a class="reference internal" href="thread.html#thread.get_ident" title="thread.get_ident"><code class="xref py py-func docutils literal"><span class="pre">thread.get_ident()</span></code></a> 関数を参照下さい。スレッド識別子は、スレッドが終了した後、新たなスレッドが生成された場合、再利用され得ます。スレッド識別子は、スレッドが終了した後でも利用できます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.is_alive">
<code class="descname">is_alive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.is_alive" title="この定義へのパーマリンク">¶</a></dt>
<dt id="threading.Thread.isAlive">
<code class="descname">isAlive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.isAlive" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッドが生存中かどうかを返します。</p>
<p>このメソッドは <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドが起動した直後からその <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドが終了するまでの間 <code class="docutils literal"><span class="pre">True</span></code> を返します。モジュール関数、 <a class="reference internal" href="#threading.enumerate" title="threading.enumerate"><code class="xref py py-func docutils literal"><span class="pre">enumerate()</span></code></a> は、全ての生存中のスレッドのリストを返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>新たに <code class="docutils literal"><span class="pre">is_alive()</span></code> として使えるようになりました。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="threading.Thread.daemon">
<code class="descname">daemon</code><a class="headerlink" href="#threading.Thread.daemon" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッドのデーモンフラグです。このフラグは <a class="reference internal" href="#threading.Thread.start" title="threading.Thread.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a> の呼び出し前に設定されなければなりません。さもなくば、 <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。初期値は生成側のスレッドから継承されます。メインスレッドはデーモンスレッドではないので、メインスレッドから生成するスレッドはデフォルトで <a class="reference internal" href="#threading.Thread.daemon" title="threading.Thread.daemon"><code class="xref py py-attr docutils literal"><span class="pre">daemon</span></code></a> = <code class="docutils literal"><span class="pre">False</span></code> です。</p>
<p>デーモンでない生存中のスレッドが全てなくなると、 Python プログラム全体が終了します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.isDaemon">
<code class="descname">isDaemon</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.isDaemon" title="この定義へのパーマリンク">¶</a></dt>
<dt id="threading.Thread.setDaemon">
<code class="descname">setDaemon</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.setDaemon" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#threading.Thread.daemon" title="threading.Thread.daemon"><code class="xref py py-attr docutils literal"><span class="pre">daemon</span></code></a> の、Python 2.6 以前の API です。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lock-objects">
<span id="id2"></span><h2>16.2.2. Lock オブジェクト<a class="headerlink" href="#lock-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>プリミティブロックとは、ロックが生じた際に特定のスレッドによって所有されない同期プリミティブです。 Python では現在のところ拡張モジュール <a class="reference internal" href="thread.html#module-thread" title="thread: Create multiple threads of control within one interpreter."><code class="xref py py-mod docutils literal"><span class="pre">thread</span></code></a> で直接実装されている最も低水準の同期プリミティブを使えます。</p>
<p>プリミティブロックは2つの状態、 &#8220;ロック&#8221; または &#8220;アンロック&#8221; があります。このロックはアンロック状態で作成されます。ロックには基本となる二つのメソッド、 <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> があります。ロックの状態がアンロックである場合、 <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> は状態をロックに変更して即座に処理を戻します。状態がロックの場合、 <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> は他のスレッドが <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> を呼出してロックの状態をアンロックに変更するまでブロックします。その後、状態をロックに再度設定してから処理を戻します。 <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> メソッドを呼び出すのはロック状態のときでなければなりません; このメソッドはロックの状態をアンロックに変更し、即座に処理を戻します。アンロックの状態のロックを解放しようとすると <a class="reference internal" href="#threading.ThreadError" title="threading.ThreadError"><code class="xref py py-exc docutils literal"><span class="pre">ThreadError</span></code></a> が送出されます。</p>
<p>複数のスレッドにおいて <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> がアンロック状態への遷移を待っているためにブロックが起きている時に <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> を呼び出してロックの状態をアンロックにすると、一つのスレッドだけが処理を進行できます。どのスレッドが処理を進行できるのかは定義されておらず、実装によって異なるかもしれません。</p>
<p>全てのメソッドはアトミックに実行されます。</p>
<dl class="method">
<dt id="threading.Lock.acquire">
<code class="descclassname">Lock.</code><code class="descname">acquire</code><span class="sig-paren">(</span><span class="optional">[</span><em>blocking</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Lock.acquire" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ブロックあり、またはブロックなしでロックを獲得します。</p>
<p>引数 <em>blocking</em> を <code class="docutils literal"><span class="pre">True</span></code> (デフォルト) に設定して呼び出した場合、ロックがアンロック状態になるまでブロックします。そしてそれをロック状態にしてから <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
<p>引数 <em>blocking</em> の値を <code class="docutils literal"><span class="pre">False</span></code> にして呼び出すとブロックしません。<em>blocking</em> を <code class="docutils literal"><span class="pre">True</span></code> にして呼び出した場合にブロックするような状況では、直ちに <code class="docutils literal"><span class="pre">False</span></code> を返します。それ以外の場合には、ロックをロック状態にして <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Lock.release">
<code class="descclassname">Lock.</code><code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Lock.release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ロックを解放します。</p>
<p>ロックの状態がロックのとき、状態をアンロックにリセットして処理を戻します。他のスレッドがロックがアンロック状態になるのを待ってブロックしている場合、ただ一つのスレッドだけが処理を継続できるようにします。</p>
<p>アンロック状態のロックに対して起動された場合、 <a class="reference internal" href="#threading.ThreadError" title="threading.ThreadError"><code class="xref py py-exc docutils literal"><span class="pre">ThreadError</span></code></a> が送出されます。</p>
<p>戻り値はありません。</p>
</dd></dl>

</div>
<div class="section" id="rlock-objects">
<span id="id3"></span><h2>16.2.3. RLock オブジェクト<a class="headerlink" href="#rlock-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>再入可能ロック (reentrant lock) とは、同じスレッドが複数回獲得できるような同期プリミティブです。再入可能ロックの内部では、プリミティブロックの使うロック／アンロック状態に加え、 &#8220;所有スレッド (owning thread)&#8221; と &#8220;再帰レベル (recursion level)&#8221; という概念を用いています。ロック状態では何らかのスレッドがロックを所有しており、アンロック状態ではいかなるスレッドもロックを所有していません。</p>
<p>スレッドがこのロックの状態をロックにするには、ロックの <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> メソッドを呼び出します。このメソッドは、スレッドがロックを所有すると処理を戻します。ロックの状態をアンロックにするには <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> メソッドを呼び出します。 <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> / <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> からなるペアの呼び出しはネストできます; 最後に呼び出した <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> (最も外側の呼び出しペア) だけが、ロックの状態をアンロックにリセットし、 <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> でブロック中の別のスレッドの処理を進行させられます。</p>
<dl class="method">
<dt id="threading.RLock.acquire">
<code class="descclassname">RLock.</code><code class="descname">acquire</code><span class="sig-paren">(</span><span class="optional">[</span><em>blocking=1</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.RLock.acquire" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ブロックあり、またはブロックなしでロックを獲得します。</p>
<p>引数なしで呼び出した場合: スレッドが既にロックを所有している場合、再帰レベルをインクリメントして即座に処理を戻します。それ以外の場合、他のスレッドがロックを所有していれば、そのロックの状態がアンロックになるまでブロックします。その後、ロックの状態がアンロックになる (いかなるスレッドもロックを所有しない状態になる) と、ロックの所有権を獲得し、再帰レベルを 1 にセットして処理を戻します。ロックの状態がアンロックになるのを待っているスレッドが複数ある場合、その中の一つだけがロックの所有権を獲得できます。この場合、戻り値はありません。</p>
<p>引数 <em>blocking</em> の値を true にして呼び出した場合、引数なしで呼び出したときと同じことを行ない、true を返します。</p>
<p>引数 <em>blocking</em> の値を false にして呼び出すとブロックしません。引数なしで呼び出した場合にブロックするような状況であった場合には直ちに false を返します。それ以外の場合には、引数なしで呼び出したときと同じ処理を行い true を返します。</p>
</dd></dl>

<dl class="method">
<dt id="threading.RLock.release">
<code class="descclassname">RLock.</code><code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.RLock.release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>再帰レベルをデクリメントしてロックを解放します。デクリメント後に再帰レベルがゼロになった場合、ロックの状態をアンロック (いかなるスレッドにも所有されていない状態) にリセットし、ロックの状態がアンロックになるのを待ってブロックしているスレッドがある場合にはその中のただ一つだけが処理を進行できるようにします。デクリメント後も再帰レベルがゼロでない場合、ロックの状態はロックのままで、呼び出し側のスレッドに所有されたままになります。</p>
<p>呼び出し側のスレッドがロックを所有しているときにのみこのメソッドを呼び出してください。ロックの状態がアンロックの時にこのメソッドを呼び出すと、 <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
<p>戻り値はありません。</p>
</dd></dl>

</div>
<div class="section" id="condition-objects">
<span id="id4"></span><h2>16.2.4. Condition オブジェクト<a class="headerlink" href="#condition-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>条件変数 (condition variable) は常にある種のロックに関連付けられています; 条件変数に関連付けるロックは明示的に引き渡したり、デフォルトで生成させたりできます。 (複数の条件変数で同じロックを共有するような場合には、引渡しによる関連付けが便利です。)</p>
<p>条件変数には、 <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> メソッドおよび <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> があり、関連付けされているロックの対応するメソッドを呼び出すようになっています。また、 <code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></code> といったメソッドがあります。これら三つのメソッドを呼び出せるのは、呼び出し手のスレッドがロックを獲得している時だけです。そうでない場合は <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
<p><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code> メソッドは現在のスレッドのロックを解放し、他のスレッドが同じ条件変数に対して <code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code> または <code class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></code> を呼び出して現在のスレッドを起こすまでブロックします。一度起こされると、再度ロックを獲得して処理を戻します。 <code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code> にはタイムアウトも設定できます。</p>
<p><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code> メソッドは条件変数待ちのスレッドを1つ起こします。 <code class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></code> メソッドは条件変数待ちの全てのスレッドを起こします。</p>
<p>注意: <code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></code> はロックを解放しません; 従って、スレッドが起こされたとき、 <code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code> の呼び出しは即座に処理を戻すわけではなく、 <code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code> または <code class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></code> を呼び出したスレッドが最終的にロックの所有権を放棄したときに初めて処理を返すのです。</p>
<p>豆知識: 条件変数を使う典型的なプログラミングスタイルでは、何らかの共有された状態変数へのアクセスを同期させるためにロックを使います; 状態変数が特定の状態に変化したことを知りたいスレッドは、自分の望む状態になるまで繰り返し <code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code> を呼び出します。その一方で、状態変更を行うスレッドは、前者のスレッドが待ち望んでいる状態であるかもしれないような状態へ変更を行ったときに <code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code> や <code class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></code> を呼び出します。例えば、以下のコードは無制限のバッファ容量のときの一般的な生産者-消費者問題です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Consume one item</span>
<span class="n">cv</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="k">while</span> <span class="ow">not</span> <span class="n">an_item_is_available</span><span class="p">():</span>
    <span class="n">cv</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
<span class="n">get_an_available_item</span><span class="p">()</span>
<span class="n">cv</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

<span class="c1"># Produce one item</span>
<span class="n">cv</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="n">make_an_item_available</span><span class="p">()</span>
<span class="n">cv</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>
<span class="n">cv</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></code> のどちらを使うかは、その状態の変化に興味を持っている待ちスレッドが一つだけなのか、あるいは複数なのかで考えます。例えば、典型的な生産者-消費者問題では、バッファに 1 つの要素を加えた場合には消費者スレッドを 1 つしか起こさなくてかまいません。</p>
<dl class="class">
<dt id="threading.Condition">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Condition</code><span class="sig-paren">(</span><span class="optional">[</span><em>lock</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>lock</em> を指定して、 <code class="docutils literal"><span class="pre">None</span></code> の値にする場合、 <a class="reference internal" href="#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal"><span class="pre">Lock</span></code></a> または <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> オブジェクトでなければなりません。この場合、 <em>lock</em> は根底にあるロックオブジェクトとして使われます。それ以外の場合には新しい <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> オブジェクトを生成して使います。</p>
<dl class="method">
<dt id="threading.Condition.acquire">
<code class="descname">acquire</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition.acquire" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>根底にあるロックを獲得します。このメソッドは根底にあるロックの対応するメソッドを呼び出します。そのメソッドの戻り値を返します。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Condition.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition.release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>根底にあるロックを解放します。このメソッドは根底にあるロックの対応するメソッドを呼び出します。戻り値はありません。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Condition.wait">
<code class="descname">wait</code><span class="sig-paren">(</span><span class="optional">[</span><em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition.wait" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>通知 (notify) を受けるか、タイムアウトするまで待機します。呼び出し側のスレッドがロックを獲得していないときにこのメソッドを呼び出すと <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
<p>このメソッドは根底にあるロックを解放し、他のスレッドが同じ条件変数に対して <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> または <a class="reference internal" href="#threading.Condition.notifyAll" title="threading.Condition.notifyAll"><code class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></code></a> を呼び出して現在のスレッドを起こすか、オプションのタイムアウトが発生するまでブロックします。一度スレッドが起こされると、再度ロックを獲得して処理を戻します。</p>
<p><em>timeout</em> 引数を指定して、 <code class="docutils literal"><span class="pre">None</span></code> 以外の値にする場合、タイムアウトを秒 (または端数秒) を表す浮動小数点数でなければなりません。</p>
<p>根底にあるロックが <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> である場合、 <a class="reference internal" href="#threading.Condition.release" title="threading.Condition.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> メソッドではロックは解放されません。というのも、ロックが再帰的に複数回獲得されている場合には、 <a class="reference internal" href="#threading.Condition.release" title="threading.Condition.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> によって実際にアンロックが行われないかもしれないからです。その代わり、ロックが再帰的に複数回獲得されていても確実にアンロックを行える <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> クラスの内部インタフェースを使います。その後ロックを再獲得する時に、もう一つの内部インタフェースを使ってロックの再帰レベルを復帰します。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Condition.notify">
<code class="descname">notify</code><span class="sig-paren">(</span><em>n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition.notify" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デフォルトで、この条件変数を待っている1つのスレッドを起こします。 呼び出し側のスレッドがロックを獲得していないときにこのメソッドを呼び出すと <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
<p>何らかの待機中スレッドがある場合、そのうち <em>n</em> スレッドを起こします。待機中のスレッドがなければ何もしません。</p>
<p>現在の実装では、少なくとも <em>n</em> スレッドが待機中であれば、ちょうど <em>n</em> スレッドを起こします。とはいえ、この挙動に依存するのは安全ではありません。将来、実装の最適化によって、複数のスレッドを起こすようになるかもしれないからです。</p>
<p>注意: 起こされたスレッドは実際にロックを再獲得できるまで <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> 呼び出しから戻りません。 <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> はロックを解放しないので、 <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> 呼び出し側は明示的にロックを解放しなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Condition.notify_all">
<code class="descname">notify_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition.notify_all" title="この定義へのパーマリンク">¶</a></dt>
<dt id="threading.Condition.notifyAll">
<code class="descname">notifyAll</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition.notifyAll" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この条件を待っているすべてのスレッドを起こします。このメソッドは <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> のように動作しますが、 1 つではなくすべての待ちスレッドを起こします。呼び出し側のスレッドがロックを獲得していない場合、 <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>新たに <code class="docutils literal"><span class="pre">notify_all()</span></code> として使えるようになりました。</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="semaphore-objects">
<span id="id5"></span><h2>16.2.5. Semaphore オブジェクト<a class="headerlink" href="#semaphore-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>セマフォ (semaphore) は、計算機科学史上最も古い同期プリミティブの一つで、草創期のオランダ計算機科学者 Edsger W. Dijkstra によって発明されました (彼は <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> の代わりに <code class="xref py py-meth docutils literal"><span class="pre">P()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">V()</span></code> を使いました)。</p>
<p>セマフォは <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> でデクリメントされ <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> でインクリメントされるような内部カウンタを管理します。カウンタは決してゼロより小さくはなりません; <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> は、カウンタがゼロになっている場合、他のスレッドが <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> を呼び出すまでブロックします。</p>
<dl class="class">
<dt id="threading.Semaphore">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Semaphore</code><span class="sig-paren">(</span><span class="optional">[</span><em>value</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Semaphore" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションの引数には、内部カウンタの初期値を指定します。デフォルトは <code class="docutils literal"><span class="pre">1</span></code> です。与えられた <em>value</em> が 0 より小さい場合、 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。</p>
<dl class="method">
<dt id="threading.Semaphore.acquire">
<code class="descname">acquire</code><span class="sig-paren">(</span><span class="optional">[</span><em>blocking</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Semaphore.acquire" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>セマフォを獲得します。</p>
<p>引数なしで呼び出した場合: <code class="xref py py-meth docutils literal"><span class="pre">acqure()</span></code> 処理に入ったときに内部カウンタがゼロより大きければ、カウンタを 1 デクリメントして即座に処理を戻します。 <code class="xref py py-meth docutils literal"><span class="pre">acqure()</span></code> 処理に入ったときに内部カウンタがゼロの場合、他のスレッドが <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> を呼び出してカウンタをゼロより大きくするまでブロックします。この処理は、適切なインターロック (interlock) を介して行い、複数の <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> 呼び出しがブロックされた場合、 <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> が正確に一つだけを起こせるようにします。この実装はランダムに一つ選択するだけでもよいので、ブロックされたスレッドがどの起こされる順番に依存してはなりません。この場合、戻り値はありません。</p>
<p><em>blocking</em> 引数の値を真にした場合、引数なしで呼び出した場合と同じ処理を行って真を返します。</p>
<p><em>blocking</em> を false にして呼び出すとブロックしません。引数なしで呼び出した場合にブロックするような状況であった場合には直ちに false を返します。それ以外の場合には、引数なしで呼び出したときと同じ処理を行い true を返します。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Semaphore.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Semaphore.release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>内部カウンタを 1 インクリメントして、セマフォを解放します。 <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> 処理に入ったときにカウンタがゼロであり、カウンタの値がゼロより大きくなるのを待っている別のスレッドがあった場合、そのスレッドを起こします。</p>
</dd></dl>

</dd></dl>

<div class="section" id="semaphore-example">
<span id="semaphore-examples"></span><h3>16.2.5.1. <a class="reference internal" href="#threading.Semaphore" title="threading.Semaphore"><code class="xref py py-class docutils literal"><span class="pre">Semaphore</span></code></a> の例<a class="headerlink" href="#semaphore-example" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>セマフォはしばしば、容量に限りのある資源、例えばデータベースサーバなどを保護するために使われます。リソースが固定の状況では、常に有限セマフォを使わなければなりません。主スレッドは、作業スレッドを立ち上げる前にセマフォを初期化します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">maxconnections</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">...</span>
<span class="n">pool_sema</span> <span class="o">=</span> <span class="n">BoundedSemaphore</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">maxconnections</span><span class="p">)</span>
</pre></div>
</div>
<p>作業スレッドは、ひとたび立ち上がると、サーバへ接続する必要が生じたときにセマフォの <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> および <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> メソッドを呼び出します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pool_sema</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">connectdb</span><span class="p">()</span>
<span class="o">...</span> <span class="n">use</span> <span class="n">connection</span> <span class="o">...</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">pool_sema</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</div>
<p>有限セマフォを使うと、セマフォを獲得回数以上に解放してしまうというプログラム上の間違いを見逃しにくくします。</p>
</div>
</div>
<div class="section" id="event-objects">
<span id="id6"></span><h2>16.2.6. Event オブジェクト<a class="headerlink" href="#event-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>イベントは、あるスレッドがイベントを発信し、他のスレッドはそれを待つという、スレッド間で通信を行うための最も単純なメカニズムの一つです。</p>
<p>イベントオブジェクトは内部フラグを管理します。このフラグは <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code class="xref py py-meth docutils literal"><span class="pre">set()</span></code></a> メソッドで値を true に、 <a class="reference internal" href="#threading.Event.clear" title="threading.Event.clear"><code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code></a> メソッドで値を false にリセットします。 <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> メソッドはフラグが true になるまでブロックします。</p>
<dl class="class">
<dt id="threading.Event">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Event</code><a class="headerlink" href="#threading.Event" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>内部フラグの初期値は偽です。</p>
<dl class="method">
<dt id="threading.Event.is_set">
<code class="descname">is_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Event.is_set" title="この定義へのパーマリンク">¶</a></dt>
<dt id="threading.Event.isSet">
<code class="descname">isSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Event.isSet" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>内部フラグの値が true である場合にのみ true を返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>新たに <code class="docutils literal"><span class="pre">is_set()</span></code> として使えるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="threading.Event.set">
<code class="descname">set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Event.set" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>内部フラグの値を true にセットします。フラグの値が true になるのを待っている全てのスレッドを起こします。一旦フラグが true になると、スレッドが <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> を呼び出しても全くブロックしなくなります。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Event.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Event.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>内部フラグの値を false にリセットします。以降は、 <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code class="xref py py-meth docutils literal"><span class="pre">set()</span></code></a> を呼び出して再び内部フラグの値を true にセットするまで、 <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> を呼び出したスレッドはブロックするようになります。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Event.wait">
<code class="descname">wait</code><span class="sig-paren">(</span><span class="optional">[</span><em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Event.wait" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>内部フラグの値が true になるまでブロックします。 <code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code> 処理に入った時点で内部フラグの値が true であれば、直ちに処理を戻します。そうでない場合、他のスレッドが <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code class="xref py py-meth docutils literal"><span class="pre">set()</span></code></a> を呼び出してフラグの値を true にセットするか、オプションのタイムアウトが発生するまでブロックします。</p>
<p><em>timeout</em> 引数を指定して、 <code class="docutils literal"><span class="pre">None</span></code> 以外の値にする場合、タイムアウトを秒 (または端数秒) を表す浮動小数点数でなければなりません。</p>
<p>このメソッドは終了時の内部フラグを返します。 timeout が指定されて、操作がタイムアウトしたとき以外は、 <code class="docutils literal"><span class="pre">True</span></code> を返すはずです。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span>以前は、このメソッドは常に <code class="docutils literal"><span class="pre">None</span></code> を返していました。</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="timer-objects">
<span id="id7"></span><h2>16.2.7. Timer オブジェクト<a class="headerlink" href="#timer-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このクラスは、一定時間経過後に実行される活動、すなわちタイマ活動を表現します。 <a class="reference internal" href="#threading.Timer" title="threading.Timer"><code class="xref py py-class docutils literal"><span class="pre">Timer</span></code></a> は <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">Thread</span></code></a> のサブクラスであり、自作のスレッドを構築した一例でもあります。</p>
<p>タイマは <code class="xref py py-meth docutils literal"><span class="pre">start()</span></code> メソッドを呼び出すとスレッドとして作動し始めします。 (活動を開始する前に) <a class="reference internal" href="#threading.Timer.cancel" title="threading.Timer.cancel"><code class="xref py py-meth docutils literal"><span class="pre">cancel()</span></code></a> メソッドを呼び出すと、タイマを停止できます。タイマが活動を実行するまでの待ち時間は、ユーザが指定した待ち時間と必ずしも厳密には一致しません。</p>
<p>例えば:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s2">&quot;hello, world&quot;</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">(</span><span class="mf">30.0</span><span class="p">,</span> <span class="n">hello</span><span class="p">)</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>  <span class="c1"># after 30 seconds, &quot;hello, world&quot; will be printed</span>
</pre></div>
</div>
<dl class="class">
<dt id="threading.Timer">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Timer</code><span class="sig-paren">(</span><em>interval</em>, <em>function</em>, <em>args=[]</em>, <em>kwargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Timer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>interval</em> 秒後に <em>function</em> を引数 <em>args</em> 、キーワード引数 <em>kwargs</em> つきで実行するようなタイマを生成します。</p>
<dl class="method">
<dt id="threading.Timer.cancel">
<code class="descname">cancel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Timer.cancel" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>タイマをストップして、その動作の実行をキャンセルします。このメソッドはタイマがまだ活動待ち状態にある場合にのみ動作します。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="using-locks-conditions-and-semaphores-in-the-with-statement">
<span id="with-locks"></span><h2>16.2.8. <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文でのロック・条件変数・セマフォの使い方<a class="headerlink" href="#using-locks-conditions-and-semaphores-in-the-with-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールのオブジェクトで <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> 両メソッドを具えているものは全て <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文のコンテキストマネージャとして使うことができます。 <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> メソッドが <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文のブロックに入るときに呼び出され、ブロック脱出時には <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> メソッドが呼ばれます。</p>
<p>現在のところ、 <a class="reference internal" href="#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal"><span class="pre">Lock</span></code></a> 、 <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> 、 <a class="reference internal" href="#threading.Condition" title="threading.Condition"><code class="xref py py-class docutils literal"><span class="pre">Condition</span></code></a> 、 <a class="reference internal" href="#threading.Semaphore" title="threading.Semaphore"><code class="xref py py-class docutils literal"><span class="pre">Semaphore</span></code></a> 、 <a class="reference internal" href="#threading.BoundedSemaphore" title="threading.BoundedSemaphore"><code class="xref py py-class docutils literal"><span class="pre">BoundedSemaphore</span></code></a> を <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文のコンテキストマネージャとして使うことができます。以下の例を見てください。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="n">some_rlock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>

<span class="k">with</span> <span class="n">some_rlock</span><span class="p">:</span>
    <span class="nb">print</span> <span class="s2">&quot;some_rlock is locked while this executes&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="importing-in-threaded-code">
<span id="threaded-imports"></span><h2>16.2.9. スレッド化されたコード中でのImport<a class="headerlink" href="#importing-in-threaded-code" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>スレッドセーフなimportのためには、継承の制限に起因する、ふたつの重要な制約があります。</p>
<ul class="simple">
<li><p class="first">ひとつ目は、主とするモジュール以外では、importが新しいスレッドを生成しないようになっていなければなりません。そして、そのスレッドを待たなければなりません。この制約を守らない場合、生成されたスレッドが直接的、または、間接的にモジュールをimportしようとした際に、デッドロックを引き起こす可能性があります。</p>
</li>
<li><p class="first">ふたつ目は、全てのimportが、インタープリターが自身を終了させる前に完了しなければなりません。これは、最も簡単な方法としては、threadingモジュールを通して生成される非デーモンからのみimportを実行することで達成できます。デーモンスレッド、および、直接、threadモジュールから生成されたスレッドは、インタープリター終了後にimportを実行しないようにする、別の同期の仕組みを必要とします。この制約を守らない場合、 intermittent (間歇) 例外を引き起こし、インタープリターのシャットダウン中にクラッシュする可能性があります。 (後から実行されるimportは、すでにアクセス可能でなくなった領域にアクセスしようとするためです)</p>
</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">16.2. <code class="docutils literal"><span class="pre">threading</span></code> &#8212; 高水準のスレッドインタフェース</a><ul>
<li><a class="reference internal" href="#thread-objects">16.2.1. Thread オブジェクト</a></li>
<li><a class="reference internal" href="#lock-objects">16.2.2. Lock オブジェクト</a></li>
<li><a class="reference internal" href="#rlock-objects">16.2.3. RLock オブジェクト</a></li>
<li><a class="reference internal" href="#condition-objects">16.2.4. Condition オブジェクト</a></li>
<li><a class="reference internal" href="#semaphore-objects">16.2.5. Semaphore オブジェクト</a><ul>
<li><a class="reference internal" href="#semaphore-example">16.2.5.1. <code class="docutils literal"><span class="pre">Semaphore</span></code> の例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#event-objects">16.2.6. Event オブジェクト</a></li>
<li><a class="reference internal" href="#timer-objects">16.2.7. Timer オブジェクト</a></li>
<li><a class="reference internal" href="#using-locks-conditions-and-semaphores-in-the-with-statement">16.2.8. <code class="docutils literal"><span class="pre">with</span></code> 文でのロック・条件変数・セマフォの使い方</a></li>
<li><a class="reference internal" href="#importing-in-threaded-code">16.2.9. スレッド化されたコード中でのImport</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="select.html"
                        title="前の章へ">16.1. <code class="docutils literal"><span class="pre">select</span></code> &#8212; I/O 処理の完了を待機する</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="thread.html"
                        title="次の章へ">16.3. <code class="docutils literal"><span class="pre">thread</span></code> &#8212; マルチスレッドのコントロール</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">バグ報告</a></li>
  <li><a href="https://github.com/python/cpython/blob/2.7/Doc/library/threading.rst"
         rel="nofollow">ソースの表示</a>
  </li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="thread.html" title="16.3. thread — マルチスレッドのコントロール"
             >次へ</a> |</li>
        <li class="right" >
          <a href="select.html" title="16.1. select — I/O 処理の完了を待機する"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.13</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="someos.html" >16. オプションのオペレーティングシステムサービス</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト).
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    Last updated on 2017-03-23.
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>