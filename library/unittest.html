
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>25.3. unittest — ユニットテストフレームワーク &#8212; Python 2.7.14 ドキュメント</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.14',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7.14 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="25.4. 2to3 - Python 2 から 3 への自動コード変換" href="2to3.html" />
    <link rel="prev" title="25.2. doctest — 対話的な実行例をテストする" href="doctest.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/unittest.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2to3.html" title="25.4. 2to3 - Python 2 から 3 への自動コード変換"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="25.2. doctest — 対話的な実行例をテストする"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.14</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">25. 開発ツール</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-unittest">
<span id="unittest-unit-testing-framework"></span><h1>25.3. <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> — ユニットテストフレームワーク<a class="headerlink" href="#module-unittest" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.1 で追加.</span></p>
</div>
<p>(読者の方がすでにテストの基本概念についてなじみがあるようでしたら、この部分をとばして <a class="reference internal" href="#assert-methods"><span class="std std-ref">the list of assert methods</span></a> に進むと良いでしょう。)</p>
<p>この Python ユニットテストフレームワークは時に &quot;PyUnit&quot; とも呼ばれ、 Kent Beck と Erich Gamma による JUnit の Python 版です。 JUnit はまた Kent の Smalltalk 用テストフレームワークの Java 版で、どちらもそれぞれの言語で業界標準のユニットテストフレームワークとなっています。</p>
<p><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> では、テストの自動化・初期設定と終了処理の共有・テストの分類・テスト実行と結果レポートの分離などの機能を提供しており、 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> のクラスを使って簡単にたくさんのテストを開発できるようになっています。</p>
<p>これを実現するために、 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> はいくつかの重要な概念をサポートしています:</p>
<dl class="docutils">
<dt>テストフィクスチャ (test fixture)</dt>
<dd><em class="dfn">test fixture</em> とは、テスト実行のために必要な準備や終了処理を指します。例: テスト用データベースの作成・ディレクトリ・サーバプロセスの起動など。</dd>
<dt>テストケース (test case)</dt>
<dd><em class="dfn">test case</em> はテストの最小単位で、各入力に対する結果をチェックします。テストケースを作成する場合は、 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> が提供する <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> クラスを基底クラスとして利用することができます。</dd>
<dt>テストスイート (test suite)</dt>
<dd><em class="dfn">test suite</em> はテストケースとテストスイートの集まりで、同時に実行しなければならないテストをまとめる場合に使用します。</dd>
<dt>テストランナー (test runner)</dt>
<dd><em class="dfn">test runner</em> はテストの実行と結果表示を管理するコンポーネントです。ランナーはグラフィカルインターフェースでもテキストインターフェースでも良いですし、何も表示せずにテスト結果を示す値を返すだけの場合もあります。</dd>
</dl>
<p><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> では、テストケースとテストフィクスチャーを、 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> クラスと <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></code></a> クラスで提供しています。 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> クラスは新規にテストを作成する場合に使用し、 <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></code></a> は既存のテストを <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> に組み込む場合に使用します。テストフィクスチャーの初期化処理と終了処理は、 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> では <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal"><span class="pre">setUp()</span></code></a> メソッドと <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></code></a> をオーバーライドして記述し、 <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></code></a> では初期化・終了処理を行う既存の関数をコンストラクタで指定します。テスト実行時、まずテストフィクスチャーの初期設定が最初に実行されます。初期化処理が正常終了した場合、テスト実行後にはテスト結果に関わらず終了処理が実行されます。 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> の各インスタンスが実行するテストは一つだけで、テストフィクスチャーは各テストごとに新しく作成されます。</p>
<p>テストスイートは <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> クラスで実装されており、複数のテストとテストスイートをまとめる事ができます。テストスイートを実行すると、スイートと <em>子</em> スイートに追加されている全てのテストが実行されます。</p>
<p>テストランナーは <code class="xref py py-meth docutils literal"><span class="pre">run()</span></code> メソッドを持つオブジェクトです。このメソッドは引数として <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> か <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> オブジェクトを受け取り、テスト結果を <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal"><span class="pre">TestResult</span></code></a> オブジェクトで戻します。 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> ではデフォルトでテスト結果を標準エラーに出力する <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code class="xref py py-class docutils literal"><span class="pre">TextTestRunner</span></code></a> をサンプルとして実装しています。これ以外のランナー (グラフィックインターフェース用など) を実装する場合でも、特別なクラスから派生させて実装する必要はありません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal"><span class="pre">doctest</span></code></a> モジュール</dt>
<dd>もうひとつのテストをサポートするモジュールで、本モジュールと趣きが異なっています。</dd>
<dt><a class="reference external" href="https://pypi.python.org/pypi/unittest2">unittest2: ユニットテストの新機能の Python 2.4-2.6 向けバックポート</a></dt>
<dd>Python 2.7 になり多くの機能が unittest に追加されました。特に、テストディスカバリが追加されました。 unittest2 を導入する事で以前のバージョンの Python でもこれらの機能を使えます。</dd>
<dt><a class="reference external" href="https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm">Simple Smalltalk Testing: With Patterns</a></dt>
<dd>Kent Beck のテスティングフレームワークに関する原論文で、ここに記載されたパターンを <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> が使用しています。</dd>
<dt><a class="reference external" href="https://nose.readthedocs.org/en/latest/">Nose</a> と <a class="reference external" href="http://pytest.org">py.test</a></dt>
<dd>サードパーティのユニットテストフレームワークで軽量な文法でテストを書くことができます。例えば、<code class="docutils literal"><span class="pre">assert</span> <span class="pre">func(10)</span> <span class="pre">==</span> <span class="pre">42</span></code>  のように書きます。</dd>
<dt><a class="reference external" href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">The Python Testing Tools Taxonomy</a></dt>
<dd>多くの Python のテストツールが一覧で紹介されています。ファンクショナルテストのフレームワークやモックライブラリも掲載されています。</dd>
<dt><a class="reference external" href="http://lists.idyll.org/listinfo/testing-in-python">Testing in Python メーリングリスト</a></dt>
<dd>Python でテストやテストツールについての議論に特化したグループです。</dd>
</dl>
</div>
<div class="section" id="basic-example">
<span id="unittest-minimal-example"></span><h2>25.3.1. 基礎的な例<a class="headerlink" href="#basic-example" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> モジュールには、テストの開発や実行の為の優れたツールが用意されており、この節では、その一部を紹介します。ほとんどのユーザとっては、ここで紹介するツールだけで十分でしょう。</p>
<p>以下は、三つの文字列メソッドをテストするスクリプトです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">TestStringMethods</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="s1">&#39;FOO&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_isupper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="s1">&#39;FOO&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="s1">&#39;Foo&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">test_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;hello world&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">])</span>
        <span class="c1"># check that s.split fails when the separator is not a string</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
            <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>テストケースは、 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">unittest.TestCase</span></code></a> のサブクラスとして作成します。メソッド名が <code class="docutils literal"><span class="pre">test</span></code> で始まる三つのメソッドがテストです。テストランナーはこの命名規約によってテストを行うメソッドを検索します。</p>
<p>これらのテスト内では、予定の結果が得られていることを確かめるために <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></code></a> を、条件のチェックに <a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal"><span class="pre">assertTrue()</span></code></a> や <a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal"><span class="pre">assertFalse()</span></code></a> を、例外が発生する事を確認するために <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></code></a> をそれぞれ呼び出しています。 <a class="reference internal" href="../reference/simple_stmts.html#assert"><code class="xref std std-keyword docutils literal"><span class="pre">assert</span></code></a> 文の代わりにこれらのメソッドを使用すると、テストランナーでテスト結果を集計してレポートを作成する事ができます。</p>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal"><span class="pre">setUp()</span></code></a> および <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></code></a> メソッドによって各テストメソッドの前後に実行する命令を実装することが出来ます。詳細は <a class="reference internal" href="#organizing-tests"><span class="std std-ref">テストの構成</span></a> を参照してください。</p>
<p>サンプルの末尾が、簡単なテストの実行方法です。 <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal"><span class="pre">unittest.main()</span></code></a> は、テストスクリプトのコマンドライン用インターフェースです。コマンドラインから起動された場合、上記のスクリプトから以下のような結果が出力されます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.000</span><span class="n">s</span>

<span class="n">OK</span>
</pre></div>
</div>
<p>簡略化した結果を出力したり、コマンドライン以外からも起動する等のより細かい制御が必要であれば、 <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal"><span class="pre">unittest.main()</span></code></a> を使用せずに別の方法でテストを実行します。コマンドラインから起動する必要もありません。例えば、上記サンプルの最後の2行は以下のように書くことができます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestLoader</span><span class="p">()</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">TestStringMethods</span><span class="p">)</span>
<span class="n">unittest</span><span class="o">.</span><span class="n">TextTestRunner</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">suite</span><span class="p">)</span>
</pre></div>
</div>
<p>変更後のスクリプトをインタープリタや別のスクリプトから実行すると、以下の出力が得られます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">test_isupper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_split</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_upper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.001</span><span class="n">s</span>

<span class="n">OK</span>
</pre></div>
</div>
<p>以上が <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> モジュールでよく使われる機能で、ほとんどのテストではこれだけでも十分です。基礎となる概念や全ての機能については以降の章を参照してください。</p>
</div>
<div class="section" id="command-line-interface">
<span id="unittest-command-line-interface"></span><h2>25.3.2. コマンドラインインターフェイス<a class="headerlink" href="#command-line-interface" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ユニットテストモジュールはコマンドラインから使うこともできます。モジュール、クラス、もしくは、特定のテストメソッドで定義されたテストを実行します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module1</span> <span class="n">test_module2</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module</span><span class="o">.</span><span class="n">TestClass</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module</span><span class="o">.</span><span class="n">TestClass</span><span class="o">.</span><span class="n">test_method</span>
</pre></div>
</div>
<p>引数として渡す事ができるのは、テストが定義されたモジュール名、もしくはクラス、メソッドのフルパス名です。</p>
<p>テスト実行時に (より冗長な) 詳細を表示するには -v フラグを渡します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="o">-</span><span class="n">v</span> <span class="n">test_module</span>
</pre></div>
</div>
<p>コマンドラインプションの一覧を表示するには以下のコマンドを実行します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="o">-</span><span class="n">h</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span>以前のバージョンでは、個々のテストメソッドしか実行することができず、モジュール単位やクラス単位で実行することは不可能でした。</p>
</div>
<div class="section" id="command-line-options">
<h3>25.3.2.1. コマンドラインオプション<a class="headerlink" href="#command-line-options" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><strong class="program">unittest</strong> には以下のコマンドラインオプションがあります:</p>
<dl class="cmdoption">
<dt id="cmdoption-unittest-b">
<code class="descname">-b</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--buffer</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-unittest-b" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>標準出力と標準エラーのストリームをテスト実行の間バッファリングします。テストが成功している間は結果の出力は破棄されます。テストが失敗、もしくはエラーが発生した場合には、結果にエラーメッセージが追加されたうえで通常通り出力されます。</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-c">
<code class="descname">-c</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--catch</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-unittest-c" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="kbd docutils literal"><span class="pre">Control-C</span></code> を実行中のテストが終了するまで遅延させ、そこまでの結果を出力します。二回目の <code class="kbd docutils literal"><span class="pre">Control-C</span></code> は、通常通り <a class="reference internal" href="exceptions.html#exceptions.KeyboardInterrupt" title="exceptions.KeyboardInterrupt"><code class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></code></a> の例外を発生させます。</p>
<p>この機能の仕組みについては、<a class="reference internal" href="#signal-handling">シグナルハンドリング</a> を参照してください。</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-f">
<code class="descname">-f</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--failfast</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-unittest-f" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>初回のエラーもしくは失敗の時にテストを停止します。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加: </span>コマンドラインオプションの <code class="docutils literal"><span class="pre">-b</span></code>、<code class="docutils literal"><span class="pre">-c</span></code>、<code class="docutils literal"><span class="pre">-f</span></code> が追加されました。</p>
</div>
<p>このコマンドラインは、プロジェクト内の全テストを実行したり、サブセットのみを実行したりといった、テストディスカバリを使用することもできます。</p>
</div>
</div>
<div class="section" id="test-discovery">
<span id="unittest-test-discovery"></span><h2>25.3.3. テストディスカバリ<a class="headerlink" href="#test-discovery" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
<p>unittest はシンプルなテストディスカバリをサポートします。このテストディスカバリに対応するために、テストが定義された全ファイルは <a class="reference internal" href="../tutorial/modules.html#tut-modules"><span class="std std-ref">modules</span></a> もしくは <a class="reference internal" href="../tutorial/modules.html#tut-packages"><span class="std std-ref">packages</span></a> としてプロジェクトの最上位のディスカバリでインポート可能である必要があります (つまり、これらのファイルは <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">identifiers</span></a> として有効である必要があるということです)。</p>
<p>テストディスカバリは <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code class="xref py py-meth docutils literal"><span class="pre">TestLoader.discover()</span></code></a> で実装されています。しかし、コマンドラインからも使う事ができます。コマンドラインからは以下のように使用します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">project_directory</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">discover</span></code> サブコマンドには以下のオプションがあります:</p>
<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-v">
<code class="descname">-v</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--verbose</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-unittest-discover-v" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>詳細な出力</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-s">
<code class="descname">-s</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--start-directory</code><code class="descclassname"> directory</code><a class="headerlink" href="#cmdoption-unittest-discover-s" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ディスカバリを開始するディレクトリ (デフォルトは <code class="docutils literal"><span class="pre">.</span></code>)</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-p">
<code class="descname">-p</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--pattern</code><code class="descclassname"> pattern</code><a class="headerlink" href="#cmdoption-unittest-discover-p" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストファイル名を識別するパターン (デフォルトは <code class="docutils literal"><span class="pre">test*.py</span></code>)</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-t">
<code class="descname">-t</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--top-level-directory</code><code class="descclassname"> directory</code><a class="headerlink" href="#cmdoption-unittest-discover-t" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロジェクトの最上位のディスカバリのディレクトリ (デフォルトは開始のディレクトリ)</p>
</dd></dl>

<p><a class="reference internal" href="#cmdoption-unittest-discover-s"><code class="xref std std-option docutils literal"><span class="pre">-s</span></code></a> 、 <a class="reference internal" href="#cmdoption-unittest-discover-p"><code class="xref std std-option docutils literal"><span class="pre">-p</span></code></a> 、および <a class="reference internal" href="#cmdoption-unittest-discover-t"><code class="xref std std-option docutils literal"><span class="pre">-t</span></code></a> の各オプションは、この順番で指定すれば位置固定の引数として指定する事ができます。以下の二つのコマンドは同じ結果になります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="o">-</span><span class="n">s</span> <span class="n">project_directory</span> <span class="o">-</span><span class="n">p</span> <span class="s2">&quot;*_test.py&quot;</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="n">project_directory</span> <span class="s2">&quot;*_test.py&quot;</span>
</pre></div>
</div>
<p>パスを渡すのはもちろんのこと、例えば <code class="docutils literal"><span class="pre">myproject.subpackage.test</span></code> のように、パッケージ名をスタートディレクトリとして渡すことができます。指定したパッケージがインポートされ、そのパッケージのファイルシステム上のパスがスタートディレクトリになります。</p>
<div class="admonition caution">
<p class="first admonition-title">ご用心</p>
<p>テストディスカバリはテストをインポートすることで読み込みます。テストディスカバリは一度、指定した開始ディレクトリから全テストファイルを探索し、そのファイルのパスをパッケージ名に変換してインポートします。例えば、 <code class="file docutils literal"><span class="pre">foo/bar/baz.py</span></code> は <code class="docutils literal"><span class="pre">foo.bar.baz</span></code> としてインポートされます。</p>
<p>もしパッケージをグローバルにインストールしていて、インストールしたのとは異なるパッケージのコピーをディスカバリしようとすると、間違った場所からインポートして <em>しまうかもしれません</em>。このような状態になるとテストディスカバリは警告を出し、停止します。</p>
<p class="last">スタートディレクトリとしてディレクトリのパスではなくパッケージ名を指定した場合は、いずれかの場所からインポートされます。この場合は警告が表示されません。</p>
</div>
<p>テストモジュールとテストパッケージは、テストのロードとディスカバリをカスタマイズすることができます。そのために <a class="reference internal" href="#load-tests-protocol">load_tests プロトコル</a> を使用します。</p>
</div>
<div class="section" id="organizing-test-code">
<span id="organizing-tests"></span><h2>25.3.4. テストの構成<a class="headerlink" href="#organizing-test-code" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ユニットテストの基礎となる構築要素は、 <em class="dfn">test case</em> — セットアップを行い、正しさのチェックを行う、独立したシナリオ — です。 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> では、テストケースは <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> モジュールの <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> クラスのインスタンスで表現します。テストケースを作成するには <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> のサブクラスを記述するか、または <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></code></a> を使用します。</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> から派生したクラスのインスタンスは、このオブジェクトだけで単独のテストメソッドをお膳立て (set-up) と後片付け (tidy-up / clean-up) を伴って実行します。</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> インスタンスは外部から完全に独立し、単独で実行する事も、他の任意のテストと一緒に実行する事もできなければなりません。</p>
<p>以下のように、 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> のサブクラスは <code class="xref py py-meth docutils literal"><span class="pre">runTest()</span></code> をオーバライドし、必要なテスト処理を記述するだけで簡単に書くことができます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">DefaultWidgetSizeTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">runTest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="s1">&#39;incorrect default size&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>何らかのテストを行う場合、ベースクラス <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> の <code class="xref py py-meth docutils literal"><span class="pre">assert*()</span></code> 系メソッドのどれかを使用してください。テストが失敗すると例外が送出され、 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> はテスト結果を <em class="dfn">failure</em> とします。その他の例外は <em class="dfn">error</em> となります。これによりどこに問題があるかが判ります。 <em class="dfn">failure</em> は間違った結果 (6 になるはずが 5 だった) で発生します。 <em class="dfn">error</em> は間違ったコード (たとえば間違った関数呼び出しによる <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>) で発生します。</p>
<p>テストの実行方法については後述とし、まずはテストケースインスタンスの作成方法を示します。テストケースインスタンスは、以下のように引数なしでコンストラクタを呼び出して作成します。:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">testCase</span> <span class="o">=</span> <span class="n">DefaultWidgetSizeTestCase</span><span class="p">()</span>
</pre></div>
</div>
<p>さて、そのようなテストケースが夥しい数になってくると、セットアップ処理は繰り返しになりがちです。例えば上記のような Widget のテストが 100 種類も必要な場合、それぞれのサブクラスで <code class="xref py py-class docutils literal"><span class="pre">Widget</span></code> オブジェクトを生成する処理を記述するのは好ましくありません。</p>
<p>ラッキーですね、私たちは初期化処理を <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal"><span class="pre">setUp()</span></code></a> メソッドに追い出すことが出来ます。これでテスト実行時にテストフレームワークが、私たちのためにそれを自動的に実行してくれます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">SimpleWidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DefaultWidgetSizeTestCase</span><span class="p">(</span><span class="n">SimpleWidgetTestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">runTest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
                         <span class="s1">&#39;incorrect default size&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">WidgetResizeTestCase</span><span class="p">(</span><span class="n">SimpleWidgetTestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">runTest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">),</span>
                         <span class="s1">&#39;wrong size after resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>テスト中に <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal"><span class="pre">setUp()</span></code></a> メソッドで例外が発生した場合、テストフレームワークはテストを実行することができないとみなし、 <code class="xref py py-meth docutils literal"><span class="pre">runTest()</span></code> を実行しません。</p>
<p>同様に、終了処理を <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></code></a> メソッドに記述すると、 <code class="xref py py-meth docutils literal"><span class="pre">runTest()</span></code> メソッド終了後に実行されます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">SimpleWidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal"><span class="pre">setUp()</span></code></a> が正常終了した場合、 <code class="xref py py-meth docutils literal"><span class="pre">runTest()</span></code> が成功したかどうかに関わらず <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></code></a> が実行されます。</p>
<p>このような、テストを実行する環境を <em class="dfn">fixture</em> と呼びます。</p>
<p>多数の小さなテストケース群が同じフィクスチャを使うことは良くあります。今の場合だと私たちは結局 <code class="xref py py-class docutils literal"><span class="pre">SimpleWidgetTestCase</span></code> を派生して、 <code class="xref py py-class docutils literal"><span class="pre">DefaultWidgetSizeTestCase</span></code> のような小さくて一つだけメソッドを持つクラスをたくさん作る必要があるところでした。これは退屈で時間のかかるものです。ですから JUnit と同じようなやり方で、 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> ではより簡単なメカニズムを用意しています:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">WidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">test_default_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
                         <span class="s1">&#39;incorrect default size&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_resize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">),</span>
                         <span class="s1">&#39;wrong size after resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>この例では <code class="xref py py-meth docutils literal"><span class="pre">runTest()</span></code> がありませんが、二つのテストメソッドを定義しています。このクラスのインスタンスは <code class="xref py py-meth docutils literal"><span class="pre">test_*()</span></code> メソッドのどちらか一方の実行と、 <code class="docutils literal"><span class="pre">self.widget</span></code> の生成・解放を行います。この場合、テストケースインスタンス生成時に、コンストラクタの引数として実行するメソッド名を指定します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">defaultSizeTestCase</span> <span class="o">=</span> <span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_default_size&#39;</span><span class="p">)</span>
<span class="n">resizeTestCase</span> <span class="o">=</span> <span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> では <code class="xref py py-class docutils literal"><span class="pre">test</span> <span class="pre">suite</span></code> によってテストケースインスタンスをテスト対象の機能によってグループ化することができます。 <em class="dfn">test suite</em> は、 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> の <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> クラスで作成します。:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">widgetTestSuite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
<span class="n">widgetTestSuite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_default_size&#39;</span><span class="p">))</span>
<span class="n">widgetTestSuite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_resize&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>各テストモジュールで、テストケースを組み込んだテストスイートオブジェクトを作成する呼び出し可能オブジェクトを用意しておくと、テストの実行や参照が容易になります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_default_size&#39;</span><span class="p">))</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_resize&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>または:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">tests</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;test_default_size&#39;</span><span class="p">,</span> <span class="s1">&#39;test_resize&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">,</span> <span class="n">tests</span><span class="p">))</span>
</pre></div>
</div>
<p>良く似た名前のテスト関数をたくさん定義した <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> のサブクラスを作るのはよくあるパターンなので、 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> ではテストスイートの作成と個々のテストをそれを追加するのを自動化するのに使える、 <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal"><span class="pre">TestLoader</span></code></a> を用意しています。たとえば、:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestLoader</span><span class="p">()</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">)</span>
</pre></div>
</div>
<p>は <code class="docutils literal"><span class="pre">WidgetTestCase.test_default_size()</span></code> と <code class="docutils literal"><span class="pre">WidgetTestCase.test_resize</span></code> を走らせるテストスイートを作成します。 <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal"><span class="pre">TestLoader</span></code></a> は自動的にテストメソッドを識別するのに <code class="docutils literal"><span class="pre">'test'</span></code> というメソッド名の接頭辞を使います。</p>
<p>テストケースはテスト関数名を組み込みの文字列順に並べ替えた順序で実行されることに注意してください。</p>
<p>システム全体のテストを一度に行う場合など、テストスイートをさらにグループ化したい場合がよくあります。これは簡単です。 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> インスタンスには <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a>  インスタンスだけでなく <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> も追加出来るからです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">suite1</span> <span class="o">=</span> <span class="n">module1</span><span class="o">.</span><span class="n">TheTestSuite</span><span class="p">()</span>
<span class="n">suite2</span> <span class="o">=</span> <span class="n">module2</span><span class="o">.</span><span class="n">TheTestSuite</span><span class="p">()</span>
<span class="n">alltests</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">([</span><span class="n">suite1</span><span class="p">,</span> <span class="n">suite2</span><span class="p">])</span>
</pre></div>
</div>
<p>テストケースやテストスイートは (<code class="file docutils literal"><span class="pre">widget.py</span></code> のような) テスト対象のモジュール内にも記述できますが、テストは (<code class="file docutils literal"><span class="pre">test_widget.py</span></code> のような) 独立したモジュールに置いた方が以下のような点で有利です:</p>
<ul class="simple">
<li>テストモジュールだけをコマンドラインから実行することができる。</li>
<li>テストコードと出荷するコードを分離する事ができる。</li>
<li>テストコードを、テスト対象のコードに合わせて修正する誘惑に駆られにくい。</li>
<li>テストコードは、テスト対象コードほど頻繁に更新されない。</li>
<li>テストコードをより簡単にリファクタリングすることができる。</li>
<li>Cで書いたモジュールのテストはどっちにしろ独立したモジュールとなるのだから、同様にしない理由もない</li>
<li>テスト戦略を変更した場合でも、ソースコードを変更する必要がない。</li>
</ul>
</div>
<div class="section" id="re-using-old-test-code">
<span id="legacy-unit-tests"></span><h2>25.3.5. 既存テストコードの再利用<a class="headerlink" href="#re-using-old-test-code" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>既存のテストコードが有るとき、このテストを <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> で実行しようとするために古いテスト関数をいちいち <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> クラスのサブクラスに変換するのは大変です。</p>
<p>このような場合は、 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> では <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> のサブクラスである <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></code></a> クラスを使い、既存のテスト関数をラップします。初期設定と終了処理も行なえます。</p>
<p>以下のテストコードがあった場合:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">testSomething</span><span class="p">():</span>
    <span class="n">something</span> <span class="o">=</span> <span class="n">makeSomething</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">something</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>等価なテストケースインスタンスは次のように作成できます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">testcase</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">FunctionTestCase</span><span class="p">(</span><span class="n">testSomething</span><span class="p">)</span>
</pre></div>
</div>
<p>テストケースの操作の部品として呼び出されるべき追加的なお膳立てと後片付けメソッドを手持ちなのであれば、このようにして提供出来ます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">testcase</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">FunctionTestCase</span><span class="p">(</span><span class="n">testSomething</span><span class="p">,</span>
                                     <span class="n">setUp</span><span class="o">=</span><span class="n">makeSomethingDB</span><span class="p">,</span>
                                     <span class="n">tearDown</span><span class="o">=</span><span class="n">deleteSomethingDB</span><span class="p">)</span>
</pre></div>
</div>
<p>既存のテストスイートからの移行を容易にするため、 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> は <a class="reference internal" href="exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code></a> の送出でテストの失敗を示すような書き方もサポートしています。しかしながら、 <code class="xref py py-meth docutils literal"><span class="pre">TestCase.fail*()</span></code> および <code class="xref py py-meth docutils literal"><span class="pre">TestCase.assert*()</span></code> メソッドを使って明確に書くことが推奨されています。 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> の将来のバージョンでは、 <a class="reference internal" href="exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code></a> は別の目的に使用される可能性があります。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></code></a> を使って既存のテストを <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> ベースのテスト体系に変換することができますが、この方法は推奨されません。時間を掛けて <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> のサブクラスに書き直した方が将来的なテストのリファクタリングが限りなく易しくなります。</p>
</div>
<p>既存のテストが <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal"><span class="pre">doctest</span></code></a> を使って書かれている場合もあるでしょう。その場合、 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal"><span class="pre">doctest</span></code></a> は <code class="xref py py-class docutils literal"><span class="pre">DocTestSuite</span></code> クラスを提供します。このクラスは、既存の <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal"><span class="pre">doctest</span></code></a>ベースのテストから、自動的に <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">unittest.TestSuite</span></code></a> のインスタンスを作成します。</p>
</div>
<div class="section" id="skipping-tests-and-expected-failures">
<span id="unittest-skipping"></span><h2>25.3.6. テストのスキップと意図的な失敗<a class="headerlink" href="#skipping-tests-and-expected-failures" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
<p>unittest は特定のテストメソッドやテストクラス全体をスキップする仕組みを備えています。さらに、この機能はテスト結果を「意図的な失敗 (expected failure)」とすることができ、テストが失敗しても <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal"><span class="pre">TestResult</span></code></a> の失敗数にはカウントされなくなります。</p>
<p>テストをスキップするには、単に <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code class="xref py py-func docutils literal"><span class="pre">skip()</span></code></a> デコレータ(<a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>) を使用するか、条件を表現するための <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code class="xref py py-func docutils literal"><span class="pre">skip()</span></code></a> に類するデコレータを使用します。</p>
<p>スキップは以下のようになります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;demonstrating skipping&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_nothing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s2">&quot;shouldn&#39;t happen&quot;</span><span class="p">)</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipIf</span><span class="p">(</span><span class="n">mylib</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                     <span class="s2">&quot;not supported in this library version&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Tests that work for only a certain version of the library.</span>
        <span class="k">pass</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipUnless</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;win&quot;</span><span class="p">),</span> <span class="s2">&quot;requires Windows&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_windows_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># windows specific testing code</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>このサンプルを詳細モードで実行すると以下のように出力されます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">test_format</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;not supported in this library version&#39;</span>
<span class="n">test_nothing</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;demonstrating skipping&#39;</span>
<span class="n">test_windows_support</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;requires Windows&#39;</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.005</span><span class="n">s</span>

<span class="n">OK</span> <span class="p">(</span><span class="n">skipped</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>テストクラスは以下のようにメソッドをスキップすることができます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;showing class skipping&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MySkippedTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_not_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal"><span class="pre">TestCase.setUp()</span></code></a> もスキップすることができます。この機能はセットアップの対象のリソースが使用不可能な状態の時に便利です。</p>
<p>意図的な失敗の機能を使用するには、 <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal"><span class="pre">expectedFailure()</span></code></a> デコレータを使います。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExpectedFailureTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@unittest</span><span class="o">.</span><span class="n">expectedFailure</span>
    <span class="k">def</span> <span class="nf">test_fail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;broken&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>独自のスキップ用のデコレータも簡単に作成することができます。 そのためには、独自のデコレータのスキップしたい時点で <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code class="xref py py-func docutils literal"><span class="pre">skip()</span></code></a> を呼び出します。 以下のデコレータはオブジェクトに指定した属性が無い場合にテストをスキップします:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">skipUnlessHasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">:</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> doesn&#39;t have </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
</pre></div>
</div>
<p>以下のデコレータはテストのスキップと意図的な失敗を実装しています:</p>
<dl class="function">
<dt id="unittest.skip">
<code class="descclassname">unittest.</code><code class="descname">skip</code><span class="sig-paren">(</span><em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デコレートしたテストを無条件でスキップします。<em>reason</em> にはテストをスキップした理由を記載します。</p>
</dd></dl>

<dl class="function">
<dt id="unittest.skipIf">
<code class="descclassname">unittest.</code><code class="descname">skipIf</code><span class="sig-paren">(</span><em>condition</em>, <em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skipIf" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>condition</em> が真の場合に、デコレートしたテストをスキップします。</p>
</dd></dl>

<dl class="function">
<dt id="unittest.skipUnless">
<code class="descclassname">unittest.</code><code class="descname">skipUnless</code><span class="sig-paren">(</span><em>condition</em>, <em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skipUnless" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>condition</em> が偽の場合に、デコレートしたテストをスキップします。</p>
</dd></dl>

<dl class="function">
<dt id="unittest.expectedFailure">
<code class="descclassname">unittest.</code><code class="descname">expectedFailure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.expectedFailure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストの失敗が意図的であることを表します。該当のテストが失敗しても、そのテストは失敗にカウントされません。</p>
</dd></dl>

<dl class="exception">
<dt id="unittest.SkipTest">
<em class="property">exception </em><code class="descclassname">unittest.</code><code class="descname">SkipTest</code><span class="sig-paren">(</span><em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.SkipTest" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この例外はテストをスキップするために送出されます。</p>
<p>ふつうはこれを直接送出する代わりに <a class="reference internal" href="#unittest.TestCase.skipTest" title="unittest.TestCase.skipTest"><code class="xref py py-meth docutils literal"><span class="pre">TestCase.skipTest()</span></code></a> やスキッピングデコレータの一つを使用出来ます。</p>
</dd></dl>

<p>スキップしたテストの前後では、 <code class="xref py py-meth docutils literal"><span class="pre">setUp()</span></code> および <code class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></code> は実行されません。同様に、スキップしたテストクラスの前後では、 <code class="xref py py-meth docutils literal"><span class="pre">setUpClass()</span></code> および <code class="xref py py-meth docutils literal"><span class="pre">tearDownClass()</span></code> は実行されません。</p>
</div>
<div class="section" id="classes-and-functions">
<span id="unittest-contents"></span><h2>25.3.7. クラスと関数<a class="headerlink" href="#classes-and-functions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この節では、 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> モジュールのAPIの詳細について説明します。</p>
<div class="section" id="test-cases">
<span id="testcase-objects"></span><h3>25.3.7.1. テストクラス<a class="headerlink" href="#test-cases" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="class">
<dt id="unittest.TestCase">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">TestCase</code><span class="sig-paren">(</span><em>methodName='runTest'</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> クラスのインスタンスは、 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> の世界におけるテストの最小実行単位を示します。このクラスをベースクラスとして使用し、必要なテストを具象サブクラスに実装します。 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> クラスでは、テストランナーがテストを実行するためのインターフェースと、各種のチェックやテスト失敗をレポートするためのメソッドを実装しています。</p>
<p>それぞれの <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> クラスのインスタンスはただ一つのテストメソッド、 <em>methodName</em> という名のメソッドを実行します。既に次のような例を扱ったことを憶えているでしょうか。:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_default_size&#39;</span><span class="p">))</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_resize&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>ここでは、それぞれが一つずつのテストを実行するような <code class="xref py py-class docutils literal"><span class="pre">WidgetTestCase</span></code> の二つのインスタンスを作成しています。</p>
<p><em>methodName</em> のデフォルトは <code class="xref py py-meth docutils literal"><span class="pre">runTest()</span></code> です。</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> のインスタンスのメソッドは3種類のグループに分けられます。 1つ目のグループのメソッドはテストの実行で使用します。2つ目のグループのメソッドは条件の確認および失敗のレポートといったテストの実装で使用されます。3つ目のグループである問い合わせ用のメソッドはテスト自身の情報を収集するために使用します。</p>
<p>はじめのグループ (テスト実行) に含まれるメソッドは以下の通りです:</p>
<dl class="method">
<dt id="unittest.TestCase.setUp">
<code class="descname">setUp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.setUp" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストフィクスチャの準備のために呼び出されるメソッドです。テストメソッドの直前に呼び出されます。このメソッドを実行中に <a class="reference internal" href="exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code></a> や <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal"><span class="pre">SkipTest</span></code></a> 以外の例外が発生した場合、テストの失敗ではなくエラーとされます。デフォルトの実装では何も行いません。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.tearDown">
<code class="descname">tearDown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.tearDown" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストメソッドが実行され、結果が記録された直後に呼び出されるメソッドです。このメソッドはテストメソッドで例外が投げられても呼び出されます。そのため、サブクラスでこのメソッドを実装する場合は、内部状態を確認することが必要になるでしょう。このメソッドで <a class="reference internal" href="exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code></a> や <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal"><span class="pre">SkipTest</span></code></a> 以外の例外が発生した場合、テストの失敗とは別のエラーとみなされます (従って報告されるエラーの総数は増えます)。このメソッドは、テストの結果に関わらず <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal"><span class="pre">setUp()</span></code></a> が成功した場合にのみ呼ばれます。デフォルトの実装では何も行いません。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.setUpClass">
<code class="descname">setUpClass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.setUpClass" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラス内に定義されたテストが実行される前に呼び出されるクラスメソッドです。 <code class="docutils literal"><span class="pre">setUpClass</span></code> はクラスを唯一の引数として取り、 <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal"><span class="pre">classmethod()</span></code></a> でデコレートされている必要があります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>詳しくは <a class="reference internal" href="#class-and-module-fixtures">クラスとモジュールのフィクスチャ</a> を参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.tearDownClass">
<code class="descname">tearDownClass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.tearDownClass" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラス内に定義されたテストが実行された後に呼び出されるクラスメソッドです。 <code class="docutils literal"><span class="pre">tearDownClass</span></code> はクラスを唯一の引数として取り、 <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal"><span class="pre">classmethod()</span></code></a> でデコレートされている必要があります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>詳しくは <a class="reference internal" href="#class-and-module-fixtures">クラスとモジュールのフィクスチャ</a> を参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>result=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.run" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストを実行し、テスト結果を <em>result</em> に指定されたテスト結果オブジェクトに渡します。 <em>result</em> 省略されるか <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> か渡された場合、一時的な結果オブジェクトを ( <code class="xref py py-meth docutils literal"><span class="pre">defaultTestCase()</span></code> メソッドを呼んで) 生成して、それを使用します。結果オブジェクトは <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> の呼び出し元には返されません。</p>
<p>このメソッドは、単に <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> インスタンスを呼び出した場合と同様に振る舞います。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.skipTest">
<code class="descname">skipTest</code><span class="sig-paren">(</span><em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.skipTest" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のテストでテストクラスもしくは <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal"><span class="pre">setUp()</span></code></a> をスキップする場合に呼ばれます。詳細については、 <a class="reference internal" href="#unittest-skipping"><span class="std std-ref">テストのスキップと意図的な失敗</span></a> を参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.debug">
<code class="descname">debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.debug" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テスト結果を収集せずにテストを実行します。例外が呼び出し元に通知されます。また、テストをデバッガで実行することができます。</p>
</dd></dl>

<p id="assert-methods"><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> クラスは失敗の検査と報告を行う多くのメソッドを提供しています。以下の表は最も一般的に使われるメソッドを列挙しています (より多くのアサートメソッドについては表の下を見てください):</p>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="34%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">確認事項</th>
<th class="head">初出</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertNotEqual(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal"><span class="pre">assertTrue(x)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">True</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal"><span class="pre">assertFalse(x)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">False</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code class="xref py py-meth docutils literal"><span class="pre">assertIs(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">b</span></code></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertIsNot" title="unittest.TestCase.assertIsNot"><code class="xref py py-meth docutils literal"><span class="pre">assertIsNot(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">b</span></code></td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertIsNone" title="unittest.TestCase.assertIsNone"><code class="xref py py-meth docutils literal"><span class="pre">assertIsNone(x)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">None</span></code></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertIsNotNone" title="unittest.TestCase.assertIsNotNone"><code class="xref py py-meth docutils literal"><span class="pre">assertIsNotNone(x)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code></td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertIn" title="unittest.TestCase.assertIn"><code class="xref py py-meth docutils literal"><span class="pre">assertIn(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">a</span> <span class="pre">in</span> <span class="pre">b</span></code></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertNotIn" title="unittest.TestCase.assertNotIn"><code class="xref py py-meth docutils literal"><span class="pre">assertNotIn(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">a</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">b</span></code></td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertIsInstance" title="unittest.TestCase.assertIsInstance"><code class="xref py py-meth docutils literal"><span class="pre">assertIsInstance(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">isinstance(a,</span> <span class="pre">b)</span></code></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertNotIsInstance" title="unittest.TestCase.assertNotIsInstance"><code class="xref py py-meth docutils literal"><span class="pre">assertNotIsInstance(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">not</span> <span class="pre">isinstance(a,</span> <span class="pre">b)</span></code></td>
<td>2.7</td>
</tr>
</tbody>
</table>
<p>(<a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></code></a> と <a class="reference internal" href="#unittest.TestCase.assertRaisesRegexp" title="unittest.TestCase.assertRaisesRegexp"><code class="xref py py-meth docutils literal"><span class="pre">assertRaisesRegexp()</span></code></a> を除く) すべてのアサートメソッドには <em>msg</em> 引数を指定することができ、テストの失敗時のエラーメッセージで使用されます (<a class="reference internal" href="#unittest.TestCase.longMessage" title="unittest.TestCase.longMessage"><code class="xref py py-data docutils literal"><span class="pre">longMessage</span></code></a> も参照してください)。</p>
<dl class="method">
<dt id="unittest.TestCase.assertEqual">
<code class="descname">assertEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>first</em> と <em>second</em> が等しいことをテストします。両者が比較出来ない場合は、テストが失敗します。</p>
<p>さらに、 <em>first</em> と <em>second</em> が厳密に同じ型であり、その型が、list, tuple, dict, set, frozenset もしくは unicode のいずれか、または <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code class="xref py py-meth docutils literal"><span class="pre">addTypeEqualityFunc()</span></code></a> で比較関数が登録されている型の場合には、より有益なデフォルトのエラーメッセージを生成するために、その型特有の比較関数が呼ばれます (<a class="reference internal" href="#type-specific-methods"><span class="std std-ref">list of type-specific methods</span></a> も参照してください)。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span>自動で型特有の比較関数が呼ばれるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertNotEqual">
<code class="descname">assertNotEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>first</em> と <em>second</em> が等しくないことをテストします。両者が比較出来ない場合は、テストが失敗します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertTrue">
<code class="descname">assertTrue</code><span class="sig-paren">(</span><em>expr</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertTrue" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertFalse">
<code class="descname">assertFalse</code><span class="sig-paren">(</span><em>expr</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertFalse" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>expr</em> が真 (偽) であることをテストします。</p>
<p>このメソッドは、<code class="docutils literal"><span class="pre">bool(expr)</span> <span class="pre">is</span> <span class="pre">True</span></code> と等価であり、<code class="docutils literal"><span class="pre">expr</span> <span class="pre">is</span> <span class="pre">True</span></code> と等価ではないことに注意が必要です (後者のためには、<code class="docutils literal"><span class="pre">assertIs(expr,</span> <span class="pre">True)</span></code> が用意されています)。また、専用のメソッドが使用できる場合には、そちらを使用してください (例えば <code class="docutils literal"><span class="pre">assertTrue(a</span> <span class="pre">==</span> <span class="pre">b)</span></code> の代わりに <code class="docutils literal"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></code> を使用してください)。そうすることにより、テスト失敗時のエラーメッセージを詳細に表示することができます。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIs">
<code class="descname">assertIs</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIs" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertIsNot">
<code class="descname">assertIsNot</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNot" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>first</em> と <em>second</em> が同じオブジェクトであること (そうでないこと) をテストします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIsNone">
<code class="descname">assertIsNone</code><span class="sig-paren">(</span><em>expr</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNone" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertIsNotNone">
<code class="descname">assertIsNotNone</code><span class="sig-paren">(</span><em>expr</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNotNone" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>expr</em> が <code class="docutils literal"><span class="pre">None</span></code> であること (および、そうでないこと) をテストします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIn">
<code class="descname">assertIn</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIn" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertNotIn">
<code class="descname">assertNotIn</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotIn" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>first</em> が <em>second</em> に含まれること (そうでないこと) をテストします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIsInstance">
<code class="descname">assertIsInstance</code><span class="sig-paren">(</span><em>obj</em>, <em>cls</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsInstance" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertNotIsInstance">
<code class="descname">assertNotIsInstance</code><span class="sig-paren">(</span><em>obj</em>, <em>cls</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotIsInstance" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>obj</em> が <em>cls</em> のインスタンスであること (あるいはそうでないこと) をテストします (この <em>cls</em> は、 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> が扱うことのできる、クラスもしくはクラスのタプルである必要があります)。正確な型をチェックするためには、 <a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code class="xref py py-func docutils literal"><span class="pre">assertIs(type(obj),</span> <span class="pre">cls)</span></code></a> を使用してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<p>例外と例外発生時の警告を確認するために以下のメソッドを使用することができます:</p>
<table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="36%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">確認事項</th>
<th class="head">初出</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal"><span class="pre">assertRaises(exc,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> raises <em>exc</em></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertRaisesRegexp" title="unittest.TestCase.assertRaisesRegexp"><code class="xref py py-meth docutils literal"><span class="pre">assertRaisesRegexp(exc,</span> <span class="pre">r,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> が <em>exc</em> を raise してメッセージが正規表現 <em>r</em> とマッチすること</td>
<td>2.7</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="unittest.TestCase.assertRaises">
<code class="descname">assertRaises</code><span class="sig-paren">(</span><em>exception</em>, <em>callable</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRaises" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">assertRaises</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span></dt>
<dd><p><em>callable</em> を呼び出した時に例外が発生することをテストします。 <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></code></a> で指定した位置パラメータとキーワードパラメータを該当メソッドに渡します。 <em>exception</em> が投げられた場合にテストが成功します。また、他の例外が投げられた場合はエラー、例外が投げられなかった場合は失敗になります。複数の例外をキャッチする場合には、例外クラスのタプルを <em>exception</em> に指定してください。</p>
<p><em>exception</em> 引数のみが渡された場合には、コンテキストマネージャが返されます。これにより関数名を渡す形式ではなく、インラインでテスト対象のコードを書くことができます。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">()</span>
</pre></div>
</div>
<p>このコンテキストマネージャは <code class="xref py py-attr docutils literal"><span class="pre">exception</span></code> で指定されたオブジェクトを格納します。これにより、例外発生時の詳細な確認をおこなうことができます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>

<span class="n">the_exception</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">exception</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">the_exception</span><span class="o">.</span><span class="n">error_code</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></code></a> がコンテキストマネージャとして使えるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertRaisesRegexp">
<code class="descname">assertRaisesRegexp</code><span class="sig-paren">(</span><em>exception</em>, <em>regexp</em>, <em>callable</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRaisesRegexp" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">assertRaisesRegexp</code><span class="sig-paren">(</span><em>exception</em>, <em>regexp</em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></code></a> と同等ですが、例外の文字列表現が <em>regexp</em> にマッチすることもテストします。 <em>regexp</em> は正規表現オブジェクトか、 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal"><span class="pre">re.search()</span></code></a> が扱える正規表現が書かれた文字列である必要があります。例えば以下のようになります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegexp</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;invalid literal for.*XYZ&#39;$&quot;</span><span class="p">,</span>
                        <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>もしくは:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegexp</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s1">&#39;literal&#39;</span><span class="p">):</span>
   <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<p>さらに特有の確認を行うために以下のメソッドが用意されています:</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="38%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">確認事項</th>
<th class="head">初出</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertAlmostEqual(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">==</span> <span class="pre">0</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertNotAlmostEqual(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">!=</span> <span class="pre">0</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertGreater" title="unittest.TestCase.assertGreater"><code class="xref py py-meth docutils literal"><span class="pre">assertGreater(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertGreaterEqual" title="unittest.TestCase.assertGreaterEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertGreaterEqual(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></code></td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertLess" title="unittest.TestCase.assertLess"><code class="xref py py-meth docutils literal"><span class="pre">assertLess(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertLessEqual" title="unittest.TestCase.assertLessEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertLessEqual(a,</span> <span class="pre">b)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></code></td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertRegexpMatches" title="unittest.TestCase.assertRegexpMatches"><code class="xref py py-meth docutils literal"><span class="pre">assertRegexpMatches(s,</span> <span class="pre">r)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">r.search(s)</span></code></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertNotRegexpMatches" title="unittest.TestCase.assertNotRegexpMatches"><code class="xref py py-meth docutils literal"><span class="pre">assertNotRegexpMatches(s,</span> <span class="pre">r)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">not</span> <span class="pre">r.search(s)</span></code></td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertItemsEqual" title="unittest.TestCase.assertItemsEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertItemsEqual(a,</span> <span class="pre">b)</span></code></a></td>
<td>意味的に <code class="docutils literal"><span class="pre">sorted(a)</span> <span class="pre">==</span> <span class="pre">sorted(b)</span></code> ですが、ハッシュ不能オブジェクトでも動作</td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertDictContainsSubset" title="unittest.TestCase.assertDictContainsSubset"><code class="xref py py-meth docutils literal"><span class="pre">assertDictContainsSubset(a,</span> <span class="pre">b)</span></code></a></td>
<td><em>a</em> の全てのキー/値ペアが <em>b</em> に存在すること</td>
<td>2.7</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="unittest.TestCase.assertAlmostEqual">
<code class="descname">assertAlmostEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>places=7</em>, <em>msg=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertAlmostEqual" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertNotAlmostEqual">
<code class="descname">assertNotAlmostEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>places=7</em>, <em>msg=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotAlmostEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>first</em> と <em>second</em> が近似的に等しい (等しくない) ことをテストします。この比較は、<em>places</em> (デフォルト7) で指定した小数位で丸めた差分をゼロと比べることでおこないます。これらのメソッドは、 (<a class="reference internal" href="functions.html#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round()</span></code></a> と同様に) <em>小数位</em> を指定するのであって、<em>有効桁数</em> を指定するのではないことに注意してください。</p>
<p><em>places</em> の代わりに <em>delta</em> が渡された場合には、<em>first</em> と <em>second</em> の差分が <em>delta</em> 以下 (以上) であることをテストします。</p>
<p><em>delta</em> と <em>places</em> の両方が指定された場合は <code class="docutils literal"><span class="pre">TypeError</span></code> が投げられます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertAlmostEqual()</span></code></a> は、オブジェクトが等しい場合には自動で近似的に等しいとみなすようになりました。 <a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertNotAlmostEqual()</span></code></a> は、オブジェクトが等しい場合には自動的に失敗するようになりました。 <em>delta</em> 引数が追加されました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertGreater">
<code class="descname">assertGreater</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertGreater" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertGreaterEqual">
<code class="descname">assertGreaterEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertGreaterEqual" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertLess">
<code class="descname">assertLess</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLess" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertLessEqual">
<code class="descname">assertLessEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLessEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>first</em> が <em>second</em> と比べて、メソッド名に対応して &gt;, &gt;=, &lt; もしくは &lt;= であることをテストします。そうでない場合はテストが失敗します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">assertGreaterEqual</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">AssertionError: &quot;3&quot; unexpectedly not greater than or equal to &quot;4&quot;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertRegexpMatches">
<code class="descname">assertRegexpMatches</code><span class="sig-paren">(</span><em>text</em>, <em>regexp</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRegexpMatches" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>regexp</em> の検索が <em>text</em> とマッチすることをテストします。テスト失敗時には、エラーメッセージにパターンと <em>text</em> が表示されます (もしくは、パターンと意図しないかたちでマッチした <em>text</em> の一部が表示されます)。 <em>regexp</em> は正規表現オブジェクトか、 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal"><span class="pre">re.search()</span></code></a> が扱える正規表現が書かれた文字列である必要があります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertNotRegexpMatches">
<code class="descname">assertNotRegexpMatches</code><span class="sig-paren">(</span><em>text</em>, <em>regexp</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotRegexpMatches" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>regexp</em> の検索が <em>text</em> とマッチしないことをテストします。テスト失敗時には、エラーメッセージにマッチしたパターンと <em>text</em> が表示されます。 <em>regexp</em> は正規表現オブジェクトか、 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal"><span class="pre">re.search()</span></code></a> が扱える正規表現が書かれた文字列である必要があります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertItemsEqual">
<code class="descname">assertItemsEqual</code><span class="sig-paren">(</span><em>actual</em>, <em>expected</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertItemsEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンス <em>expected</em> が <em>actual</em> と同じ要素を含んでいることをテストします。要素の順序はテスト結果に影響しません。要素が含まれていない場合には、シーケンスの差分がエラーメッセージとして表示されます。</p>
<p><em>actual</em> と <em>expected</em> の比較では、重複した要素は無視 <em>されません</em> 。両者に同じ数の要素が含まれていることを検証します。このメソッドは <code class="docutils literal"><span class="pre">assertEqual(sorted(expected),</span> <span class="pre">sorted(actual))</span></code> と同等に振る舞うことに加えて、ハッシュ化できないオブジェクトのシーケンスでも動作します。</p>
<p>Python 3 ではこのメソッドは <code class="docutils literal"><span class="pre">assertCountEqual</span></code> と名付けられています。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertDictContainsSubset">
<code class="descname">assertDictContainsSubset</code><span class="sig-paren">(</span><em>expected</em>, <em>actual</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertDictContainsSubset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書 <em>actual</em> のキー/値ペアが <em>expected</em> のスーパーセットになっているかどうかをテストします。そうなっていない場合には、欠けたキーと不一致の値を一覧するエラーメッセージが生成されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.2 で撤廃.</span></p>
</div>
</dd></dl>

<p id="type-specific-methods"><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></code></a> メソッドは、同じ型のオブジェクトの等価性確認のために、型ごとに特有のメソッドにディスパッチします。これらのメソッドは、ほとんどの組み込み型用のメソッドは既に実装されています。さらに、 <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code class="xref py py-meth docutils literal"><span class="pre">addTypeEqualityFunc()</span></code></a> を使う事で新たなメソッドを登録することができます:</p>
<dl class="method">
<dt id="unittest.TestCase.addTypeEqualityFunc">
<code class="descname">addTypeEqualityFunc</code><span class="sig-paren">(</span><em>typeobj</em>, <em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addTypeEqualityFunc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></code></a> で呼び出される型特有のメソッドを登録します。登録するメソッドは、比較する2つのオブジェクトの型が厳密に <em>typeobj</em> と同じ (サブクラスでもいけません) の場合に等価性を確認します。 <em>function</em>  は <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></code></a> と同様に、2つの位置固定引数と、3番目に msg=None のキーワード引数を取れる必要があります。このメソッドは、始めの2つに指定したパラメータ間の差分を検出した時に <a class="reference internal" href="#unittest.TestCase.failureException" title="unittest.TestCase.failureException"><code class="xref py py-data docutils literal"><span class="pre">self.failureException(msg)</span></code></a> の例外を投げる必要があります。この例外を投げる際は、出来る限り、エラーの内容が分かる有用な情報と差分の詳細をエラーメッセージに含めてください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></code></a> が自動的に呼び出す型特有のメソッドの概要を以下の表示に記載しています。これらのメソッドは通常は直接呼び出す必要がないことに注意が必要です。</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="35%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">比較の対象</th>
<th class="head">初出</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertMultiLineEqual(a,</span> <span class="pre">b)</span></code></a></td>
<td>文字列</td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertSequenceEqual(a,</span> <span class="pre">b)</span></code></a></td>
<td>シーケンス</td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertListEqual(a,</span> <span class="pre">b)</span></code></a></td>
<td>リスト</td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertTupleEqual(a,</span> <span class="pre">b)</span></code></a></td>
<td>タプル</td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertSetEqual" title="unittest.TestCase.assertSetEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertSetEqual(a,</span> <span class="pre">b)</span></code></a></td>
<td>set または frozenset</td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertDictEqual(a,</span> <span class="pre">b)</span></code></a></td>
<td>辞書</td>
<td>2.7</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="unittest.TestCase.assertMultiLineEqual">
<code class="descname">assertMultiLineEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertMultiLineEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Test that the multiline string <em>first</em> is equal to the string <em>second</em>.
When not equal a diff of the two strings highlighting the differences
will be included in the error message. This method is used by default
when comparing Unicode strings with <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertSequenceEqual">
<code class="descname">assertSequenceEqual</code><span class="sig-paren">(</span><em>seq1</em>, <em>seq2</em>, <em>msg=None</em>, <em>seq_type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertSequenceEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2つのシーケンスが等しいことをテストします。 <em>seq_type</em> が指定された場合、 <em>seq1</em> と <em>seq2</em> が <em>seq_type</em> のインスタンスで無い場合にはテストが失敗します。シーケンスどうしが異なる場合には、両者の差分がエラーメッセージに表示されます。</p>
<p>このメソッドは直接 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></code></a> からは呼ばれませんが、 <a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertListEqual()</span></code></a> と <a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertTupleEqual()</span></code></a> の実装で使われています。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertListEqual">
<code class="descname">assertListEqual</code><span class="sig-paren">(</span><em>list1</em>, <em>list2</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertListEqual" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertTupleEqual">
<code class="descname">assertTupleEqual</code><span class="sig-paren">(</span><em>tuple1</em>, <em>tuple2</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertTupleEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2つのリストまたはタプルが等しいかどうかをテストします。等しくない場合には、両者の差分を表示します。2つのパラメータの型が異なる場合にはテストがエラーになります。このメソッドは、デフォルトで、 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></code></a> が list または tuple を比較するときに自動的に使用します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertSetEqual">
<code class="descname">assertSetEqual</code><span class="sig-paren">(</span><em>set1</em>, <em>set2</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertSetEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2つのセットが等しいかどうかをテストします。等しくない場合には、両者の差分を表示します。このメソッドは、デフォルトで、 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></code></a> が set もしくは frozenset を比較するときに自動的に使用します。</p>
<p><em>set1</em> or <em>set2</em> のいずれかに <code class="xref py py-meth docutils literal"><span class="pre">set.difference()</span></code> メソッドが無い場合にはテストは失敗します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertDictEqual">
<code class="descname">assertDictEqual</code><span class="sig-paren">(</span><em>expected</em>, <em>actual</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertDictEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2つの辞書が等しいかどうかをテストします。等しくない場合には、両者の差分を表示します。このメソッドは、デフォルトで、 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></code></a> が dict を比較するときに自動的に使用します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<p id="other-methods-and-attrs">最後に、 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> の残りのメソッドと属性を紹介します:</p>
<dl class="method">
<dt id="unittest.TestCase.fail">
<code class="descname">fail</code><span class="sig-paren">(</span><em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.fail" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>無条件にテストを失敗させます。エラーメッセージの表示に、<em>msg</em> または <code class="docutils literal"><span class="pre">None</span></code> が使われます。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestCase.failureException">
<code class="descname">failureException</code><a class="headerlink" href="#unittest.TestCase.failureException" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="test.html#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-meth docutils literal"><span class="pre">test()</span></code></a> メソッドが送出する例外を指定するクラス属性です。例えばテストフレームワークで追加情報を付した特殊な例外が必要になる場合、この例外のサブクラスとして作成します。この属性の初期値は <a class="reference internal" href="exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code></a> です。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestCase.longMessage">
<code class="descname">longMessage</code><a class="headerlink" href="#unittest.TestCase.longMessage" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性に <code class="docutils literal"><span class="pre">True</span></code> が設定された場合、 <a class="reference internal" href="#assert-methods"><span class="std std-ref">assert methods</span></a> で指定したすべての明示的な失敗メッセージが、通常の失敗メッセージに追加されます。通常の失敗メッセージには、オブジェクトに関する有用な情報が含まれています。例えば、 assertEqual は異なるオブジェクトの repr を表示します。この属性を <code class="docutils literal"><span class="pre">True</span></code> にすることで、カスタマイズしたエラーメッセージを通常のメッセージに追加することができます。</p>
<p>この属性はデフォルトで <code class="docutils literal"><span class="pre">False</span></code> になっていて、カスタムメッセージが渡されても表示しないようになっています。</p>
<p>アサートメソッドを呼び出す前に、インスタンス属性として <code class="docutils literal"><span class="pre">True</span></code> または <code class="docutils literal"><span class="pre">False</span></code> を指定することで、この設定をオーバーライドすることができます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestCase.maxDiff">
<code class="descname">maxDiff</code><a class="headerlink" href="#unittest.TestCase.maxDiff" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性は、アサーションメソッドが失敗をレポートする時に表示する差分の長さをコントロールします。デフォルトは 80*8 文字です。この属性が影響するメソッドは、 <a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertSequenceEqual()</span></code></a> (およびこのメソッドに委譲するシーケンス比較メソッド)、 <a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertDictEqual()</span></code></a> と <a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertMultiLineEqual()</span></code></a> です。</p>
<p><code class="docutils literal"><span class="pre">maxDiff</span></code> を <code class="docutils literal"><span class="pre">None</span></code> に設定すると差分表示の上限がなくなります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<p>テストフレームワークは、テスト情報を収集するために以下のメソッドを使用します:</p>
<dl class="method">
<dt id="unittest.TestCase.countTestCases">
<code class="descname">countTestCases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.countTestCases" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストオブジェクトに含まれるテストの数を返します。 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> インスタンスは常に <code class="docutils literal"><span class="pre">1</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.defaultTestResult">
<code class="descname">defaultTestResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.defaultTestResult" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このテストケースクラスで使われるテスト結果クラスのインスタンスを (もし <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドに他の結果インスタンスが提供されないならば) 返します。</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> インスタンスに対しては、いつも <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal"><span class="pre">TestResult</span></code></a> のインスタンスですので、 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> のサブクラスでは必要に応じてこのメソッドをオーバライドしてください。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.id">
<code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.id" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストケースを特定する文字列を返します。通常、<em>id</em> はモジュール名・クラス名を含む、テストメソッドのフルネームを指定します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.shortDescription">
<code class="descname">shortDescription</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.shortDescription" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストの説明を一行分、または説明がない場合には <code class="docutils literal"><span class="pre">None</span></code> を返します。デフォルトでは、テストメソッドの docstring の先頭の一行、または <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.addCleanup">
<code class="descname">addCleanup</code><span class="sig-paren">(</span><em>function</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addCleanup" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></code></a> の後に呼び出される関数を追加します。この関数はリソースのクリーンアップのために使用します。追加された関数は、追加された順と逆の順番で呼び出されます (LIFO)。 <a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal"><span class="pre">addCleanup()</span></code></a> に渡された引数とキーワード引数が追加された関数にも渡されます。</p>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal"><span class="pre">setUp()</span></code></a> が失敗した場合、つまり <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></code></a> が呼ばれなかった場合でも、追加されたクリーンアップ関数は呼び出されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.doCleanups">
<code class="descname">doCleanups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.doCleanups" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></code></a> の後、もしくは、 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal"><span class="pre">setUp()</span></code></a> が例外を投げた場合は <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal"><span class="pre">setUp()</span></code></a> の後に、無条件で呼ばれます。</p>
<p>このメソッドは、 <a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal"><span class="pre">addCleanup()</span></code></a> で追加された関数を呼び出す責務を担います。もし、クリーンアップ関数を <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></code></a> より前に呼び出す必要がある場合には、 <a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code class="xref py py-meth docutils literal"><span class="pre">doCleanups()</span></code></a> を明示的に呼び出してください。</p>
<p><a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code class="xref py py-meth docutils literal"><span class="pre">doCleanups()</span></code></a> は、どこで呼び出されても、クリーンアップ関数をスタックから削除して実行します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="unittest.FunctionTestCase">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">FunctionTestCase</code><span class="sig-paren">(</span><em>testFunc</em>, <em>setUp=None</em>, <em>tearDown=None</em>, <em>description=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.FunctionTestCase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスでは <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> インターフェースの内、テストランナーがテストを実行するためのインターフェースだけを実装しており、テスト結果のチェックやレポートに関するメソッドは実装していません。既存のテストコードを <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> によるテストフレームワークに組み込むために使用します。</p>
</dd></dl>

<div class="section" id="deprecated-aliases">
<h4>25.3.7.1.1. 廃止予定のエイリアス<a class="headerlink" href="#deprecated-aliases" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>歴史的な経緯で、 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> のいくつかのエイリアスは廃止予定となりました。以下の表に、廃止予定のエイリアスをまとめます:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">メソッド名</th>
<th class="head">廃止予定のエリアス</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></code></a></td>
<td>failUnlessEqual, assertEquals</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertNotEqual()</span></code></a></td>
<td>failIfEqual</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal"><span class="pre">assertTrue()</span></code></a></td>
<td>failUnless, assert_</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal"><span class="pre">assertFalse()</span></code></a></td>
<td>failIf</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></code></a></td>
<td>failUnlessRaises</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertAlmostEqual()</span></code></a></td>
<td>failUnlessAlmostEqual</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal"><span class="pre">assertNotAlmostEqual()</span></code></a></td>
<td>failIfAlmostEqual</td>
</tr>
</tbody>
</table>
<div class="deprecated">
<p><span class="versionmodified">バージョン 2.7 で撤廃: </span>この表の「廃止予定」だったものが実際に廃止されました。</p>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="grouping-tests">
<span id="testsuite-objects"></span><h3>25.3.7.2. テストのグルーピング<a class="headerlink" href="#grouping-tests" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="class">
<dt id="unittest.TestSuite">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">TestSuite</code><span class="sig-paren">(</span><em>tests=()</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスは、個々のテストケースやテストスイートの集約を示します。通常のテストケースと同じようにテストランナーで実行するためのインタフェースを備えています。 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> インスタンスを実行することはスイートの繰り返しを使って個々のテストを実行することと同じです。</p>
<p>引数 <em>tests</em> が指定された場合、それはテストケースに亘る繰り返し可能オブジェクトまたは内部でスイートを組み立てるための他のテストスイートでなければなりません。後からテストケースやスイートをコレクションに付け加えるためのメソッドも提供されています。</p>
<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> は <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> オブジェクトのように振る舞います。違いは、スイートにはテストを実装しない点にあります。代わりに、テストをまとめてグループ化して、同時に実行します。 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> のインスタンスにテスト追加するためのメソッドが用意されています:</p>
<dl class="method">
<dt id="unittest.TestSuite.addTest">
<code class="descname">addTest</code><span class="sig-paren">(</span><em>test</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.addTest" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> 又は <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> のインスタンスをスイートに追加します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.addTests">
<code class="descname">addTests</code><span class="sig-paren">(</span><em>tests</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.addTests" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イテラブル <em>tests</em> に含まれる全ての <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> 又は <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> のインスタンスをスイートに追加します。</p>
<p>このメソッドは <em>tests</em> 上のイテレーションをしながらそれぞれの要素に <a class="reference internal" href="#unittest.TestSuite.addTest" title="unittest.TestSuite.addTest"><code class="xref py py-meth docutils literal"><span class="pre">addTest()</span></code></a> を呼び出すのと等価です。</p>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> クラスは <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> と以下のメソッドを共有します:</p>
<dl class="method">
<dt id="unittest.TestSuite.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.run" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スイート内のテストを実行し、結果を <em>result</em> で指定した結果オブジェクトに収集します。 <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal"><span class="pre">TestCase.run()</span></code></a> と異なり、 <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal"><span class="pre">TestSuite.run()</span></code></a> では必ず結果オブジェクトを指定する必要があります。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.debug">
<code class="descname">debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.debug" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このスイートに関連づけられたテストを結果を収集せずに実行します。これによりテストで送出された例外は呼び出し元に伝わるようになり、デバッガの下でのテスト実行をサポートできるようになります。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.countTestCases">
<code class="descname">countTestCases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.countTestCases" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このテストオブジェクトによって表現されるテストの数を返します。これには個別のテストと下位のスイートも含まれます。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.__iter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> でグループ化されたテストはイテレータでアクセスできます。サブクラスは <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> をオーバーライドすることで、テストへのアクセスを定義します。1つのメソッド内でこのメソッドは何度も呼ばれる可能性があることに注意してください (例えば、テスト数のカウントと等価性の比較)。そのため、イテレーションを繰り返しても同じテストを返すように実装してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span>以前のバージョンでは <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> はイテレータではなく、直接テストにアクセスしていました。そのため、 <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> をオーバーラードしてもテストにアクセスできませんでした。</p>
</div>
</dd></dl>

<p>通常、 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> の <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドは <code class="xref py py-class docutils literal"><span class="pre">TestRunner</span></code> が起動するため、ユーザが直接実行する必要はありません。</p>
</dd></dl>

</div>
<div class="section" id="loading-and-running-tests">
<h3>25.3.7.3. テストのロードと起動<a class="headerlink" href="#loading-and-running-tests" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="class">
<dt id="unittest.TestLoader">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">TestLoader</code><a class="headerlink" href="#unittest.TestLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal"><span class="pre">TestLoader</span></code></a> クラスはクラスとモジュールからテストスイートを生成します。通常、このクラスのインスタンスを明示的に生成する必要はありません。 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> モジュールの <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code class="xref py py-data docutils literal"><span class="pre">unittest.defaultTestLoader</span></code></a> を共用インスタンスとして使用することができます。 しかし、このクラスのサブクラスやインスタンスで、属性をカスタマイズすることができます。</p>
<p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal"><span class="pre">TestLoader</span></code></a> のオブジェクトには以下のメソッドがあります:</p>
<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromTestCase">
<code class="descname">loadTestsFromTestCase</code><span class="sig-paren">(</span><em>testCaseClass</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromTestCase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> の派生クラス <code class="xref py py-class docutils literal"><span class="pre">testCaseClass</span></code> に含まれる全テストケースのスイートを返します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromModule">
<code class="descname">loadTestsFromModule</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromModule" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定したモジュールに含まれる全テストケースのスイートを返します。このメソッドは <em>module</em> 内の <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> 派生クラスを検索し、見つかったクラスのテストメソッドごとにクラスのインスタンスを作成します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> クラスを基底クラスとしてクラス階層を構築すると fixture や補助的な関数をうまく共用することができますが、基底クラスに直接インスタンス化できないテストメソッドがあると、この <code class="xref py py-meth docutils literal"><span class="pre">loadTestsFromModule()</span></code> を使うことができません。この場合でも、 fixture が全て別々で定義がサブクラスにある場合は使用することができます。</p>
</div>
<p>モジュールが <code class="docutils literal"><span class="pre">load_tests</span></code> 関数を用意している場合、この関数がテストのロードに使われます。これによりテストのロードをカスタマイズできます。これが <a class="reference internal" href="#load-tests-protocol">load_tests プロトコル</a> です。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span><code class="docutils literal"><span class="pre">load_tests</span></code> のサポートが追加されました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromName">
<code class="descname">loadTestsFromName</code><span class="sig-paren">(</span><em>name</em>, <em>module=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromName" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列で指定される全テストケースを含むスイートを返します。</p>
<p><em>name</em> には &quot;ドット修飾名&quot; でモジュールかテストケースクラス、テストケースクラス内のメソッド、 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> インスタンスまたは <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> か <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> のインスタンスを返す呼び出し可能オブジェクトを指定します。このチェックはここで挙げた順番に行なわれます。すなわち、候補テストケースクラス内のメソッドは「呼び出し可能オブジェクト」としてではなく「テストケースクラス内のメソッド」として拾い出されます。</p>
<p>例えば <code class="xref py py-mod docutils literal"><span class="pre">SampleTests</span></code> モジュールに <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> から派生した <code class="xref py py-class docutils literal"><span class="pre">SampleTestCase</span></code> クラスがあり、 <code class="xref py py-class docutils literal"><span class="pre">SampleTestCase</span></code> にはテストメソッド <code class="xref py py-meth docutils literal"><span class="pre">test_one()</span></code> ・ <code class="xref py py-meth docutils literal"><span class="pre">test_two()</span></code> ・ <code class="xref py py-meth docutils literal"><span class="pre">test_three()</span></code> があるとします。この場合、 <em>name</em> に <code class="docutils literal"><span class="pre">'SampleTests.SampleTestCase'</span></code> と指定すると、 <code class="xref py py-class docutils literal"><span class="pre">SampleTestCase</span></code> の三つのテストメソッドを実行するテストスイートが作成されます。 <code class="docutils literal"><span class="pre">'SampleTests.SampleTestCase.test_two'</span></code> と指定すれば、 <code class="xref py py-meth docutils literal"><span class="pre">test_two()</span></code> だけを実行するテストスイートが作成されます。インポートされていないモジュールやパッケージ名を含んだ名前を指定した場合は自動的にインポートされます。</p>
<p>また、<em>module</em> を指定した場合、<em>module</em> 内の <em>name</em> を取得します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromNames">
<code class="descname">loadTestsFromNames</code><span class="sig-paren">(</span><em>names</em>, <em>module=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromNames" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestLoader.loadTestsFromName" title="unittest.TestLoader.loadTestsFromName"><code class="xref py py-meth docutils literal"><span class="pre">loadTestsFromName()</span></code></a> と同じですが、名前を一つだけ指定するのではなく、複数の名前のシーケンスを指定する事ができます。戻り値は <em>names</em> 中の名前で指定されるテスト全てを含むテストスイートです。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.getTestCaseNames">
<code class="descname">getTestCaseNames</code><span class="sig-paren">(</span><em>testCaseClass</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.getTestCaseNames" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>testCaseClass</em> 中の全てのメソッド名を含むソート済みシーケンスを返します。 <em>testCaseClass</em> は <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> のサブクラスでなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.discover">
<code class="descname">discover</code><span class="sig-paren">(</span><em>start_dir</em>, <em>pattern='test*.py'</em>, <em>top_level_dir=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.discover" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された開始ディレクトリからサブディレクトリに再帰することですべてのテストモジュールを検索し、それらを含む TestSuite オブジェクトを返します。<em>pattern</em> にマッチしたテストファイルだけがロードの対象になります。 (シェルスタイルのパターンマッチングが使われます)。その中で、インポート可能なもジュール (つまり Python の識別子として有効であるということです) がロードされます。</p>
<p>すべてのテストモジュールはプロジェクトのトップレベルからインポート可能である必要があります。開始ディレクトリがトップレベルディレクトリでない場合は、トップレベルディレクトリが分離できなくてはいけません。</p>
<p>例えば、シンタックスエラーなどで、モジュールのインポートに失敗した場合、エラーが記録され、ディスカバリ自体は続けられます。</p>
<p>テストパッケージ名 (<code class="file docutils literal"><span class="pre">__init__.py</span></code> の置かれたディレクトリ名) がパターンにマッチした場合、 <code class="docutils literal"><span class="pre">load_tests</span></code> 関数がチェックされます。この関数が存在している場合、この関数に <em>loader</em>, <em>tests</em>, <em>pattern</em> が渡され呼び出されます。</p>
<p>load_tests が存在して、ディスカバリがパッケージ内を再帰的な検索を続けている途中で <em>ない</em> 場合、 <code class="docutils literal"><span class="pre">load_tests</span></code> はそのパッケージ内の全てのテストをロードする責務を担います。</p>
<p>意図的にパターンはローダの属性として保持されないようになっています。それにより、パッケージが自分自身のディスカバリを続ける事ができます。<em>top_level_dir</em> は保持されるため、<code class="docutils literal"><span class="pre">load_tests</span></code> はこの引数を <code class="docutils literal"><span class="pre">loader.discover()</span></code> に渡す必要はありません。</p>
<p><em>start_dir</em> はドット付のモジュール名でもディレクトリでも構いません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<p>以下の属性は、サブクラス化またはインスタンスの属性値を変更して <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal"><span class="pre">TestLoader</span></code></a> をカスタマイズする場合に使用します:</p>
<dl class="attribute">
<dt id="unittest.TestLoader.testMethodPrefix">
<code class="descname">testMethodPrefix</code><a class="headerlink" href="#unittest.TestLoader.testMethodPrefix" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストメソッドの名前と判断されるメソッド名の接頭語を示す文字列。デフォルト値は <code class="docutils literal"><span class="pre">'test'</span></code> です。</p>
<p>この値は <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal"><span class="pre">getTestCaseNames()</span></code></a> と全ての <code class="xref py py-meth docutils literal"><span class="pre">loadTestsFrom*()</span></code> メソッドに影響を与えます。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestLoader.sortTestMethodsUsing">
<code class="descname">sortTestMethodsUsing</code><a class="headerlink" href="#unittest.TestLoader.sortTestMethodsUsing" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal"><span class="pre">getTestCaseNames()</span></code></a> および全ての <code class="xref py py-meth docutils literal"><span class="pre">loadTestsFrom*()</span></code> メソッドでメソッド名をソートする際に使用する比較関数。デフォルト値は組み込み関数 <a class="reference internal" href="functions.html#cmp" title="cmp"><code class="xref py py-func docutils literal"><span class="pre">cmp()</span></code></a> です。ソートを行なわないようにこの属性に <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を指定することもできます。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestLoader.suiteClass">
<code class="descname">suiteClass</code><a class="headerlink" href="#unittest.TestLoader.suiteClass" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストのリストからテストスイートを構築する呼び出し可能オブジェクト。メソッドを持つ必要はありません。デフォルト値は <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> です。</p>
<p>この値は全ての <code class="xref py py-meth docutils literal"><span class="pre">loadTestsFrom*()</span></code> メソッドに影響を与えます。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="unittest.TestResult">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">TestResult</code><a class="headerlink" href="#unittest.TestResult" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスはどのテストが成功しどのテストが失敗したかという情報を収集するのに使います。</p>
<p><a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal"><span class="pre">TestResult</span></code></a> は、複数のテスト結果を記録します。 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> クラスと <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> クラスのテスト結果を正しく記録しますので、テスト開発者が独自にテスト結果を管理する処理を開発する必要はありません。</p>
<p><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> を利用したテストフレームワークでは、 <code class="xref py py-meth docutils literal"><span class="pre">TestRunner.run()</span></code> が返す <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal"><span class="pre">TestResult</span></code></a> インスタンスを参照し、テスト結果をレポートします。</p>
<p><a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal"><span class="pre">TestResult</span></code></a> インスタンスの以下の属性は、テストの実行結果を検査する際に使用することができます:</p>
<dl class="attribute">
<dt id="unittest.TestResult.errors">
<code class="descname">errors</code><a class="headerlink" href="#unittest.TestResult.errors" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> と例外のトレースバック情報をフォーマットした文字列の 2 要素タプルからなるリスト。それぞれのタプルは予想外の例外を送出したテストに対応します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.2 で変更: </span><a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></code></a> の結果ではなく、フォーマットしたトレースバックを保存するようにしました。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.failures">
<code class="descname">failures</code><a class="headerlink" href="#unittest.TestResult.failures" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> と例外のトレースバック情報をフォーマットした文字列の 2 要素タプルからなるリスト。それぞれのタプルは <code class="xref py py-meth docutils literal"><span class="pre">TestCase.assert*()</span></code> メソッドを使って見つけ出した失敗に対応します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.2 で変更: </span><a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></code></a> の結果ではなく、フォーマットしたトレースバックを保存するようにしました。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.skipped">
<code class="descname">skipped</code><a class="headerlink" href="#unittest.TestResult.skipped" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> インスタンスと理由の文字列の2要素タプルからなるリストを保持します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.expectedFailures">
<code class="descname">expectedFailures</code><a class="headerlink" href="#unittest.TestResult.expectedFailures" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> と例外のトレースバック情報をフォーマットした文字列の 2 要素タプルからなるリスト。それぞれのタプルは意図した失敗に対応します。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.unexpectedSuccesses">
<code class="descname">unexpectedSuccesses</code><a class="headerlink" href="#unittest.TestResult.unexpectedSuccesses" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>意図した失敗のマークが付いていながら成功してしまった <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> のインスタンスのリスト。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.shouldStop">
<code class="descname">shouldStop</code><a class="headerlink" href="#unittest.TestResult.shouldStop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">True</span></code> が設定されると <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal"><span class="pre">stop()</span></code></a> によりテストの実行が停止します。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.testsRun">
<code class="descname">testsRun</code><a class="headerlink" href="#unittest.TestResult.testsRun" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これまでに実行したテストの総数です。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.buffer">
<code class="descname">buffer</code><a class="headerlink" href="#unittest.TestResult.buffer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">True</span></code> が設定されると、 <code class="docutils literal"><span class="pre">sys.stdout</span></code> と <code class="docutils literal"><span class="pre">sys.stderr</span></code> は、 <a class="reference internal" href="#unittest.TestResult.startTest" title="unittest.TestResult.startTest"><code class="xref py py-meth docutils literal"><span class="pre">startTest()</span></code></a> から <a class="reference internal" href="#unittest.TestResult.stopTest" title="unittest.TestResult.stopTest"><code class="xref py py-meth docutils literal"><span class="pre">stopTest()</span></code></a> が呼ばれるまでの間バッファリングされます。実際に、結果が <code class="docutils literal"><span class="pre">sys.stdout</span></code> と <code class="docutils literal"><span class="pre">sys.stderr</span></code> に出力されるのは、テストが失敗するかエラーが発生した時になります。表示の際には、全ての失敗 / エラーメッセージが表示されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.failfast">
<code class="descname">failfast</code><a class="headerlink" href="#unittest.TestResult.failfast" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">True</span></code> が設定されると、 <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal"><span class="pre">stop()</span></code></a> が始めの失敗もしくはエラーの時に呼び出され、テストの実行が終了します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.wasSuccessful">
<code class="descname">wasSuccessful</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.wasSuccessful" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これまでに実行したテストが全て成功していれば <code class="docutils literal"><span class="pre">True</span></code> を、それ以外なら <code class="docutils literal"><span class="pre">False</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドを呼び出して <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal"><span class="pre">TestResult</span></code></a> の <a class="reference internal" href="#unittest.TestResult.shouldStop" title="unittest.TestResult.shouldStop"><code class="xref py py-attr docutils literal"><span class="pre">shouldStop</span></code></a> 属性に <code class="docutils literal"><span class="pre">True</span></code> をセットすることで、実行中のテストは中断しなければならないというシグナルを送ることができます。 <code class="xref py py-class docutils literal"><span class="pre">TestRunner</span></code> オブジェクトはこのフラグを尊重してそれ以上のテストを実行することなく復帰しなければなりません。</p>
<p>たとえばこの機能は、ユーザのキーボード割り込みを受け取って <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code class="xref py py-class docutils literal"><span class="pre">TextTestRunner</span></code></a> クラスがテストフレームワークを停止させるのに使えます。 <code class="xref py py-class docutils literal"><span class="pre">TestRunner</span></code> の実装を提供する対話的なツールでも同じように使用することができます。</p>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal"><span class="pre">TestResult</span></code></a> クラスの以下のメソッドは内部データ管理用のメソッドですが、対話的にテスト結果をレポートするテストツールを開発する場合などにはサブクラスで拡張することができます。</p>
<dl class="method">
<dt id="unittest.TestResult.startTest">
<code class="descname">startTest</code><span class="sig-paren">(</span><em>test</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.startTest" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>test</em> を実行する直前に呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.stopTest">
<code class="descname">stopTest</code><span class="sig-paren">(</span><em>test</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stopTest" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>test</em> の実行直後に、テスト結果に関わらず呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.startTestRun">
<code class="descname">startTestRun</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.startTestRun" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>全てのテストが実行される前に一度だけ実行されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.stopTestRun">
<code class="descname">stopTestRun</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stopTestRun" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>全てのテストが実行された後に一度だけ実行されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addError">
<code class="descname">addError</code><span class="sig-paren">(</span><em>test</em>, <em>err</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テスト <em>test</em> 実行中に、想定外の例外が発生した場合に呼び出されます。 <em>err</em> は <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></code></a> が返すタプル <code class="docutils literal"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code> です。</p>
<p>デフォルトの実装では、タプル、 <code class="docutils literal"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> をインスタンスの <a class="reference internal" href="#unittest.TestResult.errors" title="unittest.TestResult.errors"><code class="xref py py-attr docutils literal"><span class="pre">errors</span></code></a> 属性に追加します。ここで、 <em>formatted_err</em> は、 <em>err</em> から導出される、整形されたトレースバックです。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addFailure">
<code class="descname">addFailure</code><span class="sig-paren">(</span><em>test</em>, <em>err</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addFailure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストケース <em>test</em> が失敗した場合に呼び出されます。 <em>err</em> は <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></code></a> が返すタプル <code class="docutils literal"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code> です。</p>
<p>デフォルトの実装では、タプル、 <code class="docutils literal"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> をインスタンスの <a class="reference internal" href="#unittest.TestResult.failures" title="unittest.TestResult.failures"><code class="xref py py-attr docutils literal"><span class="pre">failures</span></code></a> 属性に追加します。ここで、 <em>formatted_err</em> は、 <em>err</em> から導出される、整形されたトレースバックです。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addSuccess">
<code class="descname">addSuccess</code><span class="sig-paren">(</span><em>test</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSuccess" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストケース <em>test</em> が成功した場合に呼び出されます。</p>
<p>デフォルトの実装では何もしません。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addSkip">
<code class="descname">addSkip</code><span class="sig-paren">(</span><em>test</em>, <em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSkip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>test</em> がスキップされた時に呼び出されます。<em>reason</em> はスキップの際に渡された理由の文字列です。</p>
<p>デフォルトの実装では、 <code class="docutils literal"><span class="pre">(test,</span> <span class="pre">reason)</span></code> のタプルをインスタンスの <a class="reference internal" href="#unittest.TestResult.skipped" title="unittest.TestResult.skipped"><code class="xref py py-attr docutils literal"><span class="pre">skipped</span></code></a> 属性に追加します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addExpectedFailure">
<code class="descname">addExpectedFailure</code><span class="sig-paren">(</span><em>test</em>, <em>err</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addExpectedFailure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal"><span class="pre">expectedFailure()</span></code></a> のデコレータでマークされた <em>test</em> が失敗した時に呼び出されます。</p>
<p>デフォルトの実装では <code class="docutils literal"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> のタプルをインスタンスの <a class="reference internal" href="#unittest.TestResult.expectedFailures" title="unittest.TestResult.expectedFailures"><code class="xref py py-attr docutils literal"><span class="pre">expectedFailures</span></code></a> に追加します。ここで <em>formatted_err</em> は <em>err</em> から派生した整形されたトレースバックです。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addUnexpectedSuccess">
<code class="descname">addUnexpectedSuccess</code><span class="sig-paren">(</span><em>test</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addUnexpectedSuccess" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal"><span class="pre">expectedFailure()</span></code></a> のデコレータでマークされた <em>test</em> が成功した時に呼び出されます。</p>
<p>デフォルトの実装ではテストをインスタンスの <a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><code class="xref py py-attr docutils literal"><span class="pre">unexpectedSuccesses</span></code></a> 属性に追加します。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="unittest.TextTestResult">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">TextTestResult</code><span class="sig-paren">(</span><em>stream</em>, <em>descriptions</em>, <em>verbosity</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestResult" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code class="xref py py-class docutils literal"><span class="pre">TextTestRunner</span></code></a> に使用される <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal"><span class="pre">TestResult</span></code></a> の具象実装です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加: </span>このクラスは以前 <code class="docutils literal"><span class="pre">_TextTestResult</span></code> という名前でした。以前の名前はエイリアスとして残っていますが非推奨です。</p>
</div>
</dd></dl>

<dl class="data">
<dt id="unittest.defaultTestLoader">
<code class="descclassname">unittest.</code><code class="descname">defaultTestLoader</code><a class="headerlink" href="#unittest.defaultTestLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal"><span class="pre">TestLoader</span></code></a> のインスタンスで、共用することが目的です。 <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal"><span class="pre">TestLoader</span></code></a> をカスタマイズする必要がなければ、新しい <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal"><span class="pre">TestLoader</span></code></a> オブジェクトを作らずにこのインスタンスを使用します。</p>
</dd></dl>

<dl class="class">
<dt id="unittest.TextTestRunner">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">TextTestRunner</code><span class="sig-paren">(</span><em>stream=sys.stderr</em>, <em>descriptions=True</em>, <em>verbosity=1</em>, <em>failfast=False</em>, <em>buffer=False</em>, <em>resultclass=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行結果を標準エラーに出力する、単純なテストランナー。いくつかの設定項目がありますが、非常に単純です。グラフィカルなテスト実行アプリケーションでは、独自のテストランナーを作成してください。</p>
<dl class="method">
<dt id="unittest.TextTestRunner._makeResult">
<code class="descname">_makeResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner._makeResult" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <code class="xref py py-meth docutils literal"><span class="pre">run()</span></code> で使われる <code class="docutils literal"><span class="pre">TestResult</span></code> のインスタンスを返します。このメソッドは明示的に呼び出す必要はありませんが、サブクラスで <code class="docutils literal"><span class="pre">TestResult</span></code> をカスタマイズすることができます。</p>
<p><code class="docutils literal"><span class="pre">_makeResult()</span></code> は、 <code class="docutils literal"><span class="pre">TextTestRunner</span></code> のコンストラクタで <code class="docutils literal"><span class="pre">resultclass</span></code> 引数として渡されたクラスもしくはコーラブルオブジェクトをインスタンス化します。 <code class="docutils literal"><span class="pre">resultclass</span></code> が指定されていない場合には、デフォルトで <a class="reference internal" href="#unittest.TextTestResult" title="unittest.TextTestResult"><code class="xref py py-class docutils literal"><span class="pre">TextTestResult</span></code></a> が使用されます。結果のクラスは以下の引数が渡されインスタンス化されます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">stream</span><span class="p">,</span> <span class="n">descriptions</span><span class="p">,</span> <span class="n">verbosity</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="unittest.main">
<code class="descclassname">unittest.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="optional">[</span><em>module</em><span class="optional">[</span>, <em>defaultTest</em><span class="optional">[</span>, <em>argv</em><span class="optional">[</span>, <em>testRunner</em><span class="optional">[</span>, <em>testLoader</em><span class="optional">[</span>, <em>exit</em><span class="optional">[</span>, <em>verbosity</em><span class="optional">[</span>, <em>failfast</em><span class="optional">[</span>, <em>catchbreak</em><span class="optional">[</span>, <em>buffer</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.main" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>module</em> から複数のテストを読み込んで実行するためのコマンドラインプログラム。この関数を使えば、簡単に実行可能なテストモジュールを作成する事ができます。一番簡単なこの関数の使い方は、以下の行をテストスクリプトの最後に置くことです:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>より詳細な情報は verbosity 引数を指定して実行すると得られます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p><em>defaultTest</em> 引数は、 <em>argv</em> で指定されるテスト名がない場合に実行するテスト名です。これを指定しないか <code class="docutils literal"><span class="pre">None</span></code> を指定し、また <em>argv</em> からも与えられない場合は、 <em>module</em> 内で見つかる全てのテストを実行します。</p>
<p><em>argv</em> 引数には、プログラムに渡されたオプションのリストを、最初の要素がプログラム名のままで渡せます。指定しないか <code class="docutils literal"><span class="pre">None</span></code> の場合は <a class="reference internal" href="sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal"><span class="pre">sys.argv</span></code></a> が使われます。</p>
<p>引数、 <em>testRunner</em> は、test runner class、あるいは、そのインスタンスのどちらでも構いません。でフォルトでは <code class="docutils literal"><span class="pre">main</span></code> はテストが成功したか失敗したかに対応した終了コードと共に <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></code></a> を呼び出します。</p>
<p><em>testLoader</em> 引数は <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal"><span class="pre">TestLoader</span></code></a> インスタンスでなければなりません。デフォルトは <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code class="xref py py-data docutils literal"><span class="pre">defaultTestLoader</span></code></a> です。</p>
<p><code class="docutils literal"><span class="pre">main</span></code> は、 <code class="docutils literal"><span class="pre">exit=False</span></code> を指定する事で対話的なインタプリタから使用することもできます。この引数を指定すると、 <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></code></a> を呼ばずに、結果のみを出力します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest</span> <span class="k">import</span> <span class="n">main</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="s1">&#39;test_module&#39;</span><span class="p">,</span> <span class="n">exit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><em>failfast</em>, <em>catchbreak</em>, <em>buffer</em> は、<a class="reference internal" href="#command-line-options">コマンドラインオプション</a> にある同名のオプションと同じ効果のあるパラメータです。</p>
<p><code class="docutils literal"><span class="pre">main</span></code> を呼び出すと、<code class="docutils literal"><span class="pre">TestProgram</span></code> のインスタンスが返されます。このインスタンスは、<code class="docutils literal"><span class="pre">result</span></code> 属性にテスト結果を保持します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span>パラメータ <em>exit</em>, <em>verbosity</em>, <em>failfast</em>, <em>catchbreak</em>, <em>buffer</em> が追加されました。</p>
</div>
</dd></dl>

<div class="section" id="load-tests-protocol">
<h4>25.3.7.3.1. load_tests プロトコル<a class="headerlink" href="#load-tests-protocol" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
<p>モジュールやパッケージには、<code class="docutils literal"><span class="pre">load_tests</span></code> と呼ばれる関数を実装できます。これにより、通常のテスト実行時やテストディスカバリ時のテストのロードされ方をカスタマイズできます。</p>
<p>テストモジュールが <code class="docutils literal"><span class="pre">load_tests</span></code> を定義していると、それが <a class="reference internal" href="#unittest.TestLoader.loadTestsFromModule" title="unittest.TestLoader.loadTestsFromModule"><code class="xref py py-meth docutils literal"><span class="pre">TestLoader.loadTestsFromModule()</span></code></a> から呼ばれます。引数は以下です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>これは <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> を返すべきです。</p>
<p><em>loader</em> はローディングを行う <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal"><span class="pre">TestLoader</span></code></a> のインスタンスです。 <em>standard_tests</em> は、そのモジュールからデフォルトでロードされるテストです。これは、テストの標準セットのテストの追加や削除のみを行いたいテストモジュールに一般に使われます。第三引数は、パッケージをテストディスカバリの一部としてロードするときに使われます。</p>
<p>特定の <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> クラスのセットからテストをロードする典型的な <code class="docutils literal"><span class="pre">load_tests</span></code> 関数は、このようになります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">test_cases</span> <span class="o">=</span> <span class="p">(</span><span class="n">TestCase1</span><span class="p">,</span> <span class="n">TestCase2</span><span class="p">,</span> <span class="n">TestCase3</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">TestSuite</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">test_class</span> <span class="ow">in</span> <span class="n">test_cases</span><span class="p">:</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">test_class</span><span class="p">)</span>
        <span class="n">suite</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>ディスカバリが開始されると、パッケージ名にマッチするパターンを、コマンドラインまたは <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code class="xref py py-meth docutils literal"><span class="pre">TestLoader.discover()</span></code></a> に与えることで、 <code class="file docutils literal"><span class="pre">__init__.py</span></code> に <code class="docutils literal"><span class="pre">load_tests</span></code> があるか調べられます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>デフォルトのパターンは <code class="docutils literal"><span class="pre">'test*.py'</span></code> です。これは <code class="docutils literal"><span class="pre">'test'</span></code> で始まるすべての Python ファイルにマッチしますが、テストディレクトリにはマッチ <em>しません</em>。</p>
<p class="last"><code class="docutils literal"><span class="pre">'test*'</span></code> のようなパターンは、モジュールだけでなくテストパッケージにもマッチします。</p>
</div>
<p>パッケージ <code class="file docutils literal"><span class="pre">__init__.py</span></code> が <code class="docutils literal"><span class="pre">load_tests</span></code> を定義していると、それが呼び出され、ディスカバリはそれ以上パッケージ内で続けられません。 <code class="docutils literal"><span class="pre">load_tests</span></code> が以下の引数で呼び出されます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>これはパッケージ内のすべてのテストを表す <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> を返すべきです。 (<code class="docutils literal"><span class="pre">standard_tests</span></code> には、 <code class="file docutils literal"><span class="pre">__init__.py</span></code> から収集されたテストのみが含まれます。)</p>
<p>パターンは <code class="docutils literal"><span class="pre">load_tests</span></code> に渡されるので、パッケージは自由にテストディスカバリを継続 (必要なら変更) できます。テストパッケージに '何もしない' <code class="docutils literal"><span class="pre">load_tests</span></code> 関数は次のようになります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="c1"># top level directory cached on loader instance</span>
    <span class="n">this_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
    <span class="n">package_tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">discover</span><span class="p">(</span><span class="n">start_dir</span><span class="o">=</span><span class="n">this_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">standard_tests</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">package_tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">standard_tests</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="class-and-module-fixtures">
<h2>25.3.8. クラスとモジュールのフィクスチャ<a class="headerlink" href="#class-and-module-fixtures" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>クラスレベルとモジュールレベルのフィクスチャが <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a> に実装されました。テストスイートが新しいクラスのテストを始める時、以前のクラス (あれば)の <code class="xref py py-meth docutils literal"><span class="pre">tearDownClass()</span></code> を呼び出し、その後に新しいクラスの <code class="xref py py-meth docutils literal"><span class="pre">setUpClass()</span></code> を呼び出します。</p>
<p>同様に、今回のテストのモジュールが前回のテストとは異なる場合、以前のモジュールの <code class="docutils literal"><span class="pre">tearDownModule</span></code> を実行し、次に新しいモジュールの <code class="docutils literal"><span class="pre">setUpModule</span></code> を実行します。</p>
<p>すべてのテストが実行された後、最後の <code class="docutils literal"><span class="pre">tearDownClass</span></code> と <code class="docutils literal"><span class="pre">tearDownModule</span></code> が実行されます。</p>
<p>なお、共有フィクスチャは、テストの並列化などの [潜在的な] 機能と同時にはうまくいかず、テストの分離を壊すので、気をつけて使うべきです。</p>
<p>unittest テストローダによるテスト作成のデフォルトの順序では、同じモジュールやクラスからのテストはすべて同じグループにまとめられます。これにより、<code class="docutils literal"><span class="pre">setUpClass</span></code> / <code class="docutils literal"><span class="pre">setUpModule</span></code> (など) は、一つのクラスやモジュールにつき一度だけ呼ばれます。この順序をバラバラにし、異なるモジュールやクラスのテストが並ぶようにすると、共有フィクスチャ関数は、一度のテストで複数回呼ばれるようにもなります。</p>
<p>共有フィクスチャは標準でない順序で実行されることを意図していません。共有フィクスチャをサポートしたくないフレームワークのために、<code class="docutils literal"><span class="pre">BaseTestSuite</span></code> がまだ存在しています。</p>
<p>共有フィクスチャ関数のいずれかで例外が発生した場合、そのテストはエラーとして報告されます。そのとき、対応するテストインスタンスが無いので(<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> と同じインタフェースの) <code class="docutils literal"><span class="pre">_ErrorHolder</span></code> オブジェクトが生成され、エラーを表します。標準 unittest テストランナーを使っている場合はこの詳細は問題になりませんが、あなたがフレームワークの作者である場合は注意してください。</p>
<div class="section" id="setupclass-and-teardownclass">
<h3>25.3.8.1. setUpClass と tearDownClass<a class="headerlink" href="#setupclass-and-teardownclass" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらはクラスメソッドとして実装されなければなりません:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">createExpensiveConnectionObject</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
</pre></div>
</div>
<p>基底クラスの <code class="docutils literal"><span class="pre">setUpClass</span></code> および <code class="docutils literal"><span class="pre">tearDownClass</span></code> を使いたいなら、それらを自分で呼び出さなければなりません。 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code></a> の実装は空です。</p>
<p><code class="docutils literal"><span class="pre">setUpClass</span></code> の中で例外が送出されたら、クラス内のテストは実行されず、 <code class="docutils literal"><span class="pre">tearDownClass</span></code> も実行されません。スキップされたクラスは <code class="docutils literal"><span class="pre">setUpClass</span></code> も <code class="docutils literal"><span class="pre">tearDownClass</span></code> も実行されません。例外が <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal"><span class="pre">SkipTest</span></code></a> 例外であれば、そのクラスはエラーではなくスキップされたものとして報告されます。</p>
</div>
<div class="section" id="setupmodule-and-teardownmodule">
<h3>25.3.8.2. setUpModule と tearDownModule<a class="headerlink" href="#setupmodule-and-teardownmodule" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらは関数として実装されなければなりません:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setUpModule</span><span class="p">():</span>
    <span class="n">createConnection</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">tearDownModule</span><span class="p">():</span>
    <span class="n">closeConnection</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">setUpModule</span></code> の中で例外が送出されたら、モジュール内のテストは実行されず、 <code class="docutils literal"><span class="pre">tearDownModule</span></code> も実行されません。例外が <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal"><span class="pre">SkipTest</span></code></a> 例外であれば、そのモジュールはエラーではなくスキップされたものとして報告されます。</p>
</div>
</div>
<div class="section" id="signal-handling">
<h2>25.3.9. シグナルハンドリング<a class="headerlink" href="#signal-handling" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>unittest の <a class="reference internal" href="#cmdoption-unittest-c"><code class="xref std std-option docutils literal"><span class="pre">-c/--catch</span></code></a> コマンドラインオプションや、 <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal"><span class="pre">unittest.main()</span></code></a> の <code class="docutils literal"><span class="pre">catchbreak</span></code> パラメタは、テスト実行中の control-C の処理をよりフレンドリーにします。中断捕捉動作を有効である場合、 control-C が押されると、現在実行されているテストまで完了され、そのテストランが終わると今までの結果が報告されます。control-C がもう一度押されると、通常通り <a class="reference internal" href="exceptions.html#exceptions.KeyboardInterrupt" title="exceptions.KeyboardInterrupt"><code class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></code></a> が送出されます。</p>
<p>シグナルハンドラを処理する control-c は、独自の <code class="xref py py-const docutils literal"><span class="pre">signal.SIGINT</span></code> ハンドラをインストールするコードやテストの互換性を保とうとします。 <code class="docutils literal"><span class="pre">unittest</span></code> ハンドラが呼ばれ、それがインストールされた <code class="xref py py-const docutils literal"><span class="pre">signal.SIGINT</span></code> ハンドラで <em>なければ</em> 、すなわちテスト中のシステムに置き換えられて移譲されたなら、それはデフォルトのハンドラを呼び出します。インストールされたハンドラを置き換えて委譲するようなコードは、通常その動作を期待するからです。 <code class="docutils literal"><span class="pre">unittest</span></code> の control-c 処理を無効にしたいような個別のテストには、 <a class="reference internal" href="#unittest.removeHandler" title="unittest.removeHandler"><code class="xref py py-func docutils literal"><span class="pre">removeHandler()</span></code></a> デコレータが使えます。</p>
<p>フレームワークの作者がテストフレームワーク内で control-c 処理を有効にするための、いくつかのユーティリティ関数があります。</p>
<dl class="function">
<dt id="unittest.installHandler">
<code class="descclassname">unittest.</code><code class="descname">installHandler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.installHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>control-c ハンドラをインストールします。(主にユーザが control-c を押したことにより) <code class="xref py py-const docutils literal"><span class="pre">signal.SIGINT</span></code> が受け取られると、登録した結果すべてに <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal"><span class="pre">stop()</span></code></a> が呼び出されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="unittest.registerResult">
<code class="descclassname">unittest.</code><code class="descname">registerResult</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.registerResult" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>control-c 処理のために <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal"><span class="pre">TestResult</span></code></a> を登録します。結果を登録するとそれに対する弱参照が格納されるので、結果がガベージコレクトされるのを妨げません。</p>
<p>control-c 処理が有効でなければ、 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal"><span class="pre">TestResult</span></code></a> オブジェクトの登録には副作用がありません。ですからテストフレームワークは、処理が有効か無効かにかかわらず、作成する全ての結果を無条件に登録できます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="unittest.removeResult">
<code class="descclassname">unittest.</code><code class="descname">removeResult</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.removeResult" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>登録された結果を削除します。一旦結果が削除されると、control-c が押された際にその結果オブジェクトに対して <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal"><span class="pre">stop()</span></code></a> が呼び出されなくなります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="unittest.removeHandler">
<code class="descclassname">unittest.</code><code class="descname">removeHandler</code><span class="sig-paren">(</span><em>function=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.removeHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>When called without arguments this function removes the control-c handler
if it has been installed. This function can also be used as a test decorator
to temporarily remove the handler whilst the test is being executed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@unittest</span><span class="o">.</span><span class="n">removeHandler</span>
<span class="k">def</span> <span class="nf">test_signal_handling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.7 で追加.</span></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">25.3. <code class="docutils literal"><span class="pre">unittest</span></code> — ユニットテストフレームワーク</a><ul>
<li><a class="reference internal" href="#basic-example">25.3.1. 基礎的な例</a></li>
<li><a class="reference internal" href="#command-line-interface">25.3.2. コマンドラインインターフェイス</a><ul>
<li><a class="reference internal" href="#command-line-options">25.3.2.1. コマンドラインオプション</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-discovery">25.3.3. テストディスカバリ</a></li>
<li><a class="reference internal" href="#organizing-test-code">25.3.4. テストの構成</a></li>
<li><a class="reference internal" href="#re-using-old-test-code">25.3.5. 既存テストコードの再利用</a></li>
<li><a class="reference internal" href="#skipping-tests-and-expected-failures">25.3.6. テストのスキップと意図的な失敗</a></li>
<li><a class="reference internal" href="#classes-and-functions">25.3.7. クラスと関数</a><ul>
<li><a class="reference internal" href="#test-cases">25.3.7.1. テストクラス</a><ul>
<li><a class="reference internal" href="#deprecated-aliases">25.3.7.1.1. 廃止予定のエイリアス</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grouping-tests">25.3.7.2. テストのグルーピング</a></li>
<li><a class="reference internal" href="#loading-and-running-tests">25.3.7.3. テストのロードと起動</a><ul>
<li><a class="reference internal" href="#load-tests-protocol">25.3.7.3.1. load_tests プロトコル</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#class-and-module-fixtures">25.3.8. クラスとモジュールのフィクスチャ</a><ul>
<li><a class="reference internal" href="#setupclass-and-teardownclass">25.3.8.1. setUpClass と tearDownClass</a></li>
<li><a class="reference internal" href="#setupmodule-and-teardownmodule">25.3.8.2. setUpModule と tearDownModule</a></li>
</ul>
</li>
<li><a class="reference internal" href="#signal-handling">25.3.9. シグナルハンドリング</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="doctest.html"
                        title="前の章へ">25.2. <code class="docutils literal"><span class="pre">doctest</span></code> — 対話的な実行例をテストする</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="2to3.html"
                        title="次の章へ">25.4. 2to3 - Python 2 から 3 への自動コード変換</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">バグ報告</a></li>
  <li><a href="https://github.com/python/cpython/blob/2.7/Doc/library/unittest.rst"
         rel="nofollow">ソースの表示</a>
  </li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2to3.html" title="25.4. 2to3 - Python 2 から 3 への自動コード変換"
             >次へ</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="25.2. doctest — 対話的な実行例をテストする"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.14</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >25. 開発ツール</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2018, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト).
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 2018-03-27
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>