
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>3. データモデル &#8212; Python 2.7.14 ドキュメント</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.14',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7.14 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="4. 実行モデル" href="executionmodel.html" />
    <link rel="prev" title="2. 字句解析" href="lexical_analysis.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/reference/datamodel.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 実行モデル"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 字句解析"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.14</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 言語リファレンス</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="data-model">
<span id="datamodel"></span><h1>3. データモデル<a class="headerlink" href="#data-model" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="objects-values-and-types">
<span id="objects"></span><h2>3.1. オブジェクト、値、および型<a class="headerlink" href="#objects-values-and-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-0">Python における <em class="dfn">オブジェクト (object)</em> とは、データを抽象的に表したものです。Python プログラムにおけるデータは全て、オブジェクトまたはオブジェクト間の関係として表されます。(ある意味では、プログラムコードもまたオブジェクトとして表されます。これはフォン・ノイマン: Von Neumann の &quot;プログラム記憶方式コンピュータ: stored program computer&quot; のモデルに適合します。)</p>
<p id="index-1">オブジェクトはアイデンティティ値 (identity) 、型 (type) 、そして値 (value) を持ちます。オブジェクトが一度生成されると、そのオブジェクトの <em>アイデンティティ値</em> は決して変化することがありません; アイデンティティ値をオブジェクトのメモリ上のアドレスと考えてもかまいません。演算子 '<a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a>' は、二つのオブジェクト間のアイデンティティ値を比較します; 関数 <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal"><span class="pre">id()</span></code></a> は、オブジェクトのアイデンティティ値を表す整数 (現在の実装ではオブジェクトのメモリ上のアドレス) を返します。オブジェクトの <em class="dfn">型</em> もまた変わることがありません。 <a class="footnote-reference" href="#id5" id="id1">[1]</a> オブジェクトの型は、そのオブジェクトのサポートする操作 (&quot;長さを持っているか？&quot; など) を決定し、その型のオブジェクトが取りうる値について定義しています。 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a> 関数は、オブジェクトの型 (型自体も一つのオブジェクトです) を返します。オブジェクトによっては、 <em>値 (value)</em> を変えることができます。値を変えることができるオブジェクトは <em>変更可能 (mutable)</em> であるといいます; 値を一度設定すると、その後は変えることができないオブジェクトは <em>変更不能 (immutable)</em> であると呼びます。 (変更不能なコンテナオブジェクトが変更可能なオブジェクトへの参照を含んでいる場合、その値は後者のオブジェクトの変更によって変わる場合があります; その場合でも、コンテナの含んでいるオブジェクトの集まりは変わらないため、コンテナは変更不能と考えます。したがって、変更不能性 (immutability) は、厳密には変更できない値を持っていることとは違い、もっと微妙な概念です。) オブジェクトの変更可能性は型で決定されます; 例えば、数値、文字列、およびタプルは変更不能であり、辞書やリストは変更可能です。</p>
<p id="index-2">オブジェクトを明示的に破壊することはできません; しかし、オブジェクトに到達不能 (unreachable) になると、ガベージコレクション (garbage-collection) によって処理されます。実装では、ごみ収集を遅らせたり、全く行わないようにすることができます — 到達可能なオブジェクトをごみ収集処理してしまわないかぎり、どう実装するかは実装品質の問題です。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> 現在の CPython 実装では参照カウント(reference-counting) 方式を使っており、(オプションとして) 循環参照を行っているごみオブジェクトを遅延検出します。この実装ではほとんどのオブジェクトを到達不能になると同時に処理することができますが、循環参照を含むごみオブジェクトの収集が確実に行われるよう保証しているわけではありません。循環参照を持つごみオブジェクト収集の制御については、 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal"><span class="pre">gc</span></code></a> モジュールを参照してください。 CPython以外の実装は別の方式を使っており、CPythonも将来は別の方式を使うかもしれません。オブジェクトが到達不能になったときに即座に終了処理されることに頼らないでください (例えば、ファイルは必ず閉じてください)。</p>
</div>
<p>実装のトレース機能やデバッグ機能を使えば、通常は収集されてしまうようなオブジェクトを生かしておくことがあるので注意してください。また、 '<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a>' 文を使って例外を捕捉できるようにすると、オブジェクトを生かしておくことがあります。</p>
<p>オブジェクトによっては、開かれたファイルやウィンドウといった、 &quot;外部 (external) の&quot; リソースに対する参照を行っています。これらのリソースは、オブジェクトがごみ収集された際に解放されるものと理解されていますが、ごみ収集が行われる保証はないので、こうしたオブジェクトでは外部リソースを明示的に解放する方法、大抵は <code class="xref py py-meth docutils literal"><span class="pre">close()</span></code> メソッドを提供しています。こうしたオブジェクトは明示的に close するよう強く奨めます。操作をする際には、'<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a>' 文を使うと便利です。</p>
<p id="index-3">他のオブジェクトに対する参照をもつオブジェクトもあります; これらは <em>コンテナ (container)</em> と呼ばれます。コンテナオブジェクトの例として、タプル、リスト、および辞書が挙げられます。オブジェクトへの参照自体がコンテナの値の一部です。ほとんどの場合、コンテナの値というと、コンテナに入っているオブジェクトの値のことを指し、それらオブジェクトのアイデンティティではありません; しかしながら、コンテナの変更可能性について述べる場合、今まさにコンテナに入っているオブジェクトのアイデンティティのことを指します。したがって、 (タプルのように) 変更不能なオブジェクトが変更可能なオブジェクトへの参照を含む場合、その値が変化するのは変更可能なオブジェクトが変更された時、ということになります。</p>
<p>型はオブジェクトの動作のほとんど全てに影響します。オブジェクトのアイデンティティが重要かどうかでさえ、ある意味では型に左右されます: 変更不能な型では、新たな値を計算するような操作を行うと、実際には同じ型と値を持った既存のオブジェクトへの参照を返すことがありますが、変更可能なオブジェクトではそのような動作は起こりえません。例えば、 <code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1</span></code> とすると、 <code class="docutils literal"><span class="pre">a</span></code> と <code class="docutils literal"><span class="pre">b</span></code> は値 1 を持つ同じオブジェクトを参照するときもあるし、そうでないときもあります。これは実装に依存します。しかし、 <code class="docutils literal"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">[];</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> とすると、 <code class="docutils literal"><span class="pre">c</span></code> と <code class="docutils literal"><span class="pre">d</span></code> はそれぞれ二つの異なった、互いに一意な、新たに作成された空のリストを参照することが保証されています。 (<code class="docutils literal"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> とすると、 <code class="docutils literal"><span class="pre">c</span></code> と <code class="docutils literal"><span class="pre">d</span></code> の両方に同じオブジェクトを代入します)</p>
</div>
<div class="section" id="the-standard-type-hierarchy">
<span id="types"></span><h2>3.2. 標準型の階層<a class="headerlink" href="#the-standard-type-hierarchy" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-4">以下は Python に組み込まれている型のリストです。(C、Java、または実装に使われているその他の言語で書かれた) 拡張モジュールでは、その他に新たな型を定義することができます。将来のバージョンの Python では、型の階層に新たな型 (整数を使って効率的に記憶される有理数型、など) を追加することができるかもしれません。</p>
<p id="index-5">以下に説明する型のいくつかには、'特殊属性 (special attribute)' と題された段落が連ねられています。これらの属性は実装へのアクセス手段を提供するもので、一般的な用途に利用するためのものではありません。特殊属性の定義は将来変更される可能性があります。</p>
<dl class="docutils">
<dt>None</dt>
<dd><p class="first last" id="index-6">この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトは組み込み名 <code class="docutils literal"><span class="pre">None</span></code> でアクセスされます。このオブジェクトは、様々な状況で値が存在しないことをしめします。例えば、明示的に値を返さない関数は <code class="docutils literal"><span class="pre">None</span></code> を返します。 <code class="docutils literal"><span class="pre">None</span></code> の真値 (truth value) は偽 (false) です。</p>
</dd>
<dt>NotImplemented</dt>
<dd><p class="first last" id="index-7">この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトは組み込み名 <code class="docutils literal"><span class="pre">NotImplemented</span></code> でアクセスされます。数値演算に関するメソッドや拡張比較 (rich comparison) メソッドは、被演算子が該当する演算を行うための実装をもたない場合、この値を返すことがあります。(演算子によっては、インタプリタが関連のある演算を試したり、他の代替操作を行います。) 真値は真 (true) です。</p>
</dd>
<dt>Ellipsis</dt>
<dd><p class="first last" id="index-8">この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトは組み込み名 <code class="docutils literal"><span class="pre">Ellipsis</span></code> でアクセスされます。スライス内に <code class="docutils literal"><span class="pre">...</span></code> 構文がある場合に使われます。真値は真 (true)です。</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Number" title="numbers.Number"><code class="xref py py-class docutils literal"><span class="pre">numbers.Number</span></code></a></dt>
<dd><p class="first" id="index-9">数値リテラルによって作成されたり、算術演算や組み込みの算術関数によって返されるオブジェクトです。数値オブジェクトは変更不能です; 一度値が生成されると、二度と変更されることはありません。Python の数値オブジェクトはいうまでもなく数学で言うところの数値と強く関係していますが、コンピュータ内で数値を表現する際に伴う制限を受けています。</p>
<p>Python は整数、浮動小数点数、複素数の間で区別を行っています:</p>
<dl class="last docutils">
<dt><a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">numbers.Integral</span></code></a> (整数)</dt>
<dd><p class="first" id="index-10">整数型は、整数(正の数および負の数)を表す数学的集合内における要素を表現する型です。</p>
<p>以下に三つの整数型を示します:</p>
<dl class="docutils">
<dt>(通常の) 整数型 (plain integer)</dt>
<dd><p class="first last" id="index-11">-2147483648 から 2147483647 までの整数を表現します (基本ワードサイズ: natural word size がより大きなマシンではより大きな定義域になることもあります。より小さくなることはありません。) 演算の結果が定義域を超えた値になった場合、結果は通常長整数で返されます (場合によっては、 <a class="reference internal" href="../library/exceptions.html#exceptions.OverflowError" title="exceptions.OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> が送出されます) 。シフト演算やマスク演算のために、整数は 32 ビット以上の 2 の補数で表されたバイナリ表現を持つ (すなわち、4294967296 の異なったビットパターン全てが異なる値を持つ) と仮定されています。</p>
</dd>
<dt>長整数型 (long integer)</dt>
<dd><p class="first last" id="index-12">長整数は無限の定義域を持ち、利用可能な (仮想) メモリサイズの制限のみをうけます。長整数はシフト演算やマスク演算のためにバイナリ表現をもつものと仮定されます。負の数は符号ビットが左に無限に延びているような錯覚を与える 2 の補数表現の変型で表されます。</p>
</dd>
<dt>ブール型 (boolean)</dt>
<dd><p class="first last" id="index-13">真偽値の False と True を表します。<code class="docutils literal"><span class="pre">False</span></code> と <code class="docutils literal"><span class="pre">True</span></code> を表す 2 つのオブジェクトのみがブール値オブジェクトです。ブール型は整数型の部分型であり、ほとんどの状況でそれぞれ 0 と 1 のように振る舞いますが、例外として文字列に変換されたときはそれぞれ <code class="docutils literal"><span class="pre">&quot;False&quot;</span></code> および <code class="docutils literal"><span class="pre">&quot;True&quot;</span></code> という文字列が返されます。</p>
</dd>
</dl>
<p class="last" id="index-14">整数表現に関する規則は、シフト演算やマスク演算において、負の整数も含めて最も有意義な解釈ができるように、かつ通常の整数と長整数との間で定義域を切り替える際にできるだけ混乱しないように決められています。すべての演算で、演算結果がオーバフローを起こさずに整数の定義域の値になる場合は、長整数を使った場合でも、被演算子に整数と長整数を混合した場合でも同じ結果になります。定義域の切り替えはプログラマに対して透過的に(意識させることなく)行われます。</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal"><span class="pre">numbers.Real</span></code></a> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>) (実数)</dt>
<dd><p class="first last" id="index-15">この型は計算機レベルの倍精度浮動小数点数を表現します。表現可能な値の範囲やオーバーフローの扱いは計算機のアーキテクチャ（および、CやJavaによる実装）に従います。Pythonは単精度浮動小数点数をサポートしません。一般的に単精度浮動小数点数を使う理由はプロセッサーとメモリの使用を節約するためと説明されます。しかし、こうした節約はPythonでオブジェクトを扱う際のオーバーヘッドに比べれば微々たるものです。また、2種類の浮動小数点数型を持つことで複雑になる理由はありません。</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Complex" title="numbers.Complex"><code class="xref py py-class docutils literal"><span class="pre">numbers.Complex</span></code></a> (複素数)</dt>
<dd><p class="first last" id="index-16">この型は、計算機レベルで倍精度とされている浮動小数点を 2 つ一組にして複素数を表現します。浮動小数点について述べたのと同じ性質が当てはまります。複素数 <code class="docutils literal"><span class="pre">z</span></code> の実数部および虚数部は、それぞれ読み出し専用属性 <code class="docutils literal"><span class="pre">z.real</span></code> および <code class="docutils literal"><span class="pre">z.imag</span></code> で取り出すことができます。</p>
</dd>
</dl>
</dd>
<dt>シーケンス型 (sequence)</dt>
<dd><p class="first" id="index-17">この型は、有限の順序集合 (ordered set) を表現します。要素は非負の整数でインデクス化されています。組み込み関数 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> を使うと、シーケンスの要素数を返します。シーケンスの長さが <em>n</em> の場合、インデクスは 0, 1, …, <em>n</em> -1 からなる集合です。シーケンス <em>a</em> の要素 <em>i</em> は <code class="docutils literal"><span class="pre">a[i]</span></code> で選択します。</p>
<p id="index-18">シーケンスはスライス操作 (slice) もサポートしています: <code class="docutils literal"><span class="pre">a[i:j]</span></code> とすると、 <em>i</em> <code class="docutils literal"><span class="pre">&lt;=</span></code> <em>k</em> <code class="docutils literal"><span class="pre">&lt;</span></code> <em>j</em> であるインデクス <em>k</em> をもつ全ての要素を選択します。式表現としてスライスを用いた場合、スライスは同じ型をもつ新たなシーケンスを表します。新たなシーケンス内では、インデクス集合が 0 から始まるようにインデクスの値を振りなおします。</p>
<p id="index-19">シーケンスによっては、第三の &quot;ステップ (step)&quot; パラメタを持つ &quot;拡張スライス (extended slice)&quot; もサポートしています: <code class="docutils literal"><span class="pre">a[i:j:k]</span></code> は、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code>, <em>n</em> <code class="docutils literal"><span class="pre">&gt;=</span></code> <code class="docutils literal"><span class="pre">0</span></code> かつ <em>i</em> <code class="docutils literal"><span class="pre">&lt;=</span></code> <em>x</em> <code class="docutils literal"><span class="pre">&lt;</span></code> <em>j</em> であるようなインデクス <em>x</em> を持つような <em>a</em> 全ての要素を選択します。</p>
<p>シーケンスは、変更可能なものか、そうでないかで区別されています:</p>
<dl class="last docutils">
<dt>変更不能なシーケンス (immutable sequence)</dt>
<dd><p class="first" id="index-20">変更不能なシーケンス型のオブジェクトは、一度生成されるとその値を変更することができません。 (オブジェクトに他のオブジェクトへの参照が入っている場合、参照されているオブジェクトは変更可能なオブジェクトでもよく、その値は変更される可能性があります; しかし、変更不能なオブジェクトが直接参照しているオブジェクトの集合自体は、変更することができません。)</p>
<p>以下の型は変更不能なシーケンス型です:</p>
<dl class="last docutils">
<dt>文字列型 (string)</dt>
<dd><p class="first" id="index-21">文字列の各要素は文字 (character) です。文字型 (character type) は存在しません。単一の文字は、要素が一つだけの文字列として表現されます。各文字は(少なくとも)8-bit の 1 byte を表現します。組み込み関数 <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal"><span class="pre">chr()</span></code></a> および <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a> を使うと、文字と非負の整数で表されたバイト値の間で変換を行えます。0–127 の値を持つバイト値は、通常同じ ASCII 値をもつ文字を表現していますが、値をどう解釈するかはプログラムにゆだねられています。文字列データ型はまた、例えばファイルから読み出されたデータを記憶するといった用途で、バイト値のアレイを表現するために用いられます。</p>
<p class="last" id="index-22">(ネイティブの文字セットが ASCIIでないシステムでは、 <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal"><span class="pre">chr()</span></code></a> や <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a> が ASCII と EBCDIC との間で対応付けを行っており、文字列間の比較で ASCII 順が守られる限り、文字列の内部表現として EBCDIC を使ってもかまいません。誰か他にもっとましなルールをお持ちですか?)</p>
</dd>
<dt>Unicode 文字列型</dt>
<dd><p class="first last" id="index-23">Unicode オブジェクトの各要素は Unicode コード単位です。 Unicode コード単位とは、単一の Unicode オブジェクトで、Unicode 序数を表現する 16-bit または 32-bit の値を保持できるものです (この序数の最大値は <code class="docutils literal"><span class="pre">sys.maxunicode</span></code> で与えられており、コンパイル時に Python がどう設定されているかに依存します)。 Unicode オブジェクト内にサロゲートペア (surrogate pair) があってもよく、Python はサロゲートペアを二つの別々の Unicode 要素として報告します。組み込み関数 <a class="reference internal" href="../library/functions.html#unichr" title="unichr"><code class="xref py py-func docutils literal"><span class="pre">unichr()</span></code></a> および <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a> は、コード単位と非負の整数で表された Unicode 標準 3.0 で定義された Unicode 序数との間で変換を行います。他の文字エンコード形式との相互変換は、 Unicode メソッド <code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code> および組み込み関数 <a class="reference internal" href="../library/functions.html#unicode" title="unicode"><code class="xref py py-func docutils literal"><span class="pre">unicode()</span></code></a> で行うことができます。</p>
</dd>
<dt>タプル型 (tuple)</dt>
<dd><p class="first last" id="index-24">タプルの要素は任意の Python オブジェクトです。二つ以上の要素からなるタプルは、個々の要素を表現する式をカンマで区切って構成します。単一の要素からなるタプル (単集合 'singleton') を作るには、要素を表現する式の直後にカンマをつけます (単一の式だけではタプルを形成しません。これは、式をグループ化するのに丸括弧を使えるようにしなければならないからです)。要素の全くない丸括弧の対を作ると空のタプルになります。</p>
</dd>
</dl>
</dd>
<dt>変更可能なシーケンス型 (mutable sequence)</dt>
<dd><p class="first" id="index-25">変更可能なシーケンスは、作成した後で変更することができます。変更可能なシーケンスでは、添字表記やスライス表記を使って指定された要素に代入を行うことができ、 <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal"><span class="pre">del</span></code></a> (delete) 文を使って要素を削除することができます。</p>
<p>Python に最初から組み込まれている変更可能なシーケンス型は、今のところ二つです:</p>
<dl class="docutils">
<dt>リスト型 (list)</dt>
<dd><p class="first last" id="index-26">リストの要素は任意の Python オブジェクトにできます。リストは、角括弧の中にカンマで区切られた式を並べて作ります。 (長さが 0 や 1 のシーケンスを作るために特殊な場合分けは必要ないことに注意してください。)</p>
</dd>
<dt>バイト配列</dt>
<dd><p class="first last" id="index-27">bytearray オブジェクトは変更可能な配列です。組み込みの <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal"><span class="pre">bytearray()</span></code></a> コンストラクタによって作成されます。変更可能なことを除けば (つまりハッシュ化できない)、 byte array は変更不能な bytes オブジェクトと同じインターフェースと機能を提供します。</p>
</dd>
</dl>
<p class="last" id="index-28">拡張モジュール <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal"><span class="pre">array</span></code></a> では、別の変更可能なシーケンス型を提供しています。</p>
</dd>
</dl>
</dd>
<dt>集合型</dt>
<dd><p class="first" id="index-29">集合型は、順序のない、ユニークで不変なオブジェクトの有限集合を表現します。そのため、(配列の)添字を使ったインデックスアクセスはできません。ただし、イテレートは可能で、組み込み関数 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> は集合の要素数を返します。集合型の一般的な使い方は、集合に属しているかの高速なテスト、シーケンスからの重複の排除、共通集合・和集合・差・対称差といった数学的な演算の計算です。</p>
<p>集合の要素には、辞書のキーと同じ普遍性に関するルールが適用されます。数値型は通常の数値比較のルールに従うことに注意してください。もし2つの数値の比較結果が同値である(例えば、 <code class="docutils literal"><span class="pre">1</span></code> と <code class="docutils literal"><span class="pre">1.0</span></code>)なら、そのうちの1つのみを集合に含めることができます。</p>
<p>現在、2つの組み込み集合型があります:</p>
<dl class="last docutils">
<dt>集合型</dt>
<dd><p class="first last" id="index-30">可変な集合型です。組み込みの <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal"><span class="pre">set()</span></code></a> コンストラクタで作成され、後から <code class="xref py py-meth docutils literal"><span class="pre">add()</span></code> などのいくつかのメソッドで更新できます。</p>
</dd>
<dt>Frozen set 型</dt>
<dd><p class="first last" id="index-31">不変な集合型です。組み込みの <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal"><span class="pre">frozenset()</span></code></a> コンストラクタによって作成されます。 frozenset は不変でハッシュ可能(<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>)なので、別の集合型の要素になったり、辞書のキーにすることができます。</p>
</dd>
</dl>
</dd>
<dt>マップ型 (mapping)</dt>
<dd><p class="first" id="index-32">任意のインデクス集合でインデクス化された、有限のオブジェクトからなる集合を表現します。添字表記 <code class="docutils literal"><span class="pre">a[k]</span></code> は、 <code class="docutils literal"><span class="pre">k</span></code> でインデクス指定された要素を <code class="docutils literal"><span class="pre">a</span></code> から選択します; 選択された要素は式の中で使うことができ、代入や <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal"><span class="pre">del</span></code></a> 文の対象にすることができます。組み込み関数 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> は、マップ内の要素数を返します。</p>
<p>Python に最初から組み込まれているマップ型は、今のところ一つだけです:</p>
<dl class="last docutils">
<dt>辞書型 (dictionary)</dt>
<dd><p class="first" id="index-33">ほとんどどんな値でもインデクスとして使えるような、有限個のオブジェクトからなる集合を表します。キー値 (key) として使えない値は、リストや辞書を含む値や、アイデンティティではなく値でオブジェクトが比較される、その他の変更可能な型です。これは、辞書型を効率的に実装する上で、キーのハッシュ値が一定であることが必要だからです。数値型をキーに使う場合、キー値は通常の数値比較における規則に従います: 二つの値が等しくなる場合 (例えば <code class="docutils literal"><span class="pre">1</span></code> と <code class="docutils literal"><span class="pre">1.0</span></code>)、互いに同じ辞書のエントリを表すインデクスとして使うことができます。</p>
<p>辞書は変更可能な型です; 辞書は <code class="docutils literal"><span class="pre">{...}</span></code> 表記で生成します (<a class="reference internal" href="expressions.html#dict"><span class="std std-ref">辞書表現</span></a> を参照してください)。</p>
<p class="last" id="index-34">拡張モジュール <a class="reference internal" href="../library/dbm.html#module-dbm" title="dbm: The standard &quot;database&quot; interface, based on ndbm. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">dbm</span></code></a> 、 <a class="reference internal" href="../library/gdbm.html#module-gdbm" title="gdbm: GNU's reinterpretation of dbm. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">gdbm</span></code></a> 、および <a class="reference internal" href="../library/bsddb.html#module-bsddb" title="bsddb: Interface to Berkeley DB database library"><code class="xref py py-mod docutils literal"><span class="pre">bsddb</span></code></a> では、別のマップ型を提供しています。</p>
</dd>
</dl>
</dd>
<dt>呼び出し可能型 (callable type)</dt>
<dd><p class="first" id="index-35">関数呼び出し操作 (<a class="reference internal" href="expressions.html#calls"><span class="std std-ref">呼び出し (call)</span></a> 参照) を行うことができる型です:</p>
<dl class="last docutils">
<dt>ユーザ定義関数 (user-defined function)</dt>
<dd><p class="first" id="index-36">ユーザ定義関数オブジェクトは、関数定義を行うことで生成されます (<a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> 参照)。関数は、仮引数 (formal parameter) リストと同じ数の要素が入った引数リストとともに呼び出されます。</p>
<p>特殊属性:</p>
<table border="1" class="docutils" id="index-37">
<colgroup>
<col width="35%" />
<col width="48%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">属性</th>
<th class="head">意味</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code>
<code class="xref py py-attr docutils literal"><span class="pre">func_doc</span></code></td>
<td>関数のドキュメンテーション文字列です。ドキュメンテーションがない場合は <code class="docutils literal"><span class="pre">None</span></code> になります。</td>
<td>書き込み可能</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a>
<code class="xref py py-attr docutils literal"><span class="pre">func_name</span></code></td>
<td>関数の名前です</td>
<td>書き込み可能</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">__module__</span></code></td>
<td>関数が定義されているモジュールの名前です。モジュール名がない場合は <code class="docutils literal"><span class="pre">None</span></code> になります。</td>
<td>書き込み可能</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal"><span class="pre">__defaults__</span></code>
<code class="xref py py-attr docutils literal"><span class="pre">func_defaults</span></code></td>
<td>デフォルト値を持つ引数に対するデフォルト値が収められたタプルで、デフォルト値を持つ引数がない場合には <code class="docutils literal"><span class="pre">None</span></code> になります</td>
<td>書き込み可能</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">__code__</span></code>
<code class="xref py py-attr docutils literal"><span class="pre">func_code</span></code></td>
<td>コンパイルされた関数本体を表現するコードオブジェクトです。</td>
<td>書き込み可能</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal"><span class="pre">__globals__</span></code>
<code class="xref py py-attr docutils literal"><span class="pre">func_globals</span></code></td>
<td>関数のグローバル変数の入った辞書 (への参照) です — この辞書は、関数が定義されているモジュールのグローバルな名前空間を決定します。</td>
<td>読み込み専用</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a>
<code class="xref py py-attr docutils literal"><span class="pre">func_dict</span></code></td>
<td>任意の関数属性をサポートするための名前空間が収められています。</td>
<td>書き込み可能</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal"><span class="pre">__closure__</span></code>
<code class="xref py py-attr docutils literal"><span class="pre">func_closure</span></code></td>
<td><code class="docutils literal"><span class="pre">None</span></code> または関数の個々の自由変数 (引数以外の変数) に対して値を結び付けているセル (cell) 群からなるタプルになります。</td>
<td>読み込み専用</td>
</tr>
</tbody>
</table>
<p>「書き込み可能」とラベルされている属性のほとんどは、代入された値の型をチェックします。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.4 で変更: </span><code class="docutils literal"><span class="pre">func_name</span></code> は書き込み可能になりました.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>Python 3 との前方互換のために、ダブルアンダースコアの属性 <code class="docutils literal"><span class="pre">__closure__</span></code>, <code class="docutils literal"><span class="pre">__code__</span></code>, <code class="docutils literal"><span class="pre">__defaults__</span></code>, <code class="docutils literal"><span class="pre">__globals__</span></code> が対応する <code class="docutils literal"><span class="pre">func_*</span></code> への別名として導入されました。</p>
</div>
<p>関数オブジェクトはまた、任意の属性を設定したり取得したりできます。この機能は、例えば関数にメタデータを付与したい場合などに使えます。関数の get や set には、通常のドット表記を使います。 <em>現在の実装では、ユーザ定義の関数でのみ属性をサポートしているので注意して下さい。組み込み関数の属性は将来サポートする予定です。</em></p>
<p class="last">関数定義に関するその他の情報は、関数のコードオブジェクトから得られます; 後述の内部型 (internal type) に関する説明を参照してください。</p>
</dd>
<dt>ユーザ定義メソッド (user-defined method)</dt>
<dd><p class="first" id="index-38">ユーザ定義のメソッドオブジェクトは、クラスやクラスインスタンス (あるいは <code class="docutils literal"><span class="pre">None</span></code>) を任意の呼び出し可能オブジェクト (通常はユーザ定義関数) と結合し (combine) ます。</p>
<p>読み出し専用の特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">im_self</span></code> はクラスインスタンスオブジェクトで、 <code class="xref py py-attr docutils literal"><span class="pre">im_func</span></code> は関数オブジェクトです; <code class="xref py py-attr docutils literal"><span class="pre">im_class</span></code> は結合メソッド (bound method) において <code class="xref py py-attr docutils literal"><span class="pre">im_self</span></code> が属しているクラスか、あるいは非結合メソッド (unbound method) において、要求されたメソッドを定義しているクラスです; <code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code> はメソッドのドキュメンテーション文字列 (<code class="docutils literal"><span class="pre">im_func.__doc__</span></code> と同じ) です; <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a> はメソッドの名前 (<code class="docutils literal"><span class="pre">im_func.__name__</span></code> と同じ) です; <code class="xref py py-attr docutils literal"><span class="pre">__module__</span></code> はメソッドが定義されているモジュールの名前になるか、モジュール名がない場合は <code class="docutils literal"><span class="pre">None</span></code> になります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.2 で変更: </span>メソッドを定義しているクラスを参照するために <code class="xref py py-attr docutils literal"><span class="pre">im_self</span></code> が使われていました.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>Python 3 との前方互換性のために、 <code class="xref py py-attr docutils literal"><span class="pre">im_func</span></code> の代わりに <code class="xref py py-attr docutils literal"><span class="pre">__func__</span></code> も、 <code class="xref py py-attr docutils literal"><span class="pre">im_self</span></code> の代わりに <code class="xref py py-attr docutils literal"><span class="pre">__self__</span></code> も使うことができます。</p>
</div>
<p id="index-39">メソッドもまた、根底にある関数オブジェクトの任意の関数属性に (値の設定はできませんが) アクセスできます。</p>
<p>クラスの属性を (おそらくクラスのインスタンスを介して) 取得する際には、その属性がユーザ定義の関数オブジェクト、非結合 (unbound) のユーザ定義メソッドオブジェクト、あるいはクラスメソッドオブジェクトであれば、ユーザ定義メソッドオブジェクトが生成されることがあります。属性がユーザ定義メソッドオブジェクトの場合、属性を取得する対象のオブジェクトが属するクラスがもとのメソッドオブジェクトが定義されているクラスと同じクラスであるか、またはそのサブクラスであれば、新たなメソッドオブジェクトだけが生成されます。それ以外の場合には、もとのメソッドオブジェクトがそのまま使われます。</p>
<p id="index-40">クラスからユーザ定義関数オブジェクトを取得する方法でユーザ定義メソッドオブジェクトを生成すると、 <code class="xref py py-attr docutils literal"><span class="pre">im_self</span></code> 属性は <code class="docutils literal"><span class="pre">None</span></code> になり、メソッドオブジェクトは非結合 (unbound) であるといいます。クラスのインスタンスからユーザ定義関数オブジェクトを取得する方法でユーザ定義メソッドオブジェクトを生成すると、 <code class="xref py py-attr docutils literal"><span class="pre">im_self</span></code> 属性はインスタンスになり、メソッドオブジェクトは結合 (bound) であるといいます。どちらの場合も、新たなメソッドの <code class="xref py py-attr docutils literal"><span class="pre">im_class</span></code> 属性は、メソッドの取得が行われたクラスになり、 <code class="xref py py-attr docutils literal"><span class="pre">im_func</span></code> 属性はもとの関数オブジェクトになります。</p>
<p id="index-41">クラスやインスタンスから他のユーザ定義メソッドオブジェクトを取得する方法でユーザ定義メソッドオブジェクトを生成した場合、その動作は関数オブジェクトの場合と同様ですが、新たなインスタンスの <code class="xref py py-attr docutils literal"><span class="pre">im_func</span></code> 属性はもとのメソッドオブジェクトの属性ではなく、新たなインスタンスの属性になります。</p>
<p id="index-42">クラスやインスタンスからクラスメソッドオブジェクトを取得する方法でユーザ定義メソッドオブジェクトを生成した場合、 <code class="xref py py-attr docutils literal"><span class="pre">im_self</span></code> 属性はクラス自体となり、 <code class="xref py py-attr docutils literal"><span class="pre">im_func</span></code> 属性はクラスメソッドの根底にある関数オブジェクトになります。</p>
<p>非結合ユーザ定義メソッドオブジェクトの呼び出しの際には、根底にある関数 (<code class="xref py py-attr docutils literal"><span class="pre">im_func</span></code>) が呼び出されます。このとき、最初の引数は適切なクラス (<code class="xref py py-attr docutils literal"><span class="pre">im_class</span></code>) またはサブクラスのインスタンスでなければならないという制限が課されています。</p>
<p>結合ユーザ定義メソッドオブジェクトの呼び出しの際には、根底にある関数 (<code class="xref py py-attr docutils literal"><span class="pre">im_func</span></code>) が呼び出されます。このとき、クラスインスタンス (<code class="xref py py-attr docutils literal"><span class="pre">im_self</span></code>) が引数の先頭に挿入されます。例えば、関数 <code class="xref py py-meth docutils literal"><span class="pre">f()</span></code> の定義が入ったクラスを <code class="xref py py-class docutils literal"><span class="pre">C</span></code> とし、 <code class="docutils literal"><span class="pre">x</span></code> を <code class="xref py py-class docutils literal"><span class="pre">C</span></code> のインスタンスとすると、 <code class="docutils literal"><span class="pre">x.f(1)</span></code> の呼び出しは <code class="docutils literal"><span class="pre">C.f(x,</span> <span class="pre">1)</span></code> と同じになります。</p>
<p>ユーザ定義メソッドオブジェクトがクラスオブジェクトから派生した際、 <code class="xref py py-attr docutils literal"><span class="pre">im_self</span></code> に記憶されている &quot;クラスインスタンス&quot; はクラス自体になります。これは、 <code class="docutils literal"><span class="pre">x.f(1)</span></code> や <code class="docutils literal"><span class="pre">C.f(1)</span></code> の呼び出しが根底にある関数を <code class="docutils literal"><span class="pre">f</span></code> としたときの呼び出し <code class="docutils literal"><span class="pre">f(C,1)</span></code> と等価になるようにするためです。</p>
<p class="last">関数オブジェクトから (結合または非結合の) メソッドオブジェクトへの変換は、クラスやインスタンスから属性を取り出すたびに行われるので注意してください。場合によっては、属性をローカルな変数に代入しておき、その変数を使って関数呼び出しを行うと効果的な最適化になります。また、上記の変換はユーザ定義関数に対してのみ起こるので注意してください; その他の呼び出し可能オブジェクト (および呼び出し可能でない全てのオブジェクト) は、変換を受けずに取り出されます。それから、クラスインスタンスの属性になっているユーザ定義関数は、結合メソッドに変換できないと知っておくことも重要です; 結合メソッドへの変換が行われるのは、関数がクラスの一属性である場合 <em>だけ</em> です。</p>
</dd>
<dt>ジェネレータ関数 (generator function)</dt>
<dd><p class="first last" id="index-43"><a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 文 (<a class="reference internal" href="simple_stmts.html#yield"><span class="std std-ref">yield 文</span></a> の節を参照) を使う関数もしくはメソッドは <em class="dfn">ジェネレータ関数</em> と呼ばれます。そのような関数が呼び出されたときは常に、関数の本体を実行するのに使えるイテレータオブジェクトを返します: イテレータの <a class="reference internal" href="../library/stdtypes.html#iterator.next" title="iterator.next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a> メソッドを呼び出すと、 <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 文を使って値が提供されるまで関数を実行します。関数の <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> 文を実行するか終端に達したときは、 <a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 例外が送出され、イテレータが返すべき値の最後まで到達しています。</p>
</dd>
<dt>組み込み関数 (built-in function)</dt>
<dd><p class="first last" id="index-44">組み込み関数オブジェクトはC関数へのラッパーです。組み込み関数の例は <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> や <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal"><span class="pre">math.sin()</span></code></a> (<a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a> は標準の組み込みモジュール) です。引数の数や型は C 関数で決定されています。読み出し専用の特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code> は関数のドキュメンテーション文字列です。ドキュメンテーションがない場合は <code class="docutils literal"><span class="pre">None</span></code> になります;
<a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a> は関数の名前です;
<code class="xref py py-attr docutils literal"><span class="pre">__self__</span></code> は <code class="docutils literal"><span class="pre">None</span></code> に設定されています (組み込みメソッドの節も参照してください);
<code class="xref py py-attr docutils literal"><span class="pre">__module__</span></code> は、関数が定義されているモジュールの名前です。モジュール名がない場合は <code class="docutils literal"><span class="pre">None</span></code> になります。</p>
</dd>
<dt>組み込みメソッド (built-in method)</dt>
<dd><p class="first last" id="index-45">実際には組み込み関数を別の形で隠蔽したもので、こちらの場合には C 関数に渡される何らかのオブジェクトを非明示的な外部引数として持っています。組み込みメソッドの例は、 <em>alist</em> をリストオブジェクトとしたときの <code class="docutils literal"><span class="pre">alist.append()</span></code> です。この場合には、読み出し専用の属性 <code class="xref py py-attr docutils literal"><span class="pre">__self__</span></code> は <em>alist</em> で表されるオブジェクトになります。</p>
</dd>
<dt>クラス型 (class type)</dt>
<dd>クラス型、あるいは &quot;新しいクラス型 (new-style class)&quot; や呼び出し可能オブジェクトです。クラス型オブジェクトは通常、そのクラスの新たなインスタンスを生成する際のファクトリクラスとして振舞いますが、 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> をオーバライドして、バリエーションを持たせることもできます。呼び出しの際に使われた引数は <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> に渡され、さらに典型的な場合では新たなインスタンスを初期化するために <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> に渡されます。</dd>
<dt>旧クラス型 (classic class)</dt>
<dd><p class="first last" id="index-46">(旧) クラスオブジェクトは後で詳しく説明します。クラスオブジェクトが呼び出されると、新たにクラスインスタンス (後述) が生成され、返されます。この操作には、クラスの <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドの呼び出し (定義されている場合) が含まれています。呼び出しの際に使われた引数は、すべて <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドに渡されます。 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドがない場合、クラスは引数なしで呼び出さなければなりません。</p>
</dd>
<dt>クラスインスタンス (class instance)</dt>
<dd>クラスインスタンスは後で詳しく説明します。クラスインスタンスはクラスが <a class="reference internal" href="#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> メソッドを持っている場合にのみ呼び出すことができます; <code class="docutils literal"><span class="pre">x(arguments)</span></code> とすると、 <code class="docutils literal"><span class="pre">x.__call__(arguments)</span></code> 呼び出しを短く書けます。</dd>
</dl>
</dd>
<dt>モジュール (module)</dt>
<dd><p class="first" id="index-47">モジュールは <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文で import します (<a class="reference internal" href="simple_stmts.html#import"><span class="std std-ref">import 文</span></a> 参照)。モジュールオブジェクトは、辞書オブジェクト (モジュール内で定義されている関数が func_globals 属性で参照している辞書です) で実装された名前空間を持っています。属性への参照は、この辞書に対する検索 (lookup) に翻訳されます。例えば、 <code class="docutils literal"><span class="pre">m.x</span></code> は <code class="docutils literal"><span class="pre">m.__dict__[&quot;x&quot;]</span></code> と同じです。モジュールオブジェクトには、モジュールを初期化するために使われるコードオブジェクトは入っていません (一度初期化が終わればもう必要ないからです)。</p>
<p>属性の代入を行うと、モジュールの名前空間辞書の内容を更新します。例えば、 <code class="docutils literal"><span class="pre">m.x</span> <span class="pre">=</span> <span class="pre">1</span></code> は <code class="docutils literal"><span class="pre">m.__dict__[&quot;x&quot;]</span> <span class="pre">=</span> <span class="pre">1</span></code> と同じです。</p>
<p id="index-48">読み出し専用の特殊属性: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> はモジュールの名前空間で、辞書オブジェクトです。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> CPython がモジュール辞書を削除する方法により、モジュール辞書が生きた参照を持っていたとしてもその辞書はモジュールがスコープから外れた時に削除されます。これを避けるには、辞書をコピーするか、辞書を直接使っている間モジュールを保持してください。</p>
</div>
<p class="last" id="index-49">定義済みの (書き込み可能な) 属性: <code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code> はモジュールの名前です; <code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code> は関数のドキュメンテーション文字列です。ドキュメンテーションがない場合は <code class="docutils literal"><span class="pre">None</span></code> になります; モジュールがファイルからロードされた場合、 <code class="xref py py-attr docutils literal"><span class="pre">__file__</span></code> はロードされたモジュールファイルのパス名です。インタプリタに静的にリンクされている C モジュールの場合、 <code class="xref py py-attr docutils literal"><span class="pre">__file__</span></code> 属性はありません; 共有ライブラリから動的にロードされた拡張モジュールの場合、この属性は共有ライブラリファイルのパス名になります。</p>
</dd>
<dt>クラス</dt>
<dd><p class="first">2 種類のクラス、 type (新スタイルクラス) と class object (旧スタイルクラス) の両方とも、通常はクラス定義 (<a class="reference internal" href="compound_stmts.html#class"><span class="std std-ref">クラス定義</span></a> 参照) で生成されます。クラスは辞書で実装された名前空間を持っています。クラス属性への参照は、この辞書に対する検索 (lookup) に翻訳されます。例えば、 <code class="docutils literal"><span class="pre">C.x</span></code> は <code class="docutils literal"><span class="pre">C.__dict__[&quot;x&quot;]</span></code> と同じです。(ただし、特に新スタイルクラスにおいて、属性参照の意味を変えられる幾つかのフックがあります)。属性がこの検索で見つからない場合、現在のクラスの基底クラスへと検索を続けます。旧スタイルクラスの場合、検索は深さ優先 (depth-first)、かつ基底クラスの挙げられているリスト中の左から右 (left-to-right) の順番で行われます。新スタイルクラスは、より複雑な、C3メソッド解決順序(MRO=method resolution order) を利用していて、複数の継承パスが共通の祖先にたどり着く「ダイアモンド継承」があっても正しく動作します。 C3 MRO についてのより詳細な情報は、2.3リリースに付属するドキュメントにあります。 (<a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a>)</p>
<p id="index-50">クラス (<code class="xref py py-class docutils literal"><span class="pre">C</span></code> とします) への属性参照で、要求している属性がユーザ定義関数オブジェクトや、 <code class="xref py py-class docutils literal"><span class="pre">C</span></code> やその基底クラスに関連付けられている非結合のユーザ定義メソッドオブジェクトである場合、 <code class="xref py py-attr docutils literal"><span class="pre">im_class</span></code> 属性が <code class="xref py py-class docutils literal"><span class="pre">C</span></code> であるような非結合ユーザ定義メソッドオブジェクトに変換されます。要求している属性がクラスメソッドオブジェクトの場合、その <code class="xref py py-attr docutils literal"><span class="pre">im_self</span></code> 属性が <code class="xref py py-class docutils literal"><span class="pre">C</span></code> であるようなユーザ定義メソッドオブジェクトに変換されます。要求している属性が静的メソッドオブジェクトの場合、静的メソッドオブジェクトでラップされたオブジェクトに変換されます。クラスから取り出した属性と実際に <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> に入っているものが異なるような他の場合については、 <a class="reference internal" href="#descriptors"><span class="std std-ref">デスクリプタ (descriptor) の実装</span></a> を参照してください (新スタイルクラスだけがディスクリプタをサポートしていることに注意してください)。</p>
<p id="index-51">クラス属性を代入すると、そのクラスの辞書だけが更新され、基底クラスの辞書は更新しません。</p>
<p id="index-52">クラスオブジェクトを呼び出す (上記を参照) と、クラスインスタンスを生成します (下記を参照)。</p>
<p class="last" id="index-53">特殊属性: <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a> はクラス名です;
<code class="xref py py-attr docutils literal"><span class="pre">__module__</span></code> はクラスが定義されたモジュール名です;
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> はクラスが持つ名前空間が入った辞書です;
<a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal"><span class="pre">__bases__</span></code></a> は基底クラスからなるタプル (空もしくは要素が 1 つしかないこともあります) で、基底クラスのリストに表れる順序で並んでいます;
<code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code> はクラスのドキュメント文字列で、未定義の場合は None です。</p>
</dd>
<dt>クラスインスタンス (class instance)</dt>
<dd><p class="first" id="index-54">クラスインスタンスはクラスオブジェクト (上記参照) を呼び出して生成します。クラスインスタンスは辞書で実装された名前空間を持っており、属性参照の時にはこの辞書が最初に検索されます。辞書内に属性が見つからず、かつインスタンスのクラスに該当する属性名がある場合、検索はクラス属性にまで広げられます。見つかったクラス属性がユーザ定義関数オブジェクトや、インスタンスのクラス (<code class="xref py py-class docutils literal"><span class="pre">C</span></code> とします) やその基底クラスに関連付けられている非結合のユーザ定義メソッドオブジェクトの場合、 <code class="xref py py-attr docutils literal"><span class="pre">im_class</span></code> 属性が <code class="xref py py-class docutils literal"><span class="pre">C</span></code> で <code class="xref py py-attr docutils literal"><span class="pre">im_self</span></code> 属性がインスタンスになっている結合ユーザ定義メソッドオブジェクトに変換されます。静的メソッドやクラスメソッドオブジェクトもまた、 <code class="xref py py-class docutils literal"><span class="pre">C</span></code> から取り出した場合と同様に変換されます; 上記の &quot;クラス&quot; を参照してください。クラスから取り出した属性と実際に <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> に入っているものが異なるような他の場合については、 <a class="reference internal" href="#descriptors"><span class="std std-ref">デスクリプタ (descriptor) の実装</span></a> 節を参照してください。クラス属性が見つからず、かつオブジェクトのクラスが <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> メソッドを持っている場合、このメソッドを呼び出して属性名の検索を充足させます。</p>
<p id="index-55">属性の代入や削除を行うと、インスタンスの辞書を更新しますが、クラスの辞書を更新することはありません。クラスで <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> や <a class="reference internal" href="#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal"><span class="pre">__delattr__()</span></code></a> メソッドが定義されている場合、直接インスタンスの辞書を更新する代わりにこれらのメソッドが呼び出されます。</p>
<p id="index-56">クラスインスタンスは、ある特定の名前のメソッドを持っている場合、数値型やシーケンス型、あるいはマップ型のように振舞うことができます。 <a class="reference internal" href="#specialnames"><span class="std std-ref">特殊メソッド名</span></a> を参照してください。</p>
<p class="last" id="index-57">特殊属性: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> は属性の辞書です; <a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal"><span class="pre">__class__</span></code></a> はインスタンスのクラスです。</p>
</dd>
<dt>ファイル (file)</dt>
<dd><p class="first last" id="index-58">ファイルオブジェクトは開かれたファイルを表します。ファイルオブジェクトは組み込み関数 <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> や、 <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">os.popen()</span></code></a>, <a class="reference internal" href="../library/os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">os.fdopen()</span></code></a>, および socke オブジェクトの <code class="xref py py-meth docutils literal"><span class="pre">makefile()</span></code> メソッド (その他の拡張モジュールで提供されている関数やメソッド) で生成されます。 <code class="docutils literal"><span class="pre">sys.stdin</span></code>, <code class="docutils literal"><span class="pre">sys.stdout</span></code> および <code class="docutils literal"><span class="pre">sys.stderr</span></code> といったオブジェクトは、インタプリタの標準入力、標準出力、および標準エラー出力ストリームに対応するよう初期化されます。ファイルオブジェクトに関する完全な記述については、 <a class="reference internal" href="../library/stdtypes.html#bltin-file-objects"><span class="std std-ref">ファイルオブジェクト</span></a> を参照してください。</p>
</dd>
<dt>内部型 (internal type)</dt>
<dd><p class="first" id="index-59">インタプリタが内部的に使っているいくつかの型は、ユーザに公開されています。これらの定義は将来のインタプリタのバージョンでは変更される可能性がありますが、ここでは記述の完全性のために触れておきます。</p>
<dl class="docutils" id="index-60">
<dt>コードオブジェクト</dt>
<dd><p class="first">コードオブジェクトは <em>バイトコンパイルされた (byte-compiled)</em> 実行可能な Python コード、別名バイトコード(<a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>) を表現します。コードオブジェクトと関数オブジェクトの違いは、関数オブジェクトが関数のグローバル変数 (関数を定義しているモジュールのグローバル) に対して明示的な参照を持っているのに対し、コードオブジェクトにはコンテキストがないということです; また、関数オブジェクトではデフォルト引数値を記憶できますが、コードオブジェクトではできません (実行時に計算される値を表現するため)。関数オブジェクトと違い、コードオブジェクトは変更不可能で、変更可能なオブジェクトへの参照を (直接、間接に関わらず) 含みません。</p>
<p id="index-61">読み出し専用の特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">co_name</span></code> は関数名を表します; <code class="xref py py-attr docutils literal"><span class="pre">co_argcount</span></code> は固定引数 (positional argument) の数です; <code class="xref py py-attr docutils literal"><span class="pre">co_nlocals</span></code> は関数が使う (引数を含めた) ローカル変数の数です; <code class="xref py py-attr docutils literal"><span class="pre">co_varnames</span></code> はローカル変数名の入ったタプルです (引数名から始まっています); <code class="xref py py-attr docutils literal"><span class="pre">co_cellvars</span></code> はネストされた関数で参照されているローカル変数の名前が入ったタプルです; <code class="xref py py-attr docutils literal"><span class="pre">co_freevars</span></code> は自由変数の名前が入ったタプルです。 <code class="xref py py-attr docutils literal"><span class="pre">co_code</span></code> はバイトコード列を表現している文字列です; <code class="xref py py-attr docutils literal"><span class="pre">co_consts</span></code> はバイトコードで使われているリテラルの入ったタプルです; <code class="xref py py-attr docutils literal"><span class="pre">co_names</span></code> はバイトコードで使われている名前の入ったタプルです; <code class="xref py py-attr docutils literal"><span class="pre">co_filename</span></code> はバイトコードのコンパイルが行われたファイル名です; <code class="xref py py-attr docutils literal"><span class="pre">co_firstlineno</span></code> は関数の最初の行番号です; <code class="xref py py-attr docutils literal"><span class="pre">co_lnotab</span></code> はバイトコードオフセットから行番号への対応付けをコード化した文字列です (詳細についてはインタプリタのソースコードを参照してください); <code class="xref py py-attr docutils literal"><span class="pre">co_stacksize</span></code> は関数で (ローカル変数の分も含めて) 必要なスタックサイズです; <code class="xref py py-attr docutils literal"><span class="pre">co_flags</span></code> はインタプリタ用の様々なフラグをコード化した整数です。</p>
<p id="index-62">以下のフラグビットが <code class="xref py py-attr docutils literal"><span class="pre">co_flags</span></code> で定義されています: <code class="docutils literal"><span class="pre">0x04</span></code> ビットは、関数が <code class="docutils literal"><span class="pre">*arguments</span></code> 構文を使って任意の数の固定引数を受理できる場合に立てられます; <code class="docutils literal"><span class="pre">0x08</span></code> ビットは、関数が <code class="docutils literal"><span class="pre">**keywords</span></code> 構文を使ってキーワード引数を受理できる場合に立てられます; <code class="docutils literal"><span class="pre">0x20</span></code> ビットは、関数がジェネレータである場合に立てられます。</p>
<p>将来機能 (future feature) 宣言 (<code class="docutils literal"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>) もまた、 <code class="xref py py-attr docutils literal"><span class="pre">co_flags</span></code> のビットを立てることで、コードオブジェクトが特定の機能を有効にしてコンパイルされていることを示します: <code class="docutils literal"><span class="pre">0x2000</span></code> ビットは、関数が将来機能を有効にしてコンパイルされている場合に立てられます; 以前のバージョンの Python では、 <code class="docutils literal"><span class="pre">0x10</span></code> および <code class="docutils literal"><span class="pre">0x1000</span></code> ビットが使われていました。</p>
<p><code class="xref py py-attr docutils literal"><span class="pre">co_flags</span></code> のその他のビットは将来に内部的に利用するために予約されています。</p>
<p class="last" id="index-63">コードオブジェクトが関数を表現している場合、 <code class="xref py py-attr docutils literal"><span class="pre">co_consts</span></code> の最初の要素は関数のドキュメンテーション文字列になります。ドキュメンテーション文字列が定義されていない場合には <code class="docutils literal"><span class="pre">None</span></code> になります。</p>
</dd>
</dl>
<dl class="last docutils" id="frame-objects">
<dt>フレーム (frame) オブジェクト</dt>
<dd><p class="first" id="index-64">フレームオブジェクトは実行フレーム (execution frame) を表します。実行フレームはトレースバックオブジェクト内に出現します (下記参照)。</p>
<p id="index-65">読み出し専用の特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">f_back</span></code> は (呼び出し側にとっての) 以前のスタックフレームです。呼び出し側がスタックフレームの最下段である場合には <code class="docutils literal"><span class="pre">None</span></code> です; <code class="xref py py-attr docutils literal"><span class="pre">f_code</span></code> は現在のフレームで実行しようとしているコードオブジェクトです; <code class="xref py py-attr docutils literal"><span class="pre">f_locals</span></code> はローカル変数を検索するために使われる辞書です; <code class="xref py py-attr docutils literal"><span class="pre">f_globals</span></code> はグローバル変数用です; <code class="xref py py-attr docutils literal"><span class="pre">f_builtins</span></code> は組み込みの (Python 固有の) 名前です; <code class="xref py py-attr docutils literal"><span class="pre">f_restricted</span></code> は、関数が制限つき実行 (restricted execution) モードで実行されているかどうかを示すフラグです; <code class="xref py py-attr docutils literal"><span class="pre">f_lasti</span></code> は厳密な命令コード (コードオブジェクト中のバイトコード文字列へのインデクス) です。</p>
<p class="last" id="index-66">書き込み可能な特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">f_trace</span></code> が <code class="docutils literal"><span class="pre">None</span></code> でない場合、各ソースコード行の先頭で呼び出される関数になります; <code class="xref py py-attr docutils literal"><span class="pre">f_exc_type</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_exc_value</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_exc_traceback</span></code> は、現在のフレームが以前に引き起こした例外が提供する親フレーム内でもっとも最近捕捉された例外を表します (それ以外の場合は、これらは <code class="docutils literal"><span class="pre">None</span></code> になります); <code class="xref py py-attr docutils literal"><span class="pre">f_lineno</span></code> はフレーム中における現在の行番号です — トレース関数 (trace function) 側でこの値に書き込みを行うと、指定した行にジャンプします (最下段の実行フレームにいるときのみ) 。デバッガでは、 f_fileno を書き込むことで、ジャンプ命令 (Set Next Statement 命令とも呼ばれます) を実装できます。</p>
</dd>
<dt>トレースバック (traceback) オブジェクト</dt>
<dd><p class="first" id="index-67">トレースバックオブジェクトは例外のスタックトレースを表現します。トレースバックオブジェクトは例外が発生した際に生成されます。例外ハンドラを検索して実行スタックを戻っていく際、戻ったレベル毎に、トレースバックオブジェクトが現在のトレースバックの前に挿入されます。例外ハンドラに入ると、スタックトレースをプログラム側で利用できるようになります (<a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">try 文</span></a> を参照)。トレースバックは <code class="docutils literal"><span class="pre">sys.exc_traceback</span></code> として得ることができ、 <code class="docutils literal"><span class="pre">sys.exc_info()</span></code> が返すタプルの三番目の要素としても得られます. インタフェースとしては後者の方が推奨されていますが、これはプログラムがマルチスレッドを使っている場合に正しく動作するからです。プログラムに適切なハンドラがない場合、スタックトレースは (うまく書式化されて) 標準エラーストリームに書き出されます; インタプリタが対話的に実行されている場合、 <code class="docutils literal"><span class="pre">sys.last_traceback</span></code> として得ることもできます。</p>
<p class="last" id="index-68">読み出し専用の特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">tb_next</span></code> はスタックトレース内の (例外の発生しているフレームに向かって) 次のレベルです。次のレベルが存在しない場合には <code class="docutils literal"><span class="pre">None</span></code> になります; <code class="xref py py-attr docutils literal"><span class="pre">tb_frame</span></code> は現在のレベルにおける実行フレームを指します; <code class="xref py py-attr docutils literal"><span class="pre">tb_lineno</span></code> は例外の発生した行番号です; <code class="xref py py-attr docutils literal"><span class="pre">tb_lasti</span></code> は厳密な命令コードです。トレースバック内の行番号や最後に実行された命令は、 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a> 文内で例外が発生し、かつ対応する <a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> 節や <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 節がない場合には、フレームオブジェクト内の行番号とは異なるかもしれません。</p>
</dd>
<dt>スライス (slice) オブジェクト</dt>
<dd><p class="first" id="index-69">スライスオブジェクトは <em>拡張スライス構文 (extended slice syntax)</em> が使われた際にスライスを表現するために使われます。拡張スライス構文とは、二つのコロンや、コンマで区切られた複数のスライスや省略符号 (ellipse) を使ったスライスで、例えば <code class="docutils literal"><span class="pre">a[i:j:step]</span></code> 、 <code class="docutils literal"><span class="pre">a[i:j,</span> <span class="pre">k:l]</span></code> 、あるいは <code class="docutils literal"><span class="pre">a[...,</span> <span class="pre">i:j]</span></code> です。スライスオブジェクトは組み込み関数 <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-func docutils literal"><span class="pre">slice()</span></code></a> で生成されます。</p>
<p id="index-70">読み込み専用の特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">start</span></code> は下限です; <code class="xref py py-attr docutils literal"><span class="pre">stop</span></code> は上限です; <code class="xref py py-attr docutils literal"><span class="pre">step</span></code> はステップの値です; それぞれ省略された場合は <code class="docutils literal"><span class="pre">None</span></code> となっています。これらの属性は任意の型を持てます。</p>
<p>スライスオブジェクトはメソッドを一つサポートします:</p>
<dl class="last method">
<dt id="slice.indices">
<code class="descclassname">slice.</code><code class="descname">indices</code><span class="sig-paren">(</span><em>self</em>, <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#slice.indices" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは単一の整数引数 <em>length</em> を取り、 <em>length</em> 個の要素からなるシーケンスに適用した際にスライスオブジェクトから提供することになる、拡張スライスに関する情報を計算します。このメソッドは三つの整数からなるタプルを返します; それぞれ <em>start</em> および <em>stop</em> のインデクスと、 <em>step</em> またはスライス間の幅に対応します。インデクス値がないか、範囲外の値である場合、通常のスライスに対して一貫性のあるやりかたで扱われます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.3 で追加.</span></p>
</div>
</dd></dl>

</dd>
<dt>静的メソッド (static method) オブジェクト</dt>
<dd>静的メソッドは、上で説明したような関数オブジェクトからメソッドオブジェクトへの変換を阻止するための方法を提供します。静的メソッドオブジェクトは他の何らかのオブジェクト、通常はユーザ定義メソッドオブジェクトを包むラッパです。静的メソッドをクラスやクラスインスタンスから取得すると、実際に返されるオブジェクトはラップされたオブジェクトになり、それ以上は変換の対象にはなりません。静的メソッドオブジェクトは通常呼び出し可能なオブジェクトをラップしますが、静的オブジェクト自体は呼び出すことができません。静的オブジェクトは組み込みコンストラクタ <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></code></a> で生成されます。</dd>
<dt>クラスメソッドオブジェクト</dt>
<dd>クラスメソッドオブジェクトは、静的メソッドオブジェクトに似て、別のオブジェクトを包むラッパであり、そのオブジェクトをクラスやクラスインスタンスから取り出す方法を代替します。このようにして取得したクラスメソッドオブジェクトの動作については、上の &quot;ユーザ定義メソッド (user-defined method)&quot; で説明されています。クラスメソッドオブジェクトは組み込みのコンストラクタ <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal"><span class="pre">classmethod()</span></code></a> で生成されます。</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="new-style-and-classic-classes">
<span id="newstyle"></span><h2>3.3. 新スタイルと旧スタイル<a class="headerlink" href="#new-style-and-classic-classes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>クラスとインスタンスは好みに合わせて2種類の方法で記述することができます: 旧スタイル(もしくはクラシックスタイル)と新スタイルです。</p>
<p>Python 2.1 までは、 <code class="docutils literal"><span class="pre">class</span></code> の概念は <code class="docutils literal"><span class="pre">type</span></code> の概念とは無関係で、また、旧スタイルクラスが唯一のものでした。旧スタイルクラスでは、 <code class="docutils literal"><span class="pre">x.__class__</span></code> は <em>x</em> のクラスを提供はしますが、 <code class="docutils literal"><span class="pre">type(x)</span></code> は常に <code class="docutils literal"><span class="pre">&lt;type</span> <span class="pre">'instance'&gt;</span></code> になります。これは、すべての旧スタイルのインスタンスが、それらのクラスとは独立の、 <code class="docutils literal"><span class="pre">instance</span></code> と呼ばれる一つの内蔵型として実行されるということを反映しています。</p>
<p>新スタイルのクラスは、　<code class="docutils literal"><span class="pre">class</span></code> と <code class="docutils literal"><span class="pre">type</span></code> の概念を統一するために Python 2.2 で導入されました。新スタイルのクラスはユーザ定義型そのもので、それ以上でも以下でもありません。もし、 <em>x</em> が新スタイルクラスのインスタンスであった場合、 <code class="docutils literal"><span class="pre">type(x)</span></code> は <code class="docutils literal"><span class="pre">x.__class__</span></code> と同じになります。 (ただし、これは保証されている動作ではありません – 新スタイルクラスのインスタンスは、 <code class="docutils literal"><span class="pre">x.__class__</span></code> で返る値をオーバーライドすることができます。)</p>
<p>新スタイルクラスを導入する一番の理由は、メタモデルを用いた統一的なオブジェクトモデルを提供することにあります。また、ほとんどの組み込み型のサブクラスが作成できる、属性を計算するための&quot;デスクリプタ&quot;の導入できる等の利点があります。</p>
<p>互換性のために、デフォルトではクラスは旧スタイルになります。新スタイルのクラスは、他の新スタイルクラス (すなわち型)を親クラスとして定義する、もしくは、他の親クラスが必要ない場合に &quot;最上位型&quot; <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> を継承することで作成することができます。新スタイルクラスの動作は旧スタイルクラスの動作とは、 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a> が何を返すかといったことをはじめ、何点か重要な部分が異なります。特殊メソッドの呼び出しなど、これらの変更は新オブジェクトモデルの基盤となっています。それ以外の部分は、多重継承時のメソッドの解決順などのように、互換性の問題で以前は実装が不可能であった&quot;修正&quot;が新クラスに含まれています。</p>
<p>このマニュアルは Python のクラスメカニズムに関する総合的な情報を提供しようとしていますが、新スタイルクラスについては、まだ足りない部分があるかもしれません。より詳細な情報を得たい場合は、 <a class="reference external" href="https://www.python.org/doc/newstyle/">https://www.python.org/doc/newstyle/</a> を参照してください。</p>
<p id="index-71">Python 3 では旧スタイルクラスが削除されて、新スタイルクラスが唯一のクラスになりました。</p>
</div>
<div class="section" id="special-method-names">
<span id="specialnames"></span><h2>3.4. 特殊メソッド名<a class="headerlink" href="#special-method-names" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-72">特殊な名前をもったメソッドを定義することで、特殊な構文 (算術演算や添え字表記、スライス表記のような) 特定の演算をクラスで実装することができます。これは、個々のクラスが Python 言語で提供されている演算子に対応した独自の振る舞いをできるようにするための、演算子のオーバロード (<em class="dfn">operator overloading</em>) に対する Python のアプローチです。例えば、あるクラスが <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> という名前のメソッドを定義しており、 <code class="docutils literal"><span class="pre">x</span></code> がこのクラスのインスタンスであるとすると、 <code class="docutils literal"><span class="pre">x[i]</span></code> は旧スタイルクラスの場合 <code class="docutils literal"><span class="pre">x.__getitem__(i)</span></code> と、新スタイルクラスの場合 <code class="docutils literal"><span class="pre">type(x).__getitem__(x,</span> <span class="pre">i)</span></code> とほぼ等価になります。特に注釈のない限り、適切なメソッドが定義されていない場合にこのような演算を行おうとすると例外が送出されます。 (発生する例外はたいてい、 <a class="reference internal" href="../library/exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> か <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> です。)</p>
<p>組み込み型を模倣するクラスを実装するときは、真似されるオブジェクトにとって意味がある範囲に実装をとどめるのが重要です。例えば、あるシーケンスは個々の要素の取得はきちんと動くかもしれませんが、スライスの展開が意味を為さないかもしれません。 (W3C のドキュメントオブジェクトモデルにある <code class="xref py py-class docutils literal"><span class="pre">NodeList</span></code> インターフェースがその一例です。)</p>
<div class="section" id="basic-customization">
<span id="customization"></span><h3>3.4.1. 基本的なカスタマイズ<a class="headerlink" href="#basic-customization" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="method">
<dt id="object.__new__">
<code class="descclassname">object.</code><code class="descname">__new__</code><span class="sig-paren">(</span><em>cls</em><span class="optional">[</span>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__new__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-73">クラス <em>cls</em> の新しいインスタンスを作るために呼び出されます。 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> は静的メソッドで (このメソッドは特別扱いされているので、明示的に静的メソッドと宣言する必要はありません)、インスタンスを生成するよう要求されているクラスを第一引数にとります。残りの引数はオブジェクトのコンストラクタの式 (クラスの呼び出し文) に渡されます。 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> の戻り値は新しいオブジェクトのインスタンス (通常は <em>cls</em> のインスタンス) でなければなりません。</p>
<p>典型的な実装では、クラスの新たなインスタンスを生成するときには <code class="docutils literal"><span class="pre">super(currentclass,</span> <span class="pre">cls).__new__(cls[,</span> <span class="pre">...])</span></code> に適切な引数を指定してスーパクラスの <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> メソッドを呼び出し、新たに生成されたインスタンスに必要な変更を加えてから返します。</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> が <em>cls</em> のインスタンスを返した場合、 <code class="docutils literal"><span class="pre">__init__(self[,</span> <span class="pre">...])</span></code> のようにしてインスタンスの <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> が呼び出されます。このとき、 <em>self</em> は新たに生成されたインスタンスで、残りの引数は <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> に渡された引数と同じになります。</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> が <em>cls</em> のインスタンスを返さない場合、インスタンスの <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドは呼び出されません。</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> の主な目的は、変更不能な型 (int, str, tuple など) のサブクラスでインスタンス生成をカスタマイズすることにあります。また、クラス生成をカスタマイズするために、カスタムのメタクラスでよくオーバーライドされます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__init__">
<code class="descclassname">object.</code><code class="descname">__init__</code><span class="sig-paren">(</span><em>self</em><span class="optional">[</span>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-74">インスタンスが (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> によって) 生成された後、それが呼び出し元に返される前に呼び出されます。引数はクラスのコンストラクタ式に渡したものです。基底クラスとその派生クラスがともに <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドを持つ場合、派生クラスの <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドは基底クラスの <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドを明示的に呼び出して、インスタンスの基底クラス部分が適切に初期化されること保証しなければなりません。例えば、 <code class="docutils literal"><span class="pre">BaseClass.__init__(self,</span> <span class="pre">[args...])</span></code> 。</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> と <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> は共同してオブジェクトを構成する (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> が作成し、 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> がそれをカスタマイズする) ので、 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> が非 <code class="docutils literal"><span class="pre">None</span></code> 値を返すことがあってはなりません; さもなければ、実行時に <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出される原因になります。</p>
</dd></dl>

<dl class="method">
<dt id="object.__del__">
<code class="descclassname">object.</code><code class="descname">__del__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__del__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-75">インスタンスが消滅させられる際に呼び出されます。このメソッドはデストラクタ (destructor)  とも呼ばれます。基底クラスとその派生クラスがともに <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドを持つ場合、派生クラスの <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドは基底クラスの <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドを明示的に呼び出して、インスタンスの基底クラス部分が適切に消滅処理されること保証しなければなりません。 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドでインスタンスに対する新たな参照を作ることで、インスタンスの消滅を遅らせることができます (とはいえ、推奨しません！)。このようにすると、新たに作成された参照がその後削除された際にもう一度 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドが呼び出されます。インタプリタが終了する際に残っているオブジェクトに対して、 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドが呼び出される保証はありません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal"><span class="pre">del</span> <span class="pre">x</span></code> は直接 <code class="docutils literal"><span class="pre">x.__del__()</span></code> を呼び出しません — 前者は <code class="docutils literal"><span class="pre">x</span></code> への参照カウント (reference count) を 1 つ減らし、後者は <code class="docutils literal"><span class="pre">x</span></code> への参照カウントがゼロになった際にのみ呼び出されます。オブジェクトへの参照カウントがゼロになるのを妨げる可能性のあるよくある状況には、以下のようなものがあります: 複数のオブジェクト間における循環参照 (二重リンクリストや、親と子へのポインタを持つツリーデータ構造); 例外を捕捉した関数におけるスタックフレーム上にあるオブジェクトへの参照 (<code class="docutils literal"><span class="pre">sys.exc_traceback</span></code> に記憶されているトレースバックが、スタックフレームを生き延びさせます); または、対話モードでハンドルされなかった例外を送出したスタックフレーム上にあるオブジェクトへの参照 (<code class="docutils literal"><span class="pre">sys.last_traceback</span></code> に記憶されているトレースバックが、スタックフレームを生き延びさせます); 最初の状況については、明示的に循環参照を壊すしか解決策はありません; 後者の二つの状況は、 <code class="docutils literal"><span class="pre">None</span></code> を <code class="docutils literal"><span class="pre">sys.exc_traceback</span></code> や <code class="docutils literal"><span class="pre">sys.last_traceback</span></code> に入れることで解決できます。ごみオブジェクトと化した循環参照は、オプションの循環参照検出機構 (cycle detector) が有効にされている場合 (これはデフォルトの設定です) には検出されますが、検出された循環参照を消去するのは Python レベルで <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドが定義されていない場合だけです。 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドが循環参照検出機構でどのように扱われるか、とりわけ <code class="docutils literal"><span class="pre">garbage</span></code> 値の記述に関しては、 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal"><span class="pre">gc</span></code></a> モジュールのドキュメントを参照してください。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last"><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドの呼び出しが起きるのは不安定な状況下なので、 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> の実行中に発生した例外は無視され、代わりに <code class="docutils literal"><span class="pre">sys.stderr</span></code> に警告が出力されます。また、 (例えばプログラムの実行終了による) モジュールの削除に伴って <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> が呼び出される際には、 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドが参照している他のグローバル変数はすでに削除されていたり、削除中(例えば、import機構のシャットダウン中)かもしれません。この理由から、 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドでは外部の不変関係を維持する上で絶対最低限必要なことだけをすべきです。バージョン 1.5 からは、単一のアンダースコアで始まるようなグローバル変数は、他のグローバル変数が削除される前にモジュールから削除されるように Python 側で保証しています; これらのアンダースコア付きグローバル変数は、 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> が呼び出された際に、import されたモジュールがまだ残っているか確認する上で役に立ちます。</p>
</div>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-r"><code class="xref std std-option docutils literal"><span class="pre">-R</span></code></a> コマンドラインオプションも参照して下さい。</p>
</dd></dl>

<dl class="method">
<dt id="object.__repr__">
<code class="descclassname">object.</code><code class="descname">__repr__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__repr__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-76">組み込み関数 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> や、文字列への変換 (逆クオート表記: reverse quote) の際に呼び出され、オブジェクトを表す &quot;公式の (official)&quot; 文字列を計算します。可能な場合には、この値は同じ値を持ったオブジェクトを (適切な環境で) 再生成するために使えるような有効な Python 式に似せるべきです。それが不可能なら、 <code class="docutils literal"><span class="pre">&lt;...some</span> <span class="pre">useful</span> <span class="pre">description...&gt;</span></code> 形式の文字列を返してください。戻り値は文字列オブジェクトでなければなりません。クラスが <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></code></a> を定義しているが <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal"><span class="pre">__str__()</span></code></a> を定義していない場合、そのクラスのインスタンスに対する &quot;非公式の (informal)&quot; 文字列表現が必要なときにも <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></code></a> が使われます。</p>
<p id="index-77">この関数はデバッグの際によく用いられるので、たくさんの情報を含み、あいまいでないような表記にすることが重要です。</p>
</dd></dl>

<dl class="method">
<dt id="object.__str__">
<code class="descclassname">object.</code><code class="descname">__str__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__str__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-78">組み込み関数 <a class="reference internal" href="../library/functions.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> および <a class="reference internal" href="simple_stmts.html#print"><code class="xref std std-keyword docutils literal"><span class="pre">print</span></code></a> 文によって呼び出され、オブジェクトを表す &quot;非公式の&quot; 文字列を計算します。このメソッドは、有効な Python 式を返さなくても良いという点で、 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></code></a> と異なります: その代わり、より便利で分かりやすい表現を返すようにしてください。戻り値は文字列オブジェクトでなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__lt__">
<code class="descclassname">object.</code><code class="descname">__lt__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lt__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__le__">
<code class="descclassname">object.</code><code class="descname">__le__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__le__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__eq__">
<code class="descclassname">object.</code><code class="descname">__eq__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__eq__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ne__">
<code class="descclassname">object.</code><code class="descname">__ne__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ne__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__gt__">
<code class="descclassname">object.</code><code class="descname">__gt__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__gt__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ge__">
<code class="descclassname">object.</code><code class="descname">__ge__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ge__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified">バージョン 2.1 で追加.</span></p>
</div>
<p id="index-79">これらのメソッドは &quot;拡張比較 (rich comparison)&quot; メソッドと呼ばれ、下記の <a class="reference internal" href="#object.__cmp__" title="object.__cmp__"><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code></a> に優先して呼び出されます。演算子シンボルとメソッド名の対応は以下の通りです: <code class="docutils literal"><span class="pre">x&lt;y</span></code> は <code class="docutils literal"><span class="pre">x.__lt__(y)</span></code> を呼び出します; <code class="docutils literal"><span class="pre">x&lt;=y</span></code> は <code class="docutils literal"><span class="pre">x.__le__(y)</span></code> を呼び出します; <code class="docutils literal"><span class="pre">x==y</span></code> は <code class="docutils literal"><span class="pre">x.__eq__(y)</span></code> を呼び出します; <code class="docutils literal"><span class="pre">x!=y</span></code> および <code class="docutils literal"><span class="pre">x&lt;&gt;y</span></code> は <code class="docutils literal"><span class="pre">x.__ne__(y)</span></code> を呼び出します; <code class="docutils literal"><span class="pre">x&gt;y</span></code> は <code class="docutils literal"><span class="pre">x.__gt__(y)</span></code> を呼び出します; <code class="docutils literal"><span class="pre">x&gt;=y</span></code> は <code class="docutils literal"><span class="pre">x.__ge__(y)</span></code> を呼び出します。</p>
<p>拡張比較メソッドは、与えられた引数のペアに対する操作を実装していないときに、 <code class="docutils literal"><span class="pre">NotImplemented</span></code> というシングルトンを返すかもしれません。慣例として、正常に比較が行われたときには <code class="docutils literal"><span class="pre">False</span></code> か <code class="docutils literal"><span class="pre">True</span></code> を返します。しかし、これらのメソッドは任意の値を返すことができるので、比較演算子がブール値のコンテキスト(たとえば、 <code class="docutils literal"><span class="pre">if</span></code> 文の条件部分)で使われた場合、 Python はその値に対して <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal"><span class="pre">bool()</span></code></a> を呼び出して結果の真偽を判断します。</p>
<p>比較演算子間には、暗黙的な論理関係はありません。すなわち、 <code class="docutils literal"><span class="pre">x==y</span></code> が真である場合、暗黙のうちに <code class="docutils literal"><span class="pre">x!=y</span></code> が偽になるわけではありません。従って、 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> を実装する際、演算子が期待通りに動作するようにするために <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal"><span class="pre">__ne__()</span></code></a> も定義する必要があります。カスタムの比較演算をサポートしていて、辞書のキーに使うことができるハッシュ可能(<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>) オブジェクトを作るときの重要な注意点について、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> のドキュメント内に書かれているので参照してください。</p>
<p>これらのメソッドには、(左引数が演算をサポートしないが、右引数はサポートする場合に用いられるような) 鏡像となる (引数を入れ替えた) バージョンは存在しません; むしろ、 <a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a> と <a class="reference internal" href="#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal"><span class="pre">__gt__()</span></code></a> は互いに鏡像であり、 <a class="reference internal" href="#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal"><span class="pre">__le__()</span></code></a> と <a class="reference internal" href="#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal"><span class="pre">__ge__()</span></code></a> 、および <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> と <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal"><span class="pre">__ne__()</span></code></a> はそれぞれ互いに鏡像です。</p>
<p>拡張比較メソッドの引数には型強制 (coerce) が起こりません。</p>
<p>単一の基本演算から順序付けするための演算を自動的に生成したい場合には、 <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal"><span class="pre">functools.total_ordering()</span></code></a> を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="object.__cmp__">
<code class="descclassname">object.</code><code class="descname">__cmp__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__cmp__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-80">拡張比較 (上参照) が定義されていない場合、比較演算によって呼び出されます。 <code class="docutils literal"><span class="pre">self</span> <span class="pre">&lt;</span> <span class="pre">other</span></code> である場合には負の値、 <code class="docutils literal"><span class="pre">self</span> <span class="pre">==</span> <span class="pre">other</span></code> ならばゼロ、 <code class="docutils literal"><span class="pre">self</span> <span class="pre">&gt;</span> <span class="pre">other</span></code> であれば正の値を返さなければなりません。演算 <a class="reference internal" href="#object.__cmp__" title="object.__cmp__"><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code></a> 、 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> および <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal"><span class="pre">__ne__()</span></code></a> がいずれも定義されていない場合、クラスインスタンスはオブジェクトのアイデンティティ(&quot;アドレス&quot;) で比較されます。自作の比較演算をサポートするオブジェクトや、辞書のキーとして使えるオブジェクトを生成するには、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> に関する記述を参照してください。 (注意: <a class="reference internal" href="#object.__cmp__" title="object.__cmp__"><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code></a> が例外を伝播しないという制限は Python 1.5 から除去されました。)</p>
</dd></dl>

<dl class="method">
<dt id="object.__rcmp__">
<code class="descclassname">object.</code><code class="descname">__rcmp__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rcmp__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="versionchanged">
<p><span class="versionmodified">バージョン 2.1 で変更: </span>もはやサポートされていません.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__hash__">
<code class="descclassname">object.</code><code class="descname">__hash__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__hash__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-81">組み込みの <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a> 関数や、 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> のようなハッシュを使ったコレクション型の要素に対する操作から呼び出されます。
<a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> は整数を返さなければなりません。このメソッドに必要な性質は、比較結果が等しいオブジェクトは同じハッシュ値を持つということです;
オブジェクトを比較するときでも利用される要素をタプルに詰めてハッシュ値を計算することで、それぞれの要素のハッシュ値を混合することをおすすめします。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nick</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">))</span>
</pre></div>
</div>
<p>クラスが <a class="reference internal" href="#object.__cmp__" title="object.__cmp__"><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code></a> や <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> メソッドを定義していない場合、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> メソッドも定義してはなりません; クラスが <a class="reference internal" href="#object.__cmp__" title="object.__cmp__"><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code></a> または <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> を定義しているが、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> を定義していない場合、インスタンスを辞書のキーとして使うことはできません。クラスが変更可能なオブジェクトを定義しており、 <a class="reference internal" href="#object.__cmp__" title="object.__cmp__"><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code></a> または <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> メソッドを実装している場合、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> を定義してはなりません。これは、辞書の実装においてハッシュ値が変更不能であることが要求されているからです (オブジェクトのハッシュ値が変化すると、キーが誤ったハッシュバケツ (hash bucket) に入っていることになってしまいます)。</p>
<p>ユーザー定義クラスはデフォルトで <a class="reference internal" href="#object.__cmp__" title="object.__cmp__"><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code></a> と <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> メソッドを持っています。これらは、同一以外のすべてのオブジェクトに対して比較結果が偽になり、 <code class="docutils literal"><span class="pre">x.__hash__()</span></code> は <code class="docutils literal"><span class="pre">id(x)</span></code> から得られる結果を返します。</p>
<p>親クラスから <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> メソッドを継承して、 <a class="reference internal" href="#object.__cmp__" title="object.__cmp__"><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code></a> か <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> の意味を変更している(例えば、デフォルトの同一性ベースの同値関係から値ベースの同値関係に変更する) クラスのハッシュ値は妥当ではなくなるので、 <code class="docutils literal"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> をクラス定義に書く事で、明示的にハッシュ不可能であることを宣言できます。こうすると、プログラムがそのクラスのインスタンスのハッシュ値を取得しようとしたときに適切な <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外を送出するようになるだけでなく、 (<a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を発生させる <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> メソッドを持つクラスと違って) <code class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">collections.Hashable)</span></code> をチェックしたときに、ハッシュ不可能と判定されるようになります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.5 で変更: </span><a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> は現在では長整数オブジェクトも返せるようになりました。 32ビット整数はこのオブジェクトのハッシュから導出されます。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>クラスのインスタンスがハッシュ不可能であることを明示的に宣言するために、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-attr docutils literal"><span class="pre">__hash__</span></code></a> に <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を設定することができるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__nonzero__">
<code class="descclassname">object.</code><code class="descname">__nonzero__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__nonzero__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-82">真値テストや組み込み演算 <code class="docutils literal"><span class="pre">bool()</span></code> を実現するために呼び出されます; <code class="docutils literal"><span class="pre">False</span></code> または <code class="docutils literal"><span class="pre">True</span></code> か、等価な整数値 <code class="docutils literal"><span class="pre">0</span></code> または <code class="docutils literal"><span class="pre">1</span></code> を返さなければなりません。このメソッドが定義されていない場合、 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> が定義されていれば呼び出され、その結果が nonzero であれば真になります。 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> と <a class="reference internal" href="#object.__nonzero__" title="object.__nonzero__"><code class="xref py py-meth docutils literal"><span class="pre">__nonzero__()</span></code></a> のどちらもクラスで定義されていない場合、そのクラスのインスタンスはすべて真の値を持つものとみなされます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__unicode__">
<code class="descclassname">object.</code><code class="descname">__unicode__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__unicode__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-83">組み込み関数 <a class="reference internal" href="../library/functions.html#unicode" title="unicode"><code class="xref py py-func docutils literal"><span class="pre">unicode()</span></code></a> を実現するために呼び出されます。Unicode オブジェクトを返さなければなりません。このメソッドが定義されていなければ、文字列への変換が試みられ、その結果がデフォルトの文字エンコードを用いて Unicode に変換されます。</p>
</dd></dl>

</div>
<div class="section" id="customizing-attribute-access">
<span id="attribute-access"></span><h3>3.4.2. 属性値アクセスをカスタマイズする<a class="headerlink" href="#customizing-attribute-access" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のメソッドを定義して、クラスインスタンスへの属性値アクセス ( 属性値の使用、属性値への代入、 <code class="docutils literal"><span class="pre">x.name</span></code> の削除) の意味をカスタマイズすることができます。</p>
<dl class="method">
<dt id="object.__getattr__">
<code class="descclassname">object.</code><code class="descname">__getattr__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattr__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>属性値の検索を行った結果、通常の場所に属性値が見つからなかった場合 (すなわち、 <code class="docutils literal"><span class="pre">self</span></code> のインスタンス属性でなく、かつクラスツリーにも見つからなかった場合) に呼び出されます。<code class="docutils literal"><span class="pre">name</span></code> は属性名です。このメソッドは (計算された) 属性値を返すか、 <a class="reference internal" href="../library/exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> 例外を送出しなければなりません。</p>
<p id="index-84">通常のメカニズムを介して属性値が見つかった場合、 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> は呼び出されないので注意してください。(これは、 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> と <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> の間に意図的に導入された非対称性です。) これは、効率性のためと、こうしなければ <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> がインスタンスの他の属性値にアクセスする方法がなくなるためです。少なくともインスタンス変数に対しては、値をインスタンスの属性値辞書に挿入しないようにして (代わりに他のオブジェクトに挿入することで) 属性値が完全に制御されているように見せかけられることに注意してください。新スタイルクラスで実際に完全な制御を行う方法は、以下の <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></code></a> メソッドを参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="object.__setattr__">
<code class="descclassname">object.</code><code class="descname">__setattr__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setattr__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>属性値への代入が試みられた際に呼び出されます。このメソッドは通常の代入メカニズム (すなわち、インスタンス辞書への値の代入) の代わりに呼び出されます。 <em>name</em> は属性名で、 <em>value</em> はその属性に代入する値です。</p>
<p id="index-85"><a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> の中でインスタンス属性値への代入が必要な場合、単に <code class="docutils literal"><span class="pre">self.name</span> <span class="pre">=</span> <span class="pre">value</span></code> としてはなりません — このようにすると、自分自身に対する再帰呼び出しがおきてしまいます。その代わりに、インスタンス属性の辞書に値を挿入してください。例えば、 <code class="docutils literal"><span class="pre">self.__dict__[name]</span> <span class="pre">=</span> <span class="pre">value</span></code> とします。新しい形式のクラスでは、インスタンス辞書にアクセスするのではなく、基底クラスのメソッドを同じ属性名で呼び出します。例えば、 <code class="docutils literal"><span class="pre">object.__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></code> とします。</p>
</dd></dl>

<dl class="method">
<dt id="object.__delattr__">
<code class="descclassname">object.</code><code class="descname">__delattr__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delattr__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> に似ていますが、代入ではなく値の削除を行います。このメソッドを実装するのは、オブジェクトにとって <code class="docutils literal"><span class="pre">del</span> <span class="pre">obj.name</span></code> が意味がある場合だけにしなければなりません。</p>
</dd></dl>

<div class="section" id="more-attribute-access-for-new-style-classes">
<span id="new-style-attribute-access"></span><h4>3.4.2.1. 新しい形式のクラスのための別の属性アクセス<a class="headerlink" href="#more-attribute-access-for-new-style-classes" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>以下のメソッドは新しい形式のクラス (new-style class) のみに適用されます。</p>
<dl class="method">
<dt id="object.__getattribute__">
<code class="descclassname">object.</code><code class="descname">__getattribute__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattribute__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラスのインスタンスに対する属性アクセスを実装するために、無条件に呼び出されます。クラスが <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> も定義している場合、 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> は、 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></code></a> で明示的に呼び出すか、 <a class="reference internal" href="../library/exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> 例外を送出しない限り呼ばれません。このメソッドは (計算された) 属性値を返すか、 <a class="reference internal" href="../library/exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> 例外を送出します。このメソッドが再帰的に際限なく呼び出されてしまうのを防ぐため、実装の際には常に、必要な属性全てへのアクセスで、例えば <code class="docutils literal"><span class="pre">object.__getattribute__(self,</span> <span class="pre">name)</span></code> のように基底クラスのメソッドを同じ属性名を使って呼び出さなければなりません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">ビルトイン関数や言語構文により暗黙的に特殊メソッドが検索されるときは、このメソッドの呼び出しはバイパスされるでしょう。 <a class="reference internal" href="#new-style-special-lookup"><span class="std std-ref">新スタイルクラスの特殊メソッド検索</span></a> を参照してください。</p>
</div>
</dd></dl>

</div>
<div class="section" id="implementing-descriptors">
<span id="descriptors"></span><h4>3.4.2.2. デスクリプタ (descriptor) の実装<a class="headerlink" href="#implementing-descriptors" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>以下のメソッドは、このメソッドを持つクラス (いわゆる <em>デスクリプタ(descriptor)</em> クラス) のインスタンスが、 <em>オーナー (owner)</em> クラスに存在するときにのみ適用されます (デスクリプタは、オーナーのクラス辞書か、その親のいずれかのクラス辞書になければなりません)。以下の例では、&quot;属性&quot; とは、名前がオーナークラスの <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> のプロパティ (porperty) のキーであるような属性を指します。</p>
<dl class="method">
<dt id="object.__get__">
<code class="descclassname">object.</code><code class="descname">__get__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em>, <em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__get__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オーナクラスの属性を取得する (クラス属性へのアクセス) 際や、オーナクラスのインスタンスの属性を取得する (インスタンス属性へのアクセス) 場合に呼び出されます。 <em>owner</em> は常にオーナクラスです。一方、 <em>instance</em> は属性へのアクセスを仲介するインスタンスか属性が <em>owner</em> を介してアクセスされる場合は <code class="docutils literal"><span class="pre">None</span></code> になります。このメソッドは (計算された) 属性値を返すか、 <a class="reference internal" href="../library/exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> 例外を送出しなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__set__">
<code class="descclassname">object.</code><code class="descname">__set__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オーナクラスのインスタンス <em>instance</em> 上の属性を新たな値 <em>value</em> に設定する際に呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__delete__">
<code class="descclassname">object.</code><code class="descname">__delete__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delete__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オーナクラスのインスタンス <em>instance</em> 上の属性を削除する際に呼び出されます。</p>
</dd></dl>

</div>
<div class="section" id="invoking-descriptors">
<span id="descriptor-invocation"></span><h4>3.4.2.3. デスクリプタの呼び出し<a class="headerlink" href="#invoking-descriptors" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>一般にデスクリプタとは、特殊な &quot;束縛に関する動作 (binding behaviour)&quot; をもつオブジェクト属性のことです。デスクリプタは、デスクリプタプロトコル (descriptor protocol) のメソッド: <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal"><span class="pre">__set__()</span></code></a>, および <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal"><span class="pre">__delete__()</span></code></a> を使って、属性アクセスをオーバライドしているものです。これらのメソッドのいずれかがオブジェクトに対して定義されている場合、オブジェクトはデスクリプタであるといいます。</p>
<p>属性アクセスのデフォルトの動作は、オブジェクトの辞書から値を取り出したり、値を設定したり、削除したりするというものです。例えば、 <code class="docutils literal"><span class="pre">a.x</span></code> による属性の検索では、まず <code class="docutils literal"><span class="pre">a.__dict__['x']</span></code> 、次に <code class="docutils literal"><span class="pre">type(a).__dict__['x']</span></code> 、そして <code class="docutils literal"><span class="pre">type(a)</span></code> の基底クラスでメタクラスでないものに続く、といった具合に連鎖が起こります。</p>
<p>しかしながら、検索対象となる値が、デスクリプタメソッドのいずれかを定義しているオブジェクトの属性値である場合、Python はデフォルトの動作をオーバライドして、デスクリプタメソッドの方を呼び出します。前後する呼び出し連鎖の中のどこでデスクリプタメソッドが呼び出されるかは、どのデスクリプタメソッドが定義されているかと、どうやってデスクリプタメソッドが呼ばれるかに依存します。デスクリプタは新しい形式のオブジェクトやクラス (<a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object()</span></code></a> や <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal"><span class="pre">type()</span></code></a> をサブクラス化したもの) だけに対して呼び出されるので注意してください。</p>
<p>デスクリプタ呼び出しの基点となるのは、属性名への束縛 (binding) 、すなわち <code class="docutils literal"><span class="pre">a.x</span></code> です。引数がどのようにデスクリプタに結合されるかは <code class="docutils literal"><span class="pre">a</span></code> に依存します:</p>
<dl class="docutils">
<dt>直接呼び出し (Direct Call)</dt>
<dd>最も単純で、かつめったに使われない呼び出し操作は、コード中で直接デスクリプタメソッドの呼び出し: <code class="docutils literal"><span class="pre">x.__get__(a)</span></code> を行うというものです。</dd>
<dt>インスタンス束縛 (Instance Binding)</dt>
<dd>新しい形式のクラスのインスタンスに対する束縛では、 <code class="docutils literal"><span class="pre">a.x</span></code> は呼び出し: <code class="docutils literal"><span class="pre">type(a).__dict__['x'].__get__(a,</span> <span class="pre">type(a))</span></code> に変換されます。</dd>
<dt>クラス束縛 (Class Binding)</dt>
<dd>新しい形式のクラスに対する束縛では、 <code class="docutils literal"><span class="pre">A.x</span></code> は呼び出し: <code class="docutils literal"><span class="pre">A.__dict__['x'].__get__(None,</span> <span class="pre">A)</span></code> に変換されます。</dd>
<dt>super 束縛 (Super Binding)</dt>
<dd><code class="docutils literal"><span class="pre">a</span></code> が <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-class docutils literal"><span class="pre">super</span></code></a> のインスタンスである場合、束縛 <code class="docutils literal"><span class="pre">super(B,</span> <span class="pre">obj).m()</span></code> を行うとまず <code class="docutils literal"><span class="pre">A</span></code> 、続いて <code class="docutils literal"><span class="pre">B</span></code> に対して <code class="docutils literal"><span class="pre">obj.__class_.__mro__</span></code> を検索し、次に呼び出し: <code class="docutils literal"><span class="pre">A.__dict__['m'].__get__(obj,</span> <span class="pre">obj.__class__)</span></code> でデスクリプタを呼び出します。</dd>
</dl>
<p>インスタンス束縛では、デスクリプタ呼び出しの優先順位はどのデスクリプタが定義されているかに依存します。データデスクリプタは、 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a> と <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal"><span class="pre">__set__()</span></code></a> 、 <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal"><span class="pre">__delete__()</span></code></a> の任意の組合せを定義することができます。 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a> が定義されない場合には、その属性にアクセスすると、そのオブジェクトのインスタンス辞書にその値がある場合を除けば、デスクリプタオブジェクト自身が返ってきます。デスクリプタが <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal"><span class="pre">__set__()</span></code></a> と <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal"><span class="pre">__delete__()</span></code></a> またはそのどちらかを定義していれば、データデスクリプタとなります; もし両方とも定義しなければ、非データデスクリプタです。通常、データデスクリプタでは、 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a> と <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal"><span class="pre">__set__()</span></code></a> を定義し、一方、非データデスクリプタには <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a> メソッドしかありません。 <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal"><span class="pre">__set__()</span></code></a> と <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a> を定義したデータデスクリプタは、インスタンス辞書内で属性値が再定義されても、常にこの値をオーバライドします。対照的に、非データデスクリプタの場合には、属性値はインスタンス側でオーバライドされます。</p>
<p>(<a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></code></a> や <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal"><span class="pre">classmethod()</span></code></a> を含む) Python メソッドは、非データデスクリプタとして実装されています。その結果、インスタンスではメソッドを再定義したりオーバライドできます。このことにより、個々のインスタンスが同じクラスの他のインスタンスと互いに異なる動作を獲得することができます。</p>
<p><a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal"><span class="pre">property()</span></code></a> 関数はデータデスクリプタとして実装されています。従って、インスタンスはあるプロパティの動作をオーバライドすることができません。</p>
</div>
<div class="section" id="slots">
<span id="id2"></span><h4>3.4.2.4. __slots__<a class="headerlink" href="#slots" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>デフォルトでは、新旧どちらのクラスも、属性の記憶領域として使うための辞書を持っています。この仕様は、ほとんどインスタンス変数を持たないようなオブジェクトの場合には記憶領域の無駄遣いになります。記憶領域の消費量は、大量のインスタンスを生成する際には深刻です。</p>
<p>このデフォルトの設定は、新たな形式のクラス定義において <em>__slots__</em> を定義することでオーバライドできます。 <em>__slots_</em> 宣言はインスタンス変数のシーケンスを受け取ります。各々のインスタンス上には、各変数の値を記憶するのにちょうど必要な量だけの記憶領域を確保します。各々のインスタンスに対して <em>__dict__</em> が生成されることがないので、記憶領域が節約されます。</p>
<dl class="data">
<dt id="__slots__">
<code class="descname">__slots__</code><a class="headerlink" href="#__slots__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラス変数には、文字列、反復可能オブジェクト、あるいはインスタンスが用いる変数名を表す文字列からなるシーケンスを代入することができます。この変数が新しい形式のクラスで定義されている場合、 <em>__slots__</em> は、各インスタンスに対して宣言された変数に必要な記憶領域を確保し、 <em>__dict__</em> と <em>__weakref__</em> が自動的に生成されないようにします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.2 で追加.</span></p>
</div>
</dd></dl>

<p><em>__slots__</em> を利用する際の注意</p>
<ul>
<li><p class="first"><em>__slots__</em> を持たないクラスから継承する場合、 <em>__dict__</em> 属性は常にアクセス可能なので、サブクラスで <em>__slots__</em> を定義しても意味がありません。</p>
</li>
<li><p class="first"><em>__dict__</em> 変数がない場合、 <em>__slots__</em> に列挙されていない新たな変数をインスタンスに代入することはできません。列挙されていない変数名を使って代入しようとした場合、 <a class="reference internal" href="../library/exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> が送出されます。新たな変数を動的に代入したいのなら、 <em>__slots__</em> を宣言する際に <code class="docutils literal"><span class="pre">'__dict__'</span></code> を変数名のシーケンスに追加してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.3 で変更: </span>これまでは、 <code class="docutils literal"><span class="pre">'__dict__'</span></code> を <em>__slots__</em> 宣言に追加しても、インスタンス変数名として他にリストされていない新たな属性の代入はできませんでした。</p>
</div>
</li>
<li><p class="first"><em>__slots__</em> を定義しているクラスの各インスタンスに <em>__weakref__</em> 変数がない場合、インスタンスに対する弱参照 (weak reference) はサポートされません。弱参照のサポートが必要なら、 <em>__slots__</em> を宣言する際に <code class="docutils literal"><span class="pre">'__weakref__'</span></code> を変数名のシーケンスに追加してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.3 で変更: </span>これまでは、 <code class="docutils literal"><span class="pre">'__weakref__'</span></code> を <em>__slots__</em> 宣言に追加しても、弱参照のサポートを有効にできませんでした。</p>
</div>
</li>
<li><p class="first"><em>__slots__</em> は、クラスのレベルで各変数に対するデスクリプタ (<a class="reference internal" href="#descriptors"><span class="std std-ref">デスクリプタ (descriptor) の実装</span></a> を参照) を使って実装されます。その結果、 <em>__slots__</em> に定義されているインスタンス変数のデフォルト値はクラス属性を使って設定できなくなっています; そうしないと、デスクリプタによる代入をクラス属性が上書きしてしまうからです。</p>
</li>
<li><p class="first"><em>__slots__</em> 宣言が動作するのは、定義が行われたクラスだけに限られています。その結果、サブクラスでは、 <em>__slots__</em> を定義しない限り <em>__dict__</em> を持つことになります。</p>
</li>
<li><p class="first">あるクラスで、基底クラスですでに定義されているスロットを定義した場合、基底クラスのスロットで定義されているインスタンス変数は (デスクリプタを基底クラスから直接取得しない限り) アクセスできなくなります。これにより、プログラムの趣意が不定になってしまいます。将来は、この問題を避けるために何らかのチェックが追加されるかもしれません。</p>
</li>
<li><p class="first">空でない <em>__slots__</em> は、 <a class="reference internal" href="../library/functions.html#long" title="long"><code class="xref py py-class docutils literal"><span class="pre">long</span></code></a> 、 <a class="reference internal" href="../library/functions.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 、および <a class="reference internal" href="../library/functions.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> といった、&quot;可変長 (variable-length)&quot; の組み込み型から派生したクラスでは動作しません。</p>
</li>
<li><p class="first"><em>__slots__</em> には、文字列でない反復可能オブジェクトを代入することができます。辞書型も使うことができます; しかし将来、辞書の各キーに相当する値に何らかの特殊な意味が割り当てられるかもしれません。</p>
</li>
<li><p class="first"><em>__class__</em> への代入は、両方のクラスが同じ <em>__slots__</em> を持っているときのみ動作します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.6 で変更: </span>以前は、新旧どちらかのクラスが <em>__slots__</em> を持っていたら <em>__class__</em> への代入はエラーを発生していました。</p>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="customizing-class-creation">
<span id="metaclasses"></span><h3>3.4.3. クラス生成をカスタマイズする<a class="headerlink" href="#customizing-class-creation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>デフォルトでは、新スタイルクラスは <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a> を使って構築されます。クラス定義が別の名前空間に読み込まれ、クラス名は <code class="docutils literal"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">dict)</span></code> の結果に結合されます。</p>
<p>クラス定義が読み込まれる際、 <em>__metaclass__</em> が定義されていれば、 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a> の代わりに <em>__metaclass__</em> が指している呼び出し可能オブジェクトが呼び出されます。これによって、</p>
<ul class="simple">
<li>クラスが生成される前にクラス辞書を変更する</li>
<li>他のクラスのインスタンスを返す – 本質的にはファクトリ関数の役割を果たす</li>
</ul>
<p>これらのステップは、メタクラスの <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> メソッドで実行されなければなりません。 – このメソッドから他の属性を持ったクラスを作るには、 <code class="xref py py-meth docutils literal"><span class="pre">type.__new__()</span></code> を呼び出すことができます。次の例ではクラスを生成する前に新しい要素をクラス辞書に追加しています。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">metacls</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="nb">dict</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;metacls was here&#39;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
</pre></div>
</div>
<p>もちろん、他のクラスメソッドをオーバーライドする(または新しいメソッドを追加する)こともできます。例えば、カスタムの <a class="reference internal" href="#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> メソッドをメタクラスに定義して、新しいインスタンスを常には造らないといったカスタムの動作を実装できます。</p>
<dl class="data">
<dt id="__metaclass__">
<code class="descname">__metaclass__</code><a class="headerlink" href="#__metaclass__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この変数は <code class="docutils literal"><span class="pre">name</span></code> 、 <code class="docutils literal"><span class="pre">bases</span></code> 、および <code class="docutils literal"><span class="pre">dict</span></code> を引数として取るような任意の呼び出し可能オブジェクトにできます。クラス生成の際、組み込みの <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a> の代わりに、指定された呼び出しオブジェクトが呼び出されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.2 で追加.</span></p>
</div>
</dd></dl>

<p>以下に優先順で並んだ規則によって、適切なメタクラスが決定されます:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">dict['__metaclass__']</span></code> があればそれを使います。</li>
<li>それ以外の場合で、最低でも一つ基底クラスを持っているなら、基底クラスのメタクラス (<em>__class__</em> 属性を探し、なければ基底クラスの型) を使います。</li>
<li>それ以外の場合で、__metaclass__ という名前のグローバル変数があれば、それをつかいます。</li>
<li>それ以外の場合には、旧スタイルのメタクラス (types.ClassType) を使います。</li>
</ul>
<p>メタクラスは限りない潜在的利用価値を持っています。これまで試されてきたアイデアには、ログ記録、インタフェースのチェック、自動デリゲーション、自動プロパティ生成、プロキシ、フレームワーク、そして自動リソースロック／同期といったものがあります。</p>
</div>
<div class="section" id="customizing-instance-and-subclass-checks">
<h3>3.4.4. インスタンスのカスタマイズとサブクラスチェック<a class="headerlink" href="#customizing-instance-and-subclass-checks" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
<p>以下のメソッドは組み込み関数 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> と <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal"><span class="pre">issubclass()</span></code></a> のデフォルトの動作を上書きするのに利用します。</p>
<p>特に、 <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal"><span class="pre">abc.ABCMeta</span></code></a> メタクラスは、抽象基底クラス (ABCs) を&quot;仮想基底クラス (virtual base classes)&quot; として、他の ABC を含む、任意のクラスや (組み込み型を含む) 型に追加するために、これらのメソッドを実装しています。</p>
<dl class="method">
<dt id="class.__instancecheck__">
<code class="descclassname">class.</code><code class="descname">__instancecheck__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#class.__instancecheck__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>instance</em> が (直接、または間接的に) <em>class</em> のインスタンスと考えられる場合に true を返します。定義されていれば、 <code class="docutils literal"><span class="pre">isinstance(instance,</span> <span class="pre">class)</span></code> の実装のために呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="class.__subclasscheck__">
<code class="descclassname">class.</code><code class="descname">__subclasscheck__</code><span class="sig-paren">(</span><em>self</em>, <em>subclass</em><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasscheck__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>subclass</em> が (直接、または間接的に) <em>class</em> のサブクラスと考えられる場合に true を返します。定義されていれば、 <code class="docutils literal"><span class="pre">issubclass(subclass,</span> <span class="pre">class)</span></code> の実装のために呼び出されます。</p>
</dd></dl>

<p>なお、これらのメソッドは、クラスの型 (メタクラス) 上で検索されます。実際のクラスにクラスメソッドとして定義することはできません。これは、インスタンスそれ自体がクラスであるこの場合にのみ、インスタンスに呼び出される特殊メソッドの検索と一貫しています。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-100"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3119"><strong>PEP 3119</strong></a> - 抽象基底クラスの導入</dt>
<dd>抽象基底クラス (<a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to PEP 3119."><code class="xref py py-mod docutils literal"><span class="pre">abc</span></code></a> モジュールを参照) を言語に追加する文脈においての動機から、 <a class="reference internal" href="#class.__instancecheck__" title="class.__instancecheck__"><code class="xref py py-meth docutils literal"><span class="pre">__instancecheck__()</span></code></a> と <a class="reference internal" href="#class.__subclasscheck__" title="class.__subclasscheck__"><code class="xref py py-meth docutils literal"><span class="pre">__subclasscheck__()</span></code></a> を通して、 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> と <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal"><span class="pre">issubclass()</span></code></a> に独自の動作をさせるための仕様の記述があります。</dd>
</dl>
</div>
</div>
<div class="section" id="emulating-callable-objects">
<span id="callable-types"></span><h3>3.4.5. 呼び出し可能オブジェクトをエミュレートする<a class="headerlink" href="#emulating-callable-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="method">
<dt id="object.__call__">
<code class="descclassname">object.</code><code class="descname">__call__</code><span class="sig-paren">(</span><em>self</em><span class="optional">[</span>, <em>args...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__call__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-87">インスタンスが関数として &quot;呼ばれた&quot; 際に呼び出されます; このメソッドが定義されている場合、 <code class="docutils literal"><span class="pre">x(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> は <code class="docutils literal"><span class="pre">x.__call__(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> を短く書いたものになります。</p>
</dd></dl>

</div>
<div class="section" id="emulating-container-types">
<span id="sequence-types"></span><h3>3.4.6. コンテナをエミュレートする<a class="headerlink" href="#emulating-container-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のメソッドを定義して、コンテナオブジェクトを実装することができます。コンテナは通常、(リストやタプルのような) シーケンスや、(辞書のような) マップ型を指しますが、他のコンテナも同じように表現することができます。最初の一連のメソッドは、シーケンスをエミュレートしたり、マップ型をエミュレートするために使われます; その違いとして、シーケンスの場合には、キーとして許されているのが、シーケンスの長さが <em>N</em> であるときの <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">N</span></code> なる整数 <em>k</em> か、あるいは要素の範囲を表すスライスオブジェクトでなければならないということです。 (後方互換性のため、 <a class="reference internal" href="#object.__getslice__" title="object.__getslice__"><code class="xref py py-meth docutils literal"><span class="pre">__getslice__()</span></code></a> (以下参照) を定義して、拡張されていない単純なスライスを扱うようにもできます。)変更可能なシーケンスでは、Python の標準リストオブジェクトのように、メソッド <code class="xref py py-meth docutils literal"><span class="pre">append()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">count()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">extend()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">insert()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">reverse()</span></code>,および <code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code> を提供しなければなりません。マップ型でも、Python の標準辞書オブジェクトのように、 <code class="xref py py-meth docutils literal"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">items()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">has_key()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">get()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">setdefault()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">iterkeys()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">itervalues()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">iteritems()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">popitem()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code>,および <code class="xref py py-meth docutils literal"><span class="pre">update()</span></code> といったメソッドをマップ型で提供するよう推奨しています。 <a class="reference internal" href="../library/userdict.html#module-UserDict" title="UserDict: Class wrapper for dictionary objects."><code class="xref py py-mod docutils literal"><span class="pre">UserDict</span></code></a> モジュールでは、これらのメソッドを <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal"><span class="pre">__delitem__()</span></code></a>,および <code class="xref py py-meth docutils literal"><span class="pre">keys()</span></code> といった基本セットから作成する上で役に立つ <code class="xref py py-class docutils literal"><span class="pre">DictMixin</span></code> クラスを提供しています。最後に、シーケンス型では以下に述べるメソッド群 <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal"><span class="pre">__add__()</span></code></a>, <a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal"><span class="pre">__radd__()</span></code></a>, <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal"><span class="pre">__iadd__()</span></code></a>, <a class="reference internal" href="#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal"><span class="pre">__mul__()</span></code></a>, <a class="reference internal" href="#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal"><span class="pre">__rmul__()</span></code></a>,および <a class="reference internal" href="#object.__imul__" title="object.__imul__"><code class="xref py py-meth docutils literal"><span class="pre">__imul__()</span></code></a> を定義して、 (シーケンス間の結合を意味する) 加算操作と (要素の繰り返しを意味する) 乗算操作を実装しなければなりません; <a class="reference internal" href="#object.__coerce__" title="object.__coerce__"><code class="xref py py-meth docutils literal"><span class="pre">__coerce__()</span></code></a> や、その他の数値演算子を定義してはなりません。マップでもシーケンスでも、 <code class="docutils literal"><span class="pre">in</span></code> 演算子が有効利用できるように <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a> メソッドの定義を推奨します; マップ型では、 <code class="docutils literal"><span class="pre">in</span></code> は <code class="xref py py-meth docutils literal"><span class="pre">has_key()</span></code> と等価でなければなりません; シーケンスでは、シーケンス内の値にわたって検索を行わなければなりません。さらに、マップでもシーケンスでも、コンテナ内にわたる反復操作ができるようにするため、 <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> を実装するよう勧めます; マップ型の場合、 <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> は <code class="xref py py-meth docutils literal"><span class="pre">iterkeys()</span></code> と等価でなければなりません; シーケンスの場合、シーケンス内の値にわたって反復操作を行わなければなりません。</p>
<dl class="method">
<dt id="object.__len__">
<code class="descclassname">object.</code><code class="descname">__len__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__len__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-88">組み込み関数 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> を実現するために呼び出されます。オブジェクトの長さを <code class="docutils literal"><span class="pre">&gt;=</span></code> 0 である整数で返さなければなりません。また、オブジェクトが <a class="reference internal" href="#object.__nonzero__" title="object.__nonzero__"><code class="xref py py-meth docutils literal"><span class="pre">__nonzero__()</span></code></a> メソッドを定義しておらず、 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> メソッドがゼロを返す場合には、ブール演算コンテキストでは偽であるとみなされます。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> CPython では、オブジェクトの長さは最大でも <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal"><span class="pre">sys.maxsize</span></code></a> であることが要求されます。長さが <code class="xref py py-attr docutils literal"><span class="pre">sys.maxsize</span></code> を越える場合、(<a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> のような) いくつかの機能は <a class="reference internal" href="../library/exceptions.html#exceptions.OverflowError" title="exceptions.OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> を送出するでしょう。真偽値としての判定で <code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code> を送出しないようにするには、オブジェクトは meth:<cite>__nonzero__</cite> メソッドを定義していなければなりません。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__getitem__">
<code class="descclassname">object.</code><code class="descname">__getitem__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getitem__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-89"><code class="docutils literal"><span class="pre">self[key]</span></code> の値評価 (evaluation) を実現するために呼び出されます。シーケンスの場合、キーとして整数とスライスオブジェクトを受理できなければなりません。 (シーケンス型をエミュレートする場合) 負のインデクスの解釈は <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッド次第となります。 <em>key</em> が不適切な型であった場合、 <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出してもかまいません; (負のインデクス値に対して何らかの解釈を行った上で) <em>key</em> がシーケンスのインデクス集合外の値である場合、 <a class="reference internal" href="../library/exceptions.html#exceptions.IndexError" title="exceptions.IndexError"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code></a> を送出しなければなりません。マップ型の場合は、 <em>key</em> に誤りがある場合（コンテナに含まれていない場合）、 <a class="reference internal" href="../library/exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出しなければなりません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループでは、シーケンスの終端を正しく検出できるようにするために、不正なインデクスに対して <a class="reference internal" href="../library/exceptions.html#exceptions.IndexError" title="exceptions.IndexError"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code></a> が送出されるものと期待しています。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__missing__">
<code class="descclassname">object.</code><code class="descname">__missing__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__missing__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">self[key]</span></code> の実装において辞書内にキーが存在しなかった場合に、 dict のサブクラスのために <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>.<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> によって呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__setitem__">
<code class="descclassname">object.</code><code class="descname">__setitem__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setitem__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">self[key]</span></code> に対する代入を実現するために呼び出されます。 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> と同じ注意事項があてはまります。このメソッドを実装できるのは、あるキーに対する値の変更をサポートしているか、新たなキーを追加できるようなマップの場合と、ある要素を置き換えることができるシーケンスの場合だけです。不正な <em>key</em> に対しては、 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドと同様の例外の送出を行わなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__delitem__">
<code class="descclassname">object.</code><code class="descname">__delitem__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delitem__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">self[key]</span></code> の削除を実現するために呼び出されます。 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> と同じ注意事項があてはまります。このメソッドを実装できるのは、キーの削除をサポートしているマップの場合と、要素を削除できるシーケンスの場合だけです。不正な <em>key</em> に対しては、 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドと同様の例外の送出を行わなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__iter__">
<code class="descclassname">object.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、コンテナに対してイテレータが要求された際に呼び出されます。このメソッドは、コンテナ内の全てのオブジェクトにわたる反復処理ができるような、新たなイテレータオブジェクトを返さなければなりません。マップの場合、コンテナ内のキーに渡る反復処理でなければならず、かつ <code class="xref py py-meth docutils literal"><span class="pre">iterkeys()</span></code> によって利用できなければなりません。</p>
<p>イテレータオブジェクトでもこのメソッドを実装する必要があります; イテレータの場合、自分自身を返さなければなりません。イテレータオブジェクトに関するより詳細な情報は、 <a class="reference internal" href="../library/stdtypes.html#typeiter"><span class="std std-ref">イテレータ型</span></a> を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="object.__reversed__">
<code class="descclassname">object.</code><code class="descname">__reversed__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__reversed__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal"><span class="pre">reversed()</span></code></a> 組み込み関数が逆方向イテレーションを実装するために、(存在すれば)呼び出します。コンテナ内の全要素を逆順にイテレートする、新しいイテレータを返すべきです。</p>
<p><a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal"><span class="pre">__reversed__()</span></code></a> メソッドが定義されていない場合、 <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal"><span class="pre">reversed()</span></code></a> 組込み関数は sequence プロトコル (<a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> と <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a>) を使った方法にフォールバックします。 sequence プロトコルをサポートしたオブジェクトは、 <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal"><span class="pre">reversed()</span></code></a> よりも効率のいい実装を提供できる場合にのみ <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal"><span class="pre">__reversed__()</span></code></a> を定義するべきです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.6 で追加.</span></p>
</div>
</dd></dl>

<p>メンバシップテスト演算子 (<a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> および <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a>) は通常、シーケンスに渡る反復処理を使って実装されます。しかし、コンテナオブジェクトで以下の特殊メソッドを定義して、より効率的な実装を行ったり、オブジェクトがシーケンスでなくてもよいようにできます。</p>
<dl class="method">
<dt id="object.__contains__">
<code class="descclassname">object.</code><code class="descname">__contains__</code><span class="sig-paren">(</span><em>self</em>, <em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__contains__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メンバシップテスト演算を実現するために呼び出されます。 <em>item</em> が <em>self</em> 内に存在する場合には真を、そうでない場合には偽を返さなければなりません。マップオブジェクトの場合、値やキーと値の組ではなく、キーに対するメンバシップテストを考えなければなりません。</p>
<p><a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a> を定義しないオブジェクトに対しては、メンバシップテストはまず、 <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> を使った反復を試みます、次に古いシーケンス反復プロトコル <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> を使います、 <a class="reference internal" href="expressions.html#membership-test-details"><span class="std std-ref">言語レファレンスのこの節</span></a> を参照して下さい。</p>
</dd></dl>

</div>
<div class="section" id="additional-methods-for-emulation-of-sequence-types">
<span id="sequence-methods"></span><h3>3.4.7. シーケンス型エミュレーションで使われるその他のメソッド<a class="headerlink" href="#additional-methods-for-emulation-of-sequence-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のオプションとなるメソッドを定義して、シーケンスオブジェクトをより高度にエミュレーションできます。変更不能なシーケンスのメソッドでは、 <a class="reference internal" href="#object.__getslice__" title="object.__getslice__"><code class="xref py py-meth docutils literal"><span class="pre">__getslice__()</span></code></a> が定義できるだけです; 変更可能なシーケンスでは三つのメソッド全てを定義できます。</p>
<dl class="method">
<dt id="object.__getslice__">
<code class="descclassname">object.</code><code class="descname">__getslice__</code><span class="sig-paren">(</span><em>self</em>, <em>i</em>, <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getslice__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">バージョン 2.0 で撤廃: </span>スライスオブジェクトは <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドのパラメタとしてサポートするようになりました。 (しかし、現在の CPython はいまだに <a class="reference internal" href="#object.__getslice__" title="object.__getslice__"><code class="xref py py-meth docutils literal"><span class="pre">__getslice__()</span></code></a> を実装しています。なので、派生クラスでスライスを実装する場合は、このメソッドをオーバーライドしなければなりません。)</p>
</div>
<p><code class="docutils literal"><span class="pre">self[i:j]</span></code> の値評価を実現するために呼び出されます。返されるオブジェクトは <em>self</em> と同じ型でなければなりません。スライス表記で <em>i</em> や <em>j</em> がない場合には、それぞれゼロや <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal"><span class="pre">sys.maxsize</span></code></a> に置き換えられるので注意してください。スライスに負のインデクスが用いられた場合、シーケンスの長さがインデクス値に加算されます。インスタンスが <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> メソッドを実装していない場合には、 <a class="reference internal" href="../library/exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> が送出されます。この計算の結果、インデクス値が負でなくなるという保証はありません。シーケンスの長さよりも大きなインデクス値は修正されません。 <a class="reference internal" href="#object.__getslice__" title="object.__getslice__"><code class="xref py py-meth docutils literal"><span class="pre">__getslice__()</span></code></a> が定義されていない場合、代わりにスライスオブジェクトが生成されて <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> に渡されます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__setslice__">
<code class="descclassname">object.</code><code class="descname">__setslice__</code><span class="sig-paren">(</span><em>self</em>, <em>i</em>, <em>j</em>, <em>sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setslice__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">self[i:j]</span></code> への代入を実現するために呼び出されます。 <em>i</em> および <em>j</em> に関しては、 <a class="reference internal" href="#object.__getslice__" title="object.__getslice__"><code class="xref py py-meth docutils literal"><span class="pre">__getslice__()</span></code></a> と同じ注釈があてはまります。</p>
<p>このメソッドは撤廃されています。 <a class="reference internal" href="#object.__setslice__" title="object.__setslice__"><code class="xref py py-meth docutils literal"><span class="pre">__setslice__()</span></code></a> がないか、 <code class="docutils literal"><span class="pre">self[i:j:k]</span></code> 形式の拡張スライスの場合には、 <a class="reference internal" href="#object.__setslice__" title="object.__setslice__"><code class="xref py py-meth docutils literal"><span class="pre">__setslice__()</span></code></a> が呼ばれる代わりにスライスオブジェクトが生成され、 <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal"><span class="pre">__setitem__()</span></code></a> に渡されます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__delslice__">
<code class="descclassname">object.</code><code class="descname">__delslice__</code><span class="sig-paren">(</span><em>self</em>, <em>i</em>, <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delslice__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">self[i:j]</span></code> の削除を実現するために呼び出されます。 <em>i</em> および <em>j</em> に関しては、 <a class="reference internal" href="#object.__getslice__" title="object.__getslice__"><code class="xref py py-meth docutils literal"><span class="pre">__getslice__()</span></code></a> と同じ注釈があてはまります。このメソッドは撤廃されています。 <a class="reference internal" href="#object.__delslice__" title="object.__delslice__"><code class="xref py py-meth docutils literal"><span class="pre">__delslice__()</span></code></a> がないか、 <code class="docutils literal"><span class="pre">self[i:j:k]</span></code> 形式の拡張スライスの場合には、 <a class="reference internal" href="#object.__delslice__" title="object.__delslice__"><code class="xref py py-meth docutils literal"><span class="pre">__delslice__()</span></code></a> が呼ばれる代わりにスライスオブジェクトが生成され、 <a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal"><span class="pre">__delitem__()</span></code></a> に渡されます。</p>
</dd></dl>

<p>これらのメソッドは、単一のコロンを使った単一のスライスで、かつスライスメソッドが利用できるときにだけ呼び出されることに注意してください。拡張スライス表記を含んでいるスライス表記や、スライスメソッドがない場合、 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> 、 <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal"><span class="pre">__setitem__()</span></code></a> 、あるいは <a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal"><span class="pre">__delitem__()</span></code></a> がスライスオブジェクトを引数として呼び出されます。</p>
<p>以下の例は、プログラムやモジュールを以前のバージョンの Python に対して互換性を持たせる方法を示したものです (<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> 、 <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal"><span class="pre">__setitem__()</span></code></a> 、および <a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal"><span class="pre">__delitem__()</span></code></a> は引数としてスライスオブジェクトをサポートするものと仮定します):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="c1"># They won&#39;t be defined if version is at least 2.0 final</span>

        <span class="k">def</span> <span class="nf">__getslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">):]</span>
        <span class="k">def</span> <span class="nf">__setslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">):]</span> <span class="o">=</span> <span class="n">seq</span>
        <span class="k">def</span> <span class="nf">__delslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">):]</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a> を呼び出していることに注意してください; この呼び出し <code class="xref py py-meth docutils literal"><span class="pre">__*slice__()</span></code> メソッド呼び出される前に、負のインデクス値を処理しておくために必要です。負のインデクス値が使われた場合、 <code class="xref py py-meth docutils literal"><span class="pre">__*item__()</span></code> メソッドは与えられた値をそのまま使いますが、 <code class="xref py py-meth docutils literal"><span class="pre">__*slice__()</span></code> メソッドは &quot;調理済みの (cooked)&quot; 形式になったインデクス値を受け取ります。負のインデクス値が使われると、メソッドを呼び出す前に、常にシーケンスの長さをインデクス値に加算します (加算してもまだ負の値となっていてもかまいません); これは、組み込みシーケンス型における慣習的な負のインデクス処理方法で、 <code class="xref py py-meth docutils literal"><span class="pre">__*item__()</span></code> メソッドでも同様の処理を行うよう期待しています。しかし、ここではすでに負のインデクス値の処理を行っているので、負のインデクスを渡すべきではありません; インデクス値は、 <code class="xref py py-meth docutils literal"><span class="pre">__*item__()</span></code> メソッドに渡される前に、シーケンスのインデクス集合の境界に制限されていなければなりません。 <code class="docutils literal"><span class="pre">max(0,</span> <span class="pre">i)</span></code> を呼び出せば、適切な値を返すので便利です。</p>
</div>
<div class="section" id="emulating-numeric-types">
<span id="numeric-types"></span><h3>3.4.8. 数値型をエミュレーションする<a class="headerlink" href="#emulating-numeric-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のメソッドを定義して、数値型オブジェクトをエミュレートすることができます。特定の種類の数値型ではサポートされていないような演算に対応するメソッド (非整数の数値に対するビット単位演算など) は、未定義のままにしておかなければなりません。</p>
<dl class="method">
<dt id="object.__add__">
<code class="descclassname">object.</code><code class="descname">__add__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__add__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__sub__">
<code class="descclassname">object.</code><code class="descname">__sub__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__sub__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__mul__">
<code class="descclassname">object.</code><code class="descname">__mul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__floordiv__">
<code class="descclassname">object.</code><code class="descname">__floordiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floordiv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__mod__">
<code class="descclassname">object.</code><code class="descname">__mod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__divmod__">
<code class="descclassname">object.</code><code class="descname">__divmod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__divmod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__pow__">
<code class="descclassname">object.</code><code class="descname">__pow__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="optional">[</span>, <em>modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__pow__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__lshift__">
<code class="descclassname">object.</code><code class="descname">__lshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rshift__">
<code class="descclassname">object.</code><code class="descname">__rshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__and__">
<code class="descclassname">object.</code><code class="descname">__and__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__and__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__xor__">
<code class="descclassname">object.</code><code class="descname">__xor__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__xor__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__or__">
<code class="descclassname">object.</code><code class="descname">__or__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__or__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-90">これらのメソッドは、二項算術演算 (<code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">//</span></code>, <code class="docutils literal"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a>, <code class="docutils literal"><span class="pre">**</span></code>, <code class="docutils literal"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal"><span class="pre">&amp;</span></code>, <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">|</span></code>) を実現するために呼び出されます。例えば、式 <code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> の場合、 <em>x</em> が <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal"><span class="pre">__add__()</span></code></a> メソッドをもつクラスのインスタンスであれば、 <code class="docutils literal"><span class="pre">x.__add__(y)</span></code> が呼び出されます。 <a class="reference internal" href="#object.__divmod__" title="object.__divmod__"><code class="xref py py-meth docutils literal"><span class="pre">__divmod__()</span></code></a> メソッドは、 <a class="reference internal" href="#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal"><span class="pre">__floordiv__()</span></code></a> と <a class="reference internal" href="#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal"><span class="pre">__mod__()</span></code></a> を使った場合と等価にならなければなりません; <a class="reference internal" href="#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal"><span class="pre">__truediv__()</span></code></a> (下記参照) と関連づける必要はありません。組み込みの三項演算子バージョンの関数 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a> をサポートする場合には、 <a class="reference internal" href="#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal"><span class="pre">__pow__()</span></code></a> は、オプションとなる第三の引数を受け取れなくてはなりません。</p>
<p>こらのメソッドが渡された引き数に対する操作を提供していない場合には、 <code class="docutils literal"><span class="pre">NotImplemented</span></code> を送出しなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__div__">
<code class="descclassname">object.</code><code class="descname">__div__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__div__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__truediv__">
<code class="descclassname">object.</code><code class="descname">__truediv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__truediv__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>除算演算 (<code class="docutils literal"><span class="pre">/</span></code>) は、これらのメソッドで実現されています。 <a class="reference internal" href="#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal"><span class="pre">__truediv__()</span></code></a> は、 <code class="docutils literal"><span class="pre">__future__.division</span></code> が有効であるときに使われます。それ以外の場合には <a class="reference internal" href="#object.__div__" title="object.__div__"><code class="xref py py-meth docutils literal"><span class="pre">__div__()</span></code></a> が使われますs。二つのメソッドのうち一方しか定義されていなければ、オブジェクトは他方の演算コンテキストをサポートしなくなります; このとき、 <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出されます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__radd__">
<code class="descclassname">object.</code><code class="descname">__radd__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__radd__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rsub__">
<code class="descclassname">object.</code><code class="descname">__rsub__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rsub__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rmul__">
<code class="descclassname">object.</code><code class="descname">__rmul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rdiv__">
<code class="descclassname">object.</code><code class="descname">__rdiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rdiv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rtruediv__">
<code class="descclassname">object.</code><code class="descname">__rtruediv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rtruediv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rfloordiv__">
<code class="descclassname">object.</code><code class="descname">__rfloordiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rfloordiv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rmod__">
<code class="descclassname">object.</code><code class="descname">__rmod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rdivmod__">
<code class="descclassname">object.</code><code class="descname">__rdivmod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rdivmod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rpow__">
<code class="descclassname">object.</code><code class="descname">__rpow__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rpow__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rlshift__">
<code class="descclassname">object.</code><code class="descname">__rlshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rlshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rrshift__">
<code class="descclassname">object.</code><code class="descname">__rrshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rrshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rand__">
<code class="descclassname">object.</code><code class="descname">__rand__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rand__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rxor__">
<code class="descclassname">object.</code><code class="descname">__rxor__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rxor__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ror__">
<code class="descclassname">object.</code><code class="descname">__ror__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ror__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-91">これらのメソッドは二項算術演算 (<code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a>, <code class="docutils literal"><span class="pre">**</span></code>, <code class="docutils literal"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal"><span class="pre">&amp;</span></code>, <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">|</span></code>) を実現しますが、メソッド呼び出しが行われる被演算子が逆転して (reflected, swapped: 入れ替えられて) います。これらの関数は、左側の被演算子が対応する演算をサポートしておらずかつ両者の演算子が異なる場合にのみ呼び出されます。 <a class="footnote-reference" href="#id6" id="id3">[2]</a> 例えば、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code> の式を評価する場合、 <em>y</em> が <a class="reference internal" href="#object.__rsub__" title="object.__rsub__"><code class="xref py py-meth docutils literal"><span class="pre">__rsub__()</span></code></a> メソッドを持つクラスのインスタンスであって、しかも <code class="docutils literal"><span class="pre">x.__sub__(y)</span></code> が <em>NotImplemented</em> を返す場合には、 <code class="docutils literal"><span class="pre">y.__rsub__(x)</span></code> が呼び出されます。</p>
<p id="index-92">ただし、三項演算子 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a> が <a class="reference internal" href="#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal"><span class="pre">__rpow__()</span></code></a> を呼ぶことはないので注意してください (型強制の規則が非常に難解になるからです)。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">右側の被演算子の型が左側の被演算子の型のサブクラスであり、このサブクラスであるメソッドに対する逆転メソッドが定義されている場合には、左側の被演算子の非逆転メソッドが呼ばれる前に、このメソッドが呼ばれます。この振る舞いにより、サブクラスが親の操作をオーバーライドすることが可能になります。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__iadd__">
<code class="descclassname">object.</code><code class="descname">__iadd__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iadd__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__isub__">
<code class="descclassname">object.</code><code class="descname">__isub__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__isub__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__imul__">
<code class="descclassname">object.</code><code class="descname">__imul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__idiv__">
<code class="descclassname">object.</code><code class="descname">__idiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__idiv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__itruediv__">
<code class="descclassname">object.</code><code class="descname">__itruediv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__itruediv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ifloordiv__">
<code class="descclassname">object.</code><code class="descname">__ifloordiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ifloordiv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__imod__">
<code class="descclassname">object.</code><code class="descname">__imod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ipow__">
<code class="descclassname">object.</code><code class="descname">__ipow__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="optional">[</span>, <em>modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__ipow__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ilshift__">
<code class="descclassname">object.</code><code class="descname">__ilshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ilshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__irshift__">
<code class="descclassname">object.</code><code class="descname">__irshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__irshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__iand__">
<code class="descclassname">object.</code><code class="descname">__iand__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iand__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ixor__">
<code class="descclassname">object.</code><code class="descname">__ixor__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ixor__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ior__">
<code class="descclassname">object.</code><code class="descname">__ior__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ior__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これらのメソッドは、累算算術代入 (augmented arithmetic assignments, <code class="docutils literal"><span class="pre">+=</span></code>, <code class="docutils literal"><span class="pre">-=</span></code>, <code class="docutils literal"><span class="pre">*=</span></code>, <code class="docutils literal"><span class="pre">/=</span></code>, <code class="docutils literal"><span class="pre">//=</span></code>, <code class="docutils literal"><span class="pre">%=</span></code>, <code class="docutils literal"><span class="pre">**=</span></code>, <code class="docutils literal"><span class="pre">&lt;&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal"><span class="pre">&amp;=</span></code>, <code class="docutils literal"><span class="pre">^=</span></code>, <code class="docutils literal"><span class="pre">|=</span></code>) を実現するために呼び出されます。これらのメソッドは、演算をその場で(<em>self</em> を変更する形で) 行うよう試み、その結果(変更された <em>self</em> またはその代わりのもの)を返さなければなりません。特定のメソッドが定義されていない場合、その累算算術演算は通常のメソッドで代用されます。例えば、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></code> を評価する際、 <em>x</em> が <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal"><span class="pre">__iadd__()</span></code></a> メソッドを持つクラスのインスタンスであれば、 <code class="docutils literal"><span class="pre">x.__iadd__(y)</span></code> が呼び出されます。逆に、 <em>x</em> が <code class="xref py py-meth docutils literal"><span class="pre">__iadd()</span></code> メソッドを持たないクラスのインスタンスであれば、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> の評価と同じように <code class="docutils literal"><span class="pre">x.__add__(y)</span></code> および <code class="docutils literal"><span class="pre">y.__radd__(x)</span></code> を考慮します。</p>
</dd></dl>

<dl class="method">
<dt id="object.__neg__">
<code class="descclassname">object.</code><code class="descname">__neg__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__neg__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__pos__">
<code class="descclassname">object.</code><code class="descname">__pos__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__pos__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__abs__">
<code class="descclassname">object.</code><code class="descname">__abs__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__abs__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__invert__">
<code class="descclassname">object.</code><code class="descname">__invert__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__invert__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-93">単項算術演算 (<code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">+</span></code>, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a> および <code class="docutils literal"><span class="pre">~</span></code>) を実現するために呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__complex__">
<code class="descclassname">object.</code><code class="descname">__complex__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__complex__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__int__">
<code class="descclassname">object.</code><code class="descname">__int__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__int__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__long__">
<code class="descclassname">object.</code><code class="descname">__long__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__long__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__float__">
<code class="descclassname">object.</code><code class="descname">__float__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__float__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-94">組み込み関数 <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#long" title="long"><code class="xref py py-func docutils literal"><span class="pre">long()</span></code></a>, および <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a> を実現するために呼び出されます。適切な型の値を返さなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__oct__">
<code class="descclassname">object.</code><code class="descname">__oct__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__oct__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__hex__">
<code class="descclassname">object.</code><code class="descname">__hex__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__hex__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-95">組み込み関数 <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal"><span class="pre">oct()</span></code></a> および <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal"><span class="pre">hex()</span></code></a> を実現するために呼び出されます。文字列型を返さなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__index__">
<code class="descclassname">object.</code><code class="descname">__index__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__index__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../library/operator.html#operator.index" title="operator.index"><code class="xref py py-func docutils literal"><span class="pre">operator.index()</span></code></a> を実装するために呼び出されます。また、（スライシング）のように Python が整数オブジェクトを必要とする場合には何処でも呼び出されます。整数（int もしくは long）を返す必要があります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__coerce__">
<code class="descclassname">object.</code><code class="descname">__coerce__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__coerce__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>&quot;型混合モード (mixed-mode)&quot; での数値間の算術演算を実現するために呼び出されます。 <em>self</em> と <em>other</em> を共通の数値型に変換して、 2 要素のタプルにして返すか、不可能な場合には <code class="docutils literal"><span class="pre">None</span></code> を返さなければなりません。共通の型が <code class="docutils literal"><span class="pre">other</span></code> の型になる場合、 <code class="docutils literal"><span class="pre">None</span></code> を返すだけで十分です。この場合、インタプリタはもう一方のオブジェクトを調べて型強制を行おうとするからです (とはいえ、もう一方の値の型が実装上変更できない場合には、ここで <em>self</em> を <em>other</em> の型に変換しておいた方が便利です)。戻り値に <code class="docutils literal"><span class="pre">NotImplemented</span></code> を使うのは、 <code class="docutils literal"><span class="pre">None</span></code> を返すのと同じです。</p>
</dd></dl>

</div>
<div class="section" id="coercion-rules">
<span id="id4"></span><h3>3.4.9. 型強制規則 (coercion rule)<a class="headerlink" href="#coercion-rules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>本節では、型強制 (coercion) に関する規則について記述します。プログラム言語が進化するにつれ、型強制規則について正確に記述するのは難しくなってゆきます; 従って、あるバージョンのある実装について記述するのは望ましくありません。その代わりに、型強制に関する非公式的なガイドラインを示しておきます。 Python 3 からは、型強制がサポートされなくなる予定です。</p>
<ul>
<li><p class="first">% 演算子の左被演算子が文字列か Unicode オブジェクトの場合、型強制は起きず、文字列としての書式化操作が呼び出されます。</p>
</li>
<li><p class="first">型強制演算の定義はもはや推奨されていません。型強制を定義していない混合型 (mixed-mode) 演算は、もとの引数をそのまま演算操作に渡すようになっています。</p>
</li>
<li><p class="first">新しい形式のクラス (<a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> から派生したもの) が、二項演算子に対して <a class="reference internal" href="#object.__coerce__" title="object.__coerce__"><code class="xref py py-meth docutils literal"><span class="pre">__coerce__()</span></code></a> メソッドを呼び出すことはありません。; <a class="reference internal" href="#object.__coerce__" title="object.__coerce__"><code class="xref py py-meth docutils literal"><span class="pre">__coerce__()</span></code></a> が呼び出されるのは、組み込み関数 <a class="reference internal" href="../library/functions.html#coerce" title="coerce"><code class="xref py py-func docutils literal"><span class="pre">coerce()</span></code></a> が呼び出されたときだけです。</p>
</li>
<li><p class="first">事実上、 <code class="docutils literal"><span class="pre">NotImplemented</span></code> を返す演算子は、全く実装されていないものとして扱われます。</p>
</li>
<li><p class="first">以下の説明では、 <code class="xref py py-meth docutils literal"><span class="pre">__op__()</span></code> および <code class="xref py py-meth docutils literal"><span class="pre">__rop__()</span></code> は、演算子に相当する一般的なメソッド名を表すために使われます; <code class="xref py py-meth docutils literal"><span class="pre">__iop__()</span></code> はインプレース演算子を表します。例えば、演算子 '<code class="docutils literal"><span class="pre">+</span></code>' の場合、 <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal"><span class="pre">__add__()</span></code></a> および <a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal"><span class="pre">__radd__()</span></code></a> がそれぞれ左右の被演算子用の二項演算子として使われ、 <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal"><span class="pre">__iadd__()</span></code></a> がインプレース演算用の演算子として使われる、といった具合です。</p>
</li>
<li><p class="first">オブジェクト <em>x</em> および <em>y</em> に対して、まず <code class="docutils literal"><span class="pre">x.__op__(y)</span></code> が試されます。この演算が実装されていないか、 <code class="docutils literal"><span class="pre">NotImplemented</span></code> を返す場合、次に <code class="docutils literal"><span class="pre">y.__rop__(x)</span></code> が試されます。この演算も実装されていないか、 <code class="docutils literal"><span class="pre">NotImplemented</span></code> を返すなら、 <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます。ただし、以下の例外があるので参照してください:</p>
</li>
<li><p class="first">前項に対する例外: 左被演算子が組み込み型や新スタイルクラスのインスタンスであり、かつ右被演算子が左被演算子と同じクラスか適切なサブクラスのインスタンスであり、さらに親クラスの <code class="xref py py-meth docutils literal"><span class="pre">__rop__()</span></code> メソッドをオーバライドしている場合、左被演算子の <code class="xref py py-meth docutils literal"><span class="pre">__op__()</span></code> メソッドを試す <em>前に</em> 右被演算子の <code class="xref py py-meth docutils literal"><span class="pre">__rop__()</span></code> が試されます。</p>
<p>これは、サブクラス側で二項演算子を完全にオーバライドできるようにするためです。そうしなければ、常に左被演算子の <code class="xref py py-meth docutils literal"><span class="pre">__op__()</span></code> メソッドが右被演算子を受理してしまいます: あるクラスのインスタンスが被演算子になるとされている場合、そのサブクラスのインスタンスもまた受理可能だからです。</p>
</li>
<li><p class="first">双方の被演算子が型強制を定義している場合、型強制は被演算子の型の <code class="xref py py-meth docutils literal"><span class="pre">__op__()</span></code> や <code class="xref py py-meth docutils literal"><span class="pre">__rop__()</span></code> メソッドが呼び出される前に呼び出され、それより早くなることはありません。型強制の結果、型強制を行うことになったいずれの被演算子とも異なる型が返された場合、返されたオブジェクトの新たな型を使って、この過程が部分的に再度行われます。</p>
</li>
<li><p class="first">('<code class="docutils literal"><span class="pre">+=</span></code>' のような) インプレース型の演算子を用いる際、左被演算子が <code class="xref py py-meth docutils literal"><span class="pre">__iop__()</span></code> を実装していれば、 <code class="xref py py-meth docutils literal"><span class="pre">__iop__()</span></code> が呼び出され、型強制は一切行われません。演算が <code class="xref py py-meth docutils literal"><span class="pre">__op__()</span></code> かつ/または <code class="xref py py-meth docutils literal"><span class="pre">__rop__()</span></code> に帰着した場合、通常の型強制規則が適用されます。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> において、 <em>x</em> が結合 (concatenation) 演算を実装しているシーケンスであれば、シーケンスの結合が実行されます。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code> において、一方の演算子が繰り返し (repeat) 演算を実装しているシーケンスであり、かつ他方が整数 (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> または <a class="reference internal" href="../library/functions.html#long" title="long"><code class="xref py py-class docutils literal"><span class="pre">long</span></code></a>) である場合、シーケンスの繰り返しが実行されます。</p>
</li>
<li><p class="first">(<a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> などのメソッドで実装されている) 拡張比較は、決して型強制を行いません。(<a class="reference internal" href="#object.__cmp__" title="object.__cmp__"><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code></a> で実装されている) 三値比較 (three-way comparison) は、他の二項演算子で行われているのと同じ条件で型強制を受けます。</p>
</li>
<li><p class="first">現在の実装では、組み込み数値型 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/functions.html#long" title="long"><code class="xref py py-class docutils literal"><span class="pre">long</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> および <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a> は型強制を行いません; これらの型は全て、関数 <a class="reference internal" href="../library/functions.html#coerce" title="coerce"><code class="xref py py-func docutils literal"><span class="pre">coerce()</span></code></a> から利用するための <a class="reference internal" href="#object.__coerce__" title="object.__coerce__"><code class="xref py py-meth docutils literal"><span class="pre">__coerce__()</span></code></a> メソッドを実装しています。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 2.7 で変更: </span>複素数型は、型混合の二項算術演算に <a class="reference internal" href="#object.__coerce__" title="object.__coerce__"><code class="xref py py-meth docutils literal"><span class="pre">__coerce__()</span></code></a> を暗示的に呼び出さなくなりました。</p>
</div>
</li>
</ul>
</div>
<div class="section" id="with-statement-context-managers">
<span id="context-managers"></span><h3>3.4.10. with文とコンテキストマネージャ<a class="headerlink" href="#with-statement-context-managers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加.</span></p>
</div>
<p>コンテキストマネージャ(<em class="dfn">context manager</em>) とは、 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の実行時にランタイムコンテキストを定義するオブジェクトです。コンテキストマネージャは、コードブロックを実行するために必要な入り口および出口の処理を扱います。コンテキストマネージャは通常、 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文（ <a class="reference internal" href="compound_stmts.html#with"><span class="std std-ref">with 文</span></a> の章を参照）により起動されますが、これらのメソッドを直接呼び出すことで起動することもできます。</p>
<p id="index-96">コンテキストマネージャの代表的な使い方としては、様々なグローバル情報の保存および更新、リソースのロックとアンロック、ファイルのオープンとクローズなどが挙げられます。</p>
<p>コンテキストマネージャについてのさらなる情報については、 <a class="reference internal" href="../library/stdtypes.html#typecontextmanager"><span class="std std-ref">コンテキストマネージャ型</span></a> を参照してください。</p>
<dl class="method">
<dt id="object.__enter__">
<code class="descclassname">object.</code><code class="descname">__enter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__enter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテキストマネージャのの入り口で実行される処理です。 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文は、文の <a class="reference internal" href="compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> 節で規定された値を返すこのメソッドを呼び出します。</p>
</dd></dl>

<dl class="method">
<dt id="object.__exit__">
<code class="descclassname">object.</code><code class="descname">__exit__</code><span class="sig-paren">(</span><em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__exit__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテキストマネージャの出口で実行される処理です。パラメータは、コンテキストが終了した原因となった例外について説明しています。コンテキストが例外を送出せず終了した場合は、全ての引き数に <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> が設定されます。</p>
<p>もし、例外が送出され、かつメソッドが例外を抑制したい場合（すなわち、例外が伝播されるのを防ぎたい場合）、このメソッドは True を返す必要があります。そうでなければ、このメソッドの終了後、例外は通常通り伝播することになります。</p>
<p><a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドは受け取った例外を再度送出すべきではありません。これは、呼び出し側の責任でおこなってください。</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-101"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - &quot;with&quot; ステートメント</dt>
<dd>Python の <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の仕様、背景、および例が記載されています。</dd>
</dl>
</div>
</div>
<div class="section" id="special-method-lookup-for-old-style-classes">
<span id="old-style-special-lookup"></span><h3>3.4.11. 旧スタイルクラスの特殊メソッド検索<a class="headerlink" href="#special-method-lookup-for-old-style-classes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>旧スタイルクラスにおいて、特殊メソッドは常に他のメソッドや属性と同じ方法で検索されます。これは、メソッドが <code class="docutils literal"><span class="pre">x.__getitem__(i)</span></code> のように明示的に検索された時も、 <code class="docutils literal"><span class="pre">x[i]</span></code> のように暗黙的に検索された時も同じです。</p>
<p>これにより、1つの旧スタイルクラスの異なるインスタンスが、それぞれ別の適切な特殊属性を持っている場合、異なる動作をすることになります。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
</div>
<div class="section" id="special-method-lookup-for-new-style-classes">
<span id="new-style-special-lookup"></span><h3>3.4.12. 新スタイルクラスの特殊メソッド検索<a class="headerlink" href="#special-method-lookup-for-new-style-classes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>新スタイルクラスでは、特殊メソッドの暗黙的な呼び出しは、オブジェクトインスタンスの辞書ではなく、 type の辞書で定義されているときにのみ正しく動作することが保証されます。この動作は、以下のコードが(旧スタイルクラスの同等な例と異なり)例外を発生させる理由です。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object of type &#39;C&#39; has no len()</span>
</pre></div>
</div>
<p>この動作の背景となる理由は、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> と <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></code></a> といった type オブジェクトを含むすべてのオブジェクトで定義されている特殊メソッドにあります。これらのメソッドの暗黙の検索が通常の検索プロセスを使った場合、 type オブジェクト自体に対して実行されたときに失敗してしまいます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span>
</pre></div>
</div>
<p>クラスの非結合メソッドをこのようにして実行しようとすることは、'metaclass confusion' と呼ばれることもあり、特殊メソッドを検索するときはインスタンスをバイパスすることで回避されます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>正確性のためにインスタンス属性をスキップするのに加えて、特殊メソッド検索はオブジェクトのメタクラスを含めて、 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></code></a> メソッドもバイパスします:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>      <span class="nb">print</span> <span class="s2">&quot;Metaclass getattribute invoked&quot;</span>
<span class="gp">... </span>      <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">Meta</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span> <span class="s2">&quot;Class getattribute invoked&quot;</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>                 <span class="c1"># Explicit lookup via instance</span>
<span class="go">Class getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># Explicit lookup via type</span>
<span class="go">Metaclass getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                      <span class="c1"># Implicit lookup</span>
<span class="go">10</span>
</pre></div>
</div>
<p>このように <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></code></a> 機構をバイパスすることで、特殊メソッドの扱いに関するある程度の自由度と引き換えに (特殊メソッドはインタプリタから一貫して実行されるためにクラスオブジェクトに設定 <em>しなければならない</em>)、インタープリタを高速化するための大きな余地が手に入ります。</p>
<p class="rubric">注記</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>特定の条件が満たされた場合、オブジェクトの type を変更することが <em>できます</em> 。これは、正しく扱われなかった場合にとても奇妙な動作を引き起こすので、一般的には良い考えではありません。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>同じ型の操作に対しては、(<a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal"><span class="pre">__add__()</span></code></a> のような)逆転できないメソッドが失敗した時と同じような想定のもと処理されます。これは、逆転したメソッドを呼び出すことができないからです。</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. データモデル</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. オブジェクト、値、および型</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. 標準型の階層</a></li>
<li><a class="reference internal" href="#new-style-and-classic-classes">3.3. 新スタイルと旧スタイル</a></li>
<li><a class="reference internal" href="#special-method-names">3.4. 特殊メソッド名</a><ul>
<li><a class="reference internal" href="#basic-customization">3.4.1. 基本的なカスタマイズ</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.4.2. 属性値アクセスをカスタマイズする</a><ul>
<li><a class="reference internal" href="#more-attribute-access-for-new-style-classes">3.4.2.1. 新しい形式のクラスのための別の属性アクセス</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.4.2.2. デスクリプタ (descriptor) の実装</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.4.2.3. デスクリプタの呼び出し</a></li>
<li><a class="reference internal" href="#slots">3.4.2.4. __slots__</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.4.3. クラス生成をカスタマイズする</a></li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.4.4. インスタンスのカスタマイズとサブクラスチェック</a></li>
<li><a class="reference internal" href="#emulating-callable-objects">3.4.5. 呼び出し可能オブジェクトをエミュレートする</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.4.6. コンテナをエミュレートする</a></li>
<li><a class="reference internal" href="#additional-methods-for-emulation-of-sequence-types">3.4.7. シーケンス型エミュレーションで使われるその他のメソッド</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.4.8. 数値型をエミュレーションする</a></li>
<li><a class="reference internal" href="#coercion-rules">3.4.9. 型強制規則 (coercion rule)</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.4.10. with文とコンテキストマネージャ</a></li>
<li><a class="reference internal" href="#special-method-lookup-for-old-style-classes">3.4.11. 旧スタイルクラスの特殊メソッド検索</a></li>
<li><a class="reference internal" href="#special-method-lookup-for-new-style-classes">3.4.12. 新スタイルクラスの特殊メソッド検索</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="lexical_analysis.html"
                        title="前の章へ">2. 字句解析</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="次の章へ">4. 実行モデル</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">バグ報告</a></li>
  <li><a href="https://github.com/python/cpython/blob/2.7/Doc/reference/datamodel.rst"
         rel="nofollow">ソースの表示</a>
  </li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 実行モデル"
             >次へ</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 字句解析"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.14</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 言語リファレンス</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2018, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト).
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 2018-06-16
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>