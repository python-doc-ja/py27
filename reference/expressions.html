<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5. 式 (expression) &#8212; Python 2.7.13 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.13',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7.13 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 2.7.13 ドキュメント" href="../contents.html" />
    <link rel="up" title="Python 言語リファレンス" href="index.html" />
    <link rel="next" title="6. 単純文 (simple statement)" href="simple_stmts.html" />
    <link rel="prev" title="4. 実行モデル" href="executionmodel.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/reference/expressions.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="6. 単純文 (simple statement)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 実行モデル"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.13</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 言語リファレンス</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="expressions">
<span id="id1"></span><h1>5. 式 (expression)<a class="headerlink" href="#expressions" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p id="index-0">この章では、Python の式における個々の要素の意味について解説します。</p>
<p id="index-1"><strong>表記法に関する注意:</strong> この章と以降の章での拡張BNF (extended BNF) 表記は、字句解析規則ではなく、構文規則を記述するために用いられています。ある構文規則 (のある表現方法) が、以下の形式</p>
<pre>
<strong id="grammar-token-name">name</strong> ::=  <code class="xref docutils literal"><span class="pre">othername</span></code>
</pre>
<p id="index-2">で記述されていて、この構文特有の意味付け (semantics) が記述されていない場合、 <code class="docutils literal"><span class="pre">name</span></code> の形式をとる構文の意味付けは <code class="docutils literal"><span class="pre">othername</span></code> の意味付けと同じになります。</p>
<div class="section" id="arithmetic-conversions">
<span id="conversions"></span><h2>5.1. 算術変換 (arithmetic conversion)<a class="headerlink" href="#arithmetic-conversions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-3">以下の算術演算子の記述で、「数値引数は共通の型に変換されます」と書かれている場合、引数は <a class="reference internal" href="datamodel.html#coercion-rules"><span class="std std-ref">型強制規則 (coercion rule)</span></a> に記載されている型強制規則に基づいて型強制されます。引数がいずれも標準の数値型である場合、以下の型強制が適用されます:</p>
<ul class="simple">
<li><p class="first">片方の引数が複素数型であれば、他方は複素数型に変換されます;</p>
</li>
<li><p class="first">それ以外の場合で、片方の引数が浮動小数点数であれば、他方は浮動小数点型に変換されます;</p>
</li>
<li><p class="first">それ以外の場合で、片方の引数が長整数型であれば、他方は長整数型に変換されます;</p>
</li>
<li><p class="first">それ以外の場合で、両方の引数が通常の整数型であれば、変換の必要はありません。</p>
</li>
</ul>
<p>特定の演算子 (文字列を左引数とする &#8216;%&#8217; 演算子など) では、さらに別の規則が適用されます。拡張をおこなうことで、個々の演算子に対する型強制を定義できます。</p>
</div>
<div class="section" id="atoms">
<span id="id2"></span><h2>5.2. アトム、原子的要素 (atom)<a class="headerlink" href="#atoms" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-4">アトム (原子的要素: atom) は、式を構成する基本単位です。もっとも単純なアトムは、識別子またはリテラルになります。逆クオートや丸括弧、波括弧、または角括弧で囲われた形式 (form) もまた、文法的にはアトムに分類されます。アトムの構文定義は以下のようになります:</p>
<pre>
<strong id="grammar-token-atom">atom     </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="#grammar-token-literal"><code class="xref docutils literal"><span class="pre">literal</span></code></a> | <a class="reference internal" href="#grammar-token-enclosure"><code class="xref docutils literal"><span class="pre">enclosure</span></code></a>
<strong id="grammar-token-enclosure">enclosure</strong> ::=  <a class="reference internal" href="#grammar-token-parenth_form"><code class="xref docutils literal"><span class="pre">parenth_form</span></code></a> | <a class="reference internal" href="#grammar-token-list_display"><code class="xref docutils literal"><span class="pre">list_display</span></code></a>
               | <a class="reference internal" href="#grammar-token-generator_expression"><code class="xref docutils literal"><span class="pre">generator_expression</span></code></a> | <a class="reference internal" href="#grammar-token-dict_display"><code class="xref docutils literal"><span class="pre">dict_display</span></code></a> | <a class="reference internal" href="#grammar-token-set_display"><code class="xref docutils literal"><span class="pre">set_display</span></code></a>
               | <a class="reference internal" href="#grammar-token-string_conversion"><code class="xref docutils literal"><span class="pre">string_conversion</span></code></a> | <a class="reference internal" href="#grammar-token-yield_atom"><code class="xref docutils literal"><span class="pre">yield_atom</span></code></a>
</pre>
<div class="section" id="atom-identifiers">
<span id="identifiers-names"></span><h3>5.2.1. 識別子 (identifier、または名前 (name))<a class="headerlink" href="#atom-identifiers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-5">アトムの形になっている識別子 (identifier) は名前 (name) です。字句定義については <a class="reference internal" href="lexical_analysis.html#identifiers"><span class="std std-ref">識別子 (identifier) およびキーワード (keyword)</span></a> 節を、名前付けや束縛については <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">名前づけと束縛 (naming and binding)</span></a> 節を参照してください。</p>
<p id="index-6">名前があるオブジェクトに束縛されている場合、名前 atom を評価するとそのオブジェクトになります。名前が束縛されていない場合、 atom を評価しようとすると <a class="reference internal" href="../library/exceptions.html#exceptions.NameError" title="exceptions.NameError"><code class="xref py py-exc docutils literal"><span class="pre">NameError</span></code></a> 例外を送出します。</p>
<p id="index-7"><strong>プライベートな名前の名前修飾:</strong> クラス定義内に書かれた識別子で、2つ以上のアンダースコアから始まり、末尾が2つ以上のアンダースコアで終わっていないものは、そのクラスの <em class="dfn">プライベートな名前</em> とみなされます。プライベートな名前は、コードが生成される前により長い形式に変換されます。この変換によって、クラス名の先頭にアンダースコアがあれば除去し、先頭にアンダースコアを1つ付加し、名前の前に挿入されます。例えば、クラス名 <code class="docutils literal"><span class="pre">Ham</span></code> の中の識別子 <code class="docutils literal"><span class="pre">__spam</span></code> は、<code class="docutils literal"><span class="pre">_Ham__spam</span></code> に変換されます。変換は識別子が使用されている構文のコンテキストからは独立しています。変換された名前が非常に長い (255文字を超える) 場合、実装によっては名前の切り詰めが行われるかもしれません。クラス名がアンダースコアのみから成る場合は変換は行われません。</p>
</div>
<div class="section" id="literals">
<span id="atom-literals"></span><h3>5.2.2. リテラル<a class="headerlink" href="#literals" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-8">Python では、文字列リテラルと、様々な数値リテラルをサポートしています:</p>
<pre>
<strong id="grammar-token-literal">literal</strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-stringliteral"><code class="xref docutils literal"><span class="pre">stringliteral</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-integer"><code class="xref docutils literal"><span class="pre">integer</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-longinteger"><code class="xref docutils literal"><span class="pre">longinteger</span></code></a>
             | <a class="reference internal" href="lexical_analysis.html#grammar-token-floatnumber"><code class="xref docutils literal"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-imagnumber"><code class="xref docutils literal"><span class="pre">imagnumber</span></code></a>
</pre>
<p>リテラルを評価すると、指定した型 (文字列、整数、長整数、浮動小数点数、複素数) の指定した値を持つオブジェクトになります。浮動小数点や虚数 (複素数) リテラルの場合、値は近似値になる場合があります。詳しくは <a class="reference internal" href="lexical_analysis.html#literals"><span class="std std-ref">リテラル</span></a> を参照してください。</p>
<p id="index-9">リテラルは全て変更不能なデータ型に対応します。このため、オブジェクトのアイデンティティはオブジェクトの値ほど重要ではありません。同じ値を持つ複数のリテラルを評価した場合、(それらのリテラルがプログラムの同じ場所由来のものであっても、そうでなくても) 同じオブジェクトを指しているか、まったく同じ値を持つ別のオブジェクトになります。</p>
</div>
<div class="section" id="parenthesized-forms">
<span id="parenthesized"></span><h3>5.2.3. 丸括弧形式 (parenthesized form)<a class="headerlink" href="#parenthesized-forms" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-10">丸括弧形式とは、式リストの一形態で、丸括弧で囲ったものです:</p>
<pre>
<strong id="grammar-token-parenth_form">parenth_form</strong> ::=  &quot;(&quot; [<a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a>] &quot;)&quot;
</pre>
<p>丸括弧で囲われた式のリストは、個々の式が表現するものになります: リスト内に少なくとも一つのカンマが入っていた場合、タプルになります; そうでない場合、式のリストを構成している単一の式自体の値になります。</p>
<p id="index-11">中身が空の丸括弧のペアは、空のタプルオブジェクトを表します。タプルは変更不能なので、リテラルと同じ規則が適用されます (すなわち、空のタプルが二箇所で使われると、それらは同じオブジェクトになることもあるし、ならないこともあります)。</p>
<p id="index-12">タプルは丸括弧で作成されるのではなく、カンマによって作成されることに注意してください。例外は空のタプルで、この場合には丸括弧が <em>必要です</em> &#8212; 丸括弧のつかない &#8220;何も記述しない式 (nothing)&#8221; を使えるようにしてしまうと、文法があいまいなものになってしまい、よくあるタイプミスが検出されなくなってしまいます。</p>
</div>
<div class="section" id="list-displays">
<span id="lists"></span><h3>5.2.4. リスト表現<a class="headerlink" href="#list-displays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-13">リスト表現は、角括弧で囲われた式の系列です。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-list_display">list_display       </strong> ::=  &quot;[&quot; [<a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a> | <a class="reference internal" href="#grammar-token-list_comprehension"><code class="xref docutils literal"><span class="pre">list_comprehension</span></code></a>] &quot;]&quot;
<strong id="grammar-token-list_comprehension">list_comprehension </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-list_for"><code class="xref docutils literal"><span class="pre">list_for</span></code></a>
<strong id="grammar-token-list_for">list_for           </strong> ::=  &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-target_list"><code class="xref docutils literal"><span class="pre">target_list</span></code></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-old_expression_list"><code class="xref docutils literal"><span class="pre">old_expression_list</span></code></a> [<a class="reference internal" href="#grammar-token-list_iter"><code class="xref docutils literal"><span class="pre">list_iter</span></code></a>]
<strong id="grammar-token-old_expression_list">old_expression_list</strong> ::=  <a class="reference internal" href="#grammar-token-old_expression"><code class="xref docutils literal"><span class="pre">old_expression</span></code></a> [(&quot;,&quot; <a class="reference internal" href="#grammar-token-old_expression"><code class="xref docutils literal"><span class="pre">old_expression</span></code></a>)+ [&quot;,&quot;]]
<strong id="grammar-token-old_expression">old_expression     </strong> ::=  <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> | <a class="reference internal" href="#grammar-token-old_lambda_expr"><code class="xref docutils literal"><span class="pre">old_lambda_expr</span></code></a>
<strong id="grammar-token-list_iter">list_iter          </strong> ::=  <a class="reference internal" href="#grammar-token-list_for"><code class="xref docutils literal"><span class="pre">list_for</span></code></a> | <a class="reference internal" href="#grammar-token-list_if"><code class="xref docutils literal"><span class="pre">list_if</span></code></a>
<strong id="grammar-token-list_if">list_if            </strong> ::=  &quot;if&quot; <a class="reference internal" href="#grammar-token-old_expression"><code class="xref docutils literal"><span class="pre">old_expression</span></code></a> [<a class="reference internal" href="#grammar-token-list_iter"><code class="xref docutils literal"><span class="pre">list_iter</span></code></a>]
</pre>
<p id="index-14">リスト表現は、新に作成されたリストオブジェクトを表します。新たなリストの内容は、式のリストを与えるか、リストの内包表記 (list comprehension) で指定します。カンマで区切られた式のリストを与えた場合、リストの各要素は左から右へと順に評価され、評価された順番にリスト内に配置されます。リストの内包表記を与える場合、内包表記はまず単一の式、続いて少なくとも一つの <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節、続いてゼロ個以上の <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節か <a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> 節になります。この場合、新たに作成されるリストの各要素は、各々の <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> や <a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> 節を左から右の順にネストしたブロックとみなして実行し、ネストの最内ブロックに到達する度に式を評価した値となります。 <a class="footnote-reference" href="#id19" id="id3">[1]</a></p>
</div>
<div class="section" id="displays-for-sets-and-dictionaries">
<span id="comprehensions"></span><h3>5.2.5. 集合と辞書の表現<a class="headerlink" href="#displays-for-sets-and-dictionaries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python は、集合や辞書を構成するために、&#8221;表現 (display)&#8221; と呼ばれる特殊な構文を、それぞれ二種類づつ提供していて、コンテナの内容は:</p>
<ul class="simple">
<li><p class="first">明示的に列挙される、または</p>
</li>
<li><p class="first"><em class="dfn">内包表記 (comprehension)</em> と呼ばれる、ループ処理とフィルター処理の命令の組み合わせを通じて計算されます。</p>
</li>
</ul>
<p>内包表記の共通の構文要素はこの通りです:</p>
<pre>
<strong id="grammar-token-comprehension">comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal"><span class="pre">comp_for</span></code></a>
<strong id="grammar-token-comp_for">comp_for     </strong> ::=  &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-target_list"><code class="xref docutils literal"><span class="pre">target_list</span></code></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="#grammar-token-comp_iter"><code class="xref docutils literal"><span class="pre">comp_iter</span></code></a>]
<strong id="grammar-token-comp_iter">comp_iter    </strong> ::=  <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal"><span class="pre">comp_for</span></code></a> | <a class="reference internal" href="#grammar-token-comp_if"><code class="xref docutils literal"><span class="pre">comp_if</span></code></a>
<strong id="grammar-token-comp_if">comp_if      </strong> ::=  &quot;if&quot; <code class="xref docutils literal"><span class="pre">expression_nocond</span></code> [<a class="reference internal" href="#grammar-token-comp_iter"><code class="xref docutils literal"><span class="pre">comp_iter</span></code></a>]
</pre>
<p>内包表記はまず単一の式、続いて <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節、さらに続いて 0 個以上の <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節や <a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> 節からなります。この場合、新たなコンテナの各要素は、各々の <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> や <a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> 節を、左から右にネストしたブロックとみなして実行し、ネストの最内のブロックに到達する度に式を評価することで作成されたものになります。</p>
<p>なお、これらの内包表記は別のスコープで実行されるので、対象のリスト内で代入された名前が外側のスコープに &#8220;漏れる&#8221; ことはありません。</p>
</div>
<div class="section" id="generator-expressions">
<span id="genexpr"></span><h3>5.2.6. ジェネレータ式<a class="headerlink" href="#generator-expressions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-15">ジェネレータ式 (generator expression) とは、丸括弧を使ったコンパクトなジェネレータ表記法です:</p>
<pre>
<strong id="grammar-token-generator_expression">generator_expression</strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal"><span class="pre">comp_for</span></code></a> &quot;)&quot;
</pre>
<p>ジェネレータ式は新たなジェネレータオブジェクトを与えます。この構文は内包表記とほぼ同じですが、角括弧や波括弧ではなく、丸括弧で囲まれます。</p>
<p>ジェネレータ式で使われる変数は、ジェネレータオブジェクトに <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a> メソッドが呼び出されたときに遅延評価されます (通常のジェネレータと同じ流儀です)。しかし、最も左に位置する <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節は直ちに評価されるため、そこで生じたエラーは、ジェネレータ式を扱うコードで起こりえる他のエラーの前に現れることがあります。その後に続く <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節は、その前の <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループに依存しているため、直ちには評価されません。例: <code class="docutils literal"><span class="pre">(x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">bar(x))</span></code></p>
<p>関数の唯一の引数として渡す場合には、丸括弧を省略できます。詳しくは <a class="reference internal" href="#calls"><span class="std std-ref">呼び出し (call)</span></a> 節を参照してください。</p>
</div>
<div class="section" id="dictionary-displays">
<span id="dict"></span><h3>5.2.7. 辞書表現<a class="headerlink" href="#dictionary-displays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-16">辞書表現は、波括弧で囲われた、キーと値のペアからなる系列です。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-dict_display">dict_display      </strong> ::=  &quot;{&quot; [<a class="reference internal" href="#grammar-token-key_datum_list"><code class="xref docutils literal"><span class="pre">key_datum_list</span></code></a> | <a class="reference internal" href="#grammar-token-dict_comprehension"><code class="xref docutils literal"><span class="pre">dict_comprehension</span></code></a>] &quot;}&quot;
<strong id="grammar-token-key_datum_list">key_datum_list    </strong> ::=  <a class="reference internal" href="#grammar-token-key_datum"><code class="xref docutils literal"><span class="pre">key_datum</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-key_datum"><code class="xref docutils literal"><span class="pre">key_datum</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-key_datum">key_datum         </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-dict_comprehension">dict_comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal"><span class="pre">comp_for</span></code></a>
</pre>
<p>辞書表現は、新たな辞書オブジェクトを表します。</p>
<p>カンマ区切りの一連のキー/データの対が与えられたときは、その要素は左から右へ評価され、辞書の項目を定義します。すなわち、それぞれのキーオブジェクトが、辞書内で対応するデータを保存するキーとして使われます。これにより、キー/データリストの中で同じキーを複数回指定することができ、そのキーに対する最終的な辞書の値は、最後に与えられたものになります。</p>
<p>辞書内包表記は、リストや集合の内包表記とは対照的に、通常の &#8220;for&#8221; や &#8220;if&#8221; 節の前に、コロンで分けられた 2 つの式が必要です。内包表記が起動すると、結果のキーと値の要素が、作られた順に新しい辞書に挿入されます。</p>
<p id="index-17">キーの値として使える型に関する制限は <a class="reference internal" href="datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> 節ですでに列挙しています。(一言でいうと、キーは変更可能なオブジェクトを全て排除した <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> でなければなりません。) 重複するキー間で衝突が起きても、衝突が検出されることはありません; あるキーに対して、最後に渡されたデータ (プログラムテキスト上では、辞書表記の最も右側値となるもの) が使われます。</p>
</div>
<div class="section" id="set-displays">
<span id="set"></span><h3>5.2.8. 集合表現<a class="headerlink" href="#set-displays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-18">集合表現は波括弧で表され、キーと値を分けるコロンがないことで辞書表現と区別されます:</p>
<pre>
<strong id="grammar-token-set_display">set_display</strong> ::=  &quot;{&quot; (<a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a> | <a class="reference internal" href="#grammar-token-comprehension"><code class="xref docutils literal"><span class="pre">comprehension</span></code></a>) &quot;}&quot;
</pre>
<p>集合表示は、一連の式または内包表記によって指定された内容の、ミュータブルな集合オブジェクトを与えます。カンマ区切りの一連の式が与えられたときは、その要素は左から右へ順に評価され、集合オブジェクトに加えられます。内包表記が与えられたときは、内包表記の結果となる要素で集合が構成されます。</p>
<p>空集合は <code class="docutils literal"><span class="pre">{}</span></code> で構成できません。このリテラルは空の辞書を構成します。</p>
</div>
<div class="section" id="string-conversions">
<span id="id4"></span><h3>5.2.9. 文字列変換<a class="headerlink" href="#string-conversions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-19">文字列変換は、逆クオート (reverse quite, 別名バッククオート: backward quote) で囲われた式のリストです:</p>
<pre>
<strong id="grammar-token-string_conversion">string_conversion</strong> ::=  &quot;`&quot; <a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a> &quot;`&quot;
</pre>
<p>文字列変換は、逆クオート内の式リストを評価して、評価結果のオブジェクトを各オブジェクトの型特有の規則に従って文字列に変換します。</p>
<p>オブジェクトが文字列、数値、 <code class="docutils literal"><span class="pre">None</span></code> か、それらの型のオブジェクトのみを含むタプル、リストまたは辞書の場合、評価結果の文字列は有効な Python 式となり、組み込み関数 <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> に渡した場合に同じ値となります (浮動小数点が含まれている場合には近似値の場合もあります)。</p>
<p>(特に、文字列を変換すると、値を安全に出力するために文字列の両側にクオートが付けられ、&#8221;変 (funny) な&#8221; 文字はエスケープシーケンスに変換されます。)</p>
<p id="index-20">再帰的な構造をもつオブジェクト (例えば自分自身を直接または間接的に含むリストや辞書) では <code class="docutils literal"><span class="pre">...</span></code> を使って再帰的参照であることが示され、オブジェクトの評価結果は <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> に渡しても等価な値を得ることができません (<a class="reference internal" href="../library/exceptions.html#exceptions.SyntaxError" title="exceptions.SyntaxError"><code class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></code></a> が送出されます)。</p>
<p id="index-21">組み込み関数 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> は、括弧内の引数に対して、逆クオート表記で囲われた中身と全く同じ変換を実行します。組み込み関数 <a class="reference internal" href="../library/functions.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> は似たような動作をしますが、もっとユーザフレンドリな変換になります。</p>
</div>
<div class="section" id="yield-expressions">
<span id="yieldexpr"></span><h3>5.2.10. Yield 式<a class="headerlink" href="#yield-expressions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<pre id="index-22">
<strong id="grammar-token-yield_atom">yield_atom      </strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-yield_expression"><code class="xref docutils literal"><span class="pre">yield_expression</span></code></a> &quot;)&quot;
<strong id="grammar-token-yield_expression">yield_expression</strong> ::=  &quot;yield&quot; [<a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a>]
</pre>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加.</span></p>
</div>
<p><a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式はジェネレータ関数を定義するときにその関数の内部でのみ使用されます。関数内で <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式を使用すると、普通の関数ではなくジェネレータ関数が作成されます。</p>
<p>ジェネレータ関数が呼び出されるとき、ジェネレータとしてのイテレータを返します。そのジェネレータはジェネレータ関数の実行を制御します。ジェネレータのメソッドが呼び出されるときに実行が開始されます。メソッドを呼び出すと、実行は <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> の最初の位置まで処理されて一時停止します。そして、ジェネレータの呼び出し元へ <a class="reference internal" href="#grammar-token-expression_list"><code class="xref std std-token docutils literal"><span class="pre">expression_list</span></code></a> の値を返します。ここで言う一時停止とは、ローカル変数の束縛、命令ポインタや内部の評価スタックを含めたローカルの全ての状態が保持されることを指します。再度、ジェネレータのメソッドを呼び出して実行を再開するとき、そのジェネレータ関数はまさに <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式がただの外部呼び出しであったかのように処理が継続されます。再開した後の <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式の値は実行を再開するメソッドに依存します。</p>
<p id="index-23">これまで説明した内容から、ジェネレータ関数はコルーチンにとてもよく似ています。ジェネレータ関数は何度も生成し、1つ以上のエントリポイントを持ち、その実行は一時停止されます。ジェネレータ関数は yield した後で実行の継続を制御できないことが唯一の違いです。その制御は常にジェネレータの呼び出し元へ移されます。</p>
<div class="section" id="generator-iterator-methods">
<span id="index-24"></span><h4>5.2.10.1. ジェネレータ-イテレータメソッド<a class="headerlink" href="#generator-iterator-methods" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>この説ではジェネレータイテレータのメソッドについて説明します。これらはジェネレータ関数の実行制御に使用できます。</p>
<p>以下のジェネレータメソッドの呼び出しは、ジェネレータが既に実行中の場合 <a class="reference internal" href="../library/exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 例外を送出する点に注意してください。</p>
<span class="target" id="index-25"></span><dl class="method">
<dt id="generator.next">
<code class="descclassname">generator.</code><code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.next" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数の実行を開始するか、最後に <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式が実行されたところから再開します。ジェネレータ関数が <a class="reference internal" href="#generator.next" title="generator.next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a> メソッドによって再開された時、その時点の <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式の値は常に <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> と評価されます。その後次の <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式まで実行し、ジェネレータは一時停止し、 <a class="reference internal" href="#grammar-token-expression_list"><code class="xref std std-token docutils literal"><span class="pre">expression_list</span></code></a> の値を <a class="reference internal" href="#generator.next" title="generator.next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a> メソッドの呼び出し元に返します。ジェネレータが次の値を yield せずに終了した場合、 <a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 例外が送出されます。</p>
</dd></dl>

<dl class="method">
<dt id="generator.send">
<code class="descclassname">generator.</code><code class="descname">send</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#generator.send" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数の内部へ値を &#8220;送り&#8221;、実行を再開します。引数の <code class="docutils literal"><span class="pre">value</span></code> はカレントの <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式の結果になります。 <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> メソッドはジェネレータが生成した次の値、またはジェネレータが値を生成することなく終了すると <a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> が発生します。ジェネレータが再開するために <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> を呼び出すときは、引数として <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を指定しなければなりません。そうしないと、値を受け取る <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式が存在しないからです。</p>
</dd></dl>

<dl class="method">
<dt id="generator.throw">
<code class="descclassname">generator.</code><code class="descname">throw</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>value</em><span class="optional">[</span>, <em>traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.throw" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータが中断した位置で <code class="docutils literal"><span class="pre">type</span></code> 型の例外を発生させて、ジェネレータ関数が生成する次の値を返します。ジェネレータが値を生成することなく終了すると <a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> が発生します。ジェネレータ関数が渡された例外を捕捉しない、もしくは違う例外を発生させるなら、その例外は呼び出し元へ伝搬されます。</p>
</dd></dl>

<span class="target" id="index-26"></span><dl class="method">
<dt id="generator.close">
<code class="descclassname">generator.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数が中断した位置で <a class="reference internal" href="../library/exceptions.html#exceptions.GeneratorExit" title="exceptions.GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> を発生させます。ジェネレータ関数が (通常の終了または既にクローズされたことで) <a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 、もしくは (例外を捕捉しないことで) <a class="reference internal" href="../library/exceptions.html#exceptions.GeneratorExit" title="exceptions.GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> を発生させる場合 close() は呼び出し元へ返されます。ジェネレータが値を生成する場合 <a class="reference internal" href="../library/exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が発生します。 <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> はジェネレータが通常の終了または例外により既に終了している場合は何もしません。</p>
</dd></dl>

<p>以下の簡単なサンプルはジェネレータとジェネレータ関数の振る舞いを実際に紹介します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="s2">&quot;Execution starts when &#39;next()&#39; is called for the first time.&quot;</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="n">e</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span> <span class="s2">&quot;Don&#39;t forget to clean up when &#39;close()&#39; is called.&quot;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span> <span class="o">=</span> <span class="n">echo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">generator</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">Execution starts when &#39;next()&#39; is called for the first time.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">generator</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">generator</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="s2">&quot;spam&quot;</span><span class="p">)</span>
<span class="go">TypeError(&#39;spam&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">Don&#39;t forget to clean up when &#39;close()&#39; is called.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-83"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0342"><strong>PEP 0342</strong></a> - 拡張されたジェネレータを用いたコルーチン</dt>
<dd><p class="first last">シンプルなコルーチンとして利用できるように、ジェネレータの構文と API を拡張する提案です。</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section" id="primaries">
<span id="id5"></span><h2>5.3. プライマリ<a class="headerlink" href="#primaries" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-28">プライマリは、言語において最も結合の強い操作を表します。文法は以下のようになります:</p>
<pre>
<strong id="grammar-token-primary">primary</strong> ::=  <a class="reference internal" href="#grammar-token-atom"><code class="xref docutils literal"><span class="pre">atom</span></code></a> | <a class="reference internal" href="#grammar-token-attributeref"><code class="xref docutils literal"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="#grammar-token-subscription"><code class="xref docutils literal"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="#grammar-token-slicing"><code class="xref docutils literal"><span class="pre">slicing</span></code></a> | <a class="reference internal" href="#grammar-token-call"><code class="xref docutils literal"><span class="pre">call</span></code></a>
</pre>
<div class="section" id="attribute-references">
<span id="id6"></span><h3>5.3.1. 属性参照<a class="headerlink" href="#attribute-references" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-29">属性参照は、プライマリの後ろにピリオドと名前を連ねたものです:</p>
<pre>
<strong id="grammar-token-attributeref">attributeref</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> &quot;.&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a>
</pre>
<p id="index-30">プライマリの値評価結果は、例えばモジュール、リスト、インスタンスといった、属性参照をサポートする型でなければなりません。オブジェクトは次に、指定した名前が識別子名となっているような属性を生成するよう問い合わせされます。問い合わせた属性が得られない場合、例外 <a class="reference internal" href="../library/exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> が送出されます。それ以外の場合、オブジェクトは属性オブジェクトの型と値を決定し、生成して返します。同じ属性参照を複数回評価したとき、互いに異なる属性オブジェクトになることがあります。</p>
</div>
<div class="section" id="subscriptions">
<span id="id7"></span><h3>5.3.2. 添字表記 (subscription)<a class="headerlink" href="#subscriptions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-31"></span><p id="index-32">添字表記は、シーケンス (文字列、タプルまたはリスト) やマップ (辞書) オブジェクトから、要素を一つ選択します:</p>
<pre>
<strong id="grammar-token-subscription">subscription</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a> &quot;]&quot;
</pre>
<p>プライマリの値評価結果は、シーケンス型かマップ型のオブジェクトでなければなりません。</p>
<p>プライマリがマップであれば、式リストの値評価結果はマップ内のいずれかのキー値に相当するオブジェクトにならなければなりません。添字表記は、そのキーに対応するマップ内の値 (value) を選択します。 (式リストの要素が単独である場合を除き、式リストはタプルでなければなりません。)</p>
<p>プライマリがシーケンスの場合、式 (リスト) の値評価結果は (通常の) 整数でなければなりません。値が負の場合、シーケンスの長さが加算されます (<code class="docutils literal"><span class="pre">x[-1]</span></code> が <code class="docutils literal"><span class="pre">x</span></code> の最後の要素を指すことになります)。加算結果はシーケンス内の要素数よりも小さな非負の整数とならなければなりません。添字表記は、添字と同じシーケンス中の (ゼロから数えた) インデクスを持つ要素を選択します。</p>
<p id="index-33">文字列型の要素は文字 (character) です。文字は個別の型ではなく、 1 文字だけからなる文字列です。</p>
</div>
<div class="section" id="slicings">
<span id="id8"></span><h3>5.3.3. スライス表記 (slicing)<a class="headerlink" href="#slicings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-34"></span><p id="index-35">スライス表記はシーケンスオブジェクト (文字列、タプルまたはリスト) におけるある範囲の要素を選択します。スライス表記は式として用いたり、代入や <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal"><span class="pre">del</span></code></a> 文の対象として用いたりできます。スライス表記の構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-slicing">slicing         </strong> ::=  <a class="reference internal" href="#grammar-token-simple_slicing"><code class="xref docutils literal"><span class="pre">simple_slicing</span></code></a> | <a class="reference internal" href="#grammar-token-extended_slicing"><code class="xref docutils literal"><span class="pre">extended_slicing</span></code></a>
<strong id="grammar-token-simple_slicing">simple_slicing  </strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-short_slice"><code class="xref docutils literal"><span class="pre">short_slice</span></code></a> &quot;]&quot;
<strong id="grammar-token-extended_slicing">extended_slicing</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-slice_list"><code class="xref docutils literal"><span class="pre">slice_list</span></code></a> &quot;]&quot;
<strong id="grammar-token-slice_list">slice_list      </strong> ::=  <a class="reference internal" href="#grammar-token-slice_item"><code class="xref docutils literal"><span class="pre">slice_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-slice_item"><code class="xref docutils literal"><span class="pre">slice_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-slice_item">slice_item      </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-proper_slice"><code class="xref docutils literal"><span class="pre">proper_slice</span></code></a> | <a class="reference internal" href="#grammar-token-ellipsis"><code class="xref docutils literal"><span class="pre">ellipsis</span></code></a>
<strong id="grammar-token-proper_slice">proper_slice    </strong> ::=  <a class="reference internal" href="#grammar-token-short_slice"><code class="xref docutils literal"><span class="pre">short_slice</span></code></a> | <a class="reference internal" href="#grammar-token-long_slice"><code class="xref docutils literal"><span class="pre">long_slice</span></code></a>
<strong id="grammar-token-short_slice">short_slice     </strong> ::=  [<a class="reference internal" href="#grammar-token-lower_bound"><code class="xref docutils literal"><span class="pre">lower_bound</span></code></a>] &quot;:&quot; [<a class="reference internal" href="#grammar-token-upper_bound"><code class="xref docutils literal"><span class="pre">upper_bound</span></code></a>]
<strong id="grammar-token-long_slice">long_slice      </strong> ::=  <a class="reference internal" href="#grammar-token-short_slice"><code class="xref docutils literal"><span class="pre">short_slice</span></code></a> &quot;:&quot; [<a class="reference internal" href="#grammar-token-stride"><code class="xref docutils literal"><span class="pre">stride</span></code></a>]
<strong id="grammar-token-lower_bound">lower_bound     </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-upper_bound">upper_bound     </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-stride">stride          </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-ellipsis">ellipsis        </strong> ::=  &quot;...&quot;
</pre>
<p id="index-36">上記の形式的な構文法にはあいまいさがあります: 式リストに見えるものは、スライスリストにも見えるため、添字表記はスライス表記としても解釈されうるということです。この場合には、(スライスリストの評価結果が、適切なスライスや省略表記 (ellipsis) にならない場合)、スライス表記としての解釈よりも添字表記としての解釈の方が高い優先順位を持つように定義することで、構文法をより難解にすることなくあいまいさを取り除いています。同様に、スライスリストが厳密に一つだけの短いスライスで、末尾にカンマが続いていない場合、拡張スライスとしての解釈より、単純なスライスとしての解釈が優先されます。</p>
<p>単純なスライスに対する意味付けは以下のようになります。プライマリの値評価結果は、シーケンス型のオブジェクトでなければなりません。下境界および上境界を表す式がある場合、それらの値評価結果は整数でなくてはなりません; デフォルトの値は、それぞれゼロと <code class="docutils literal"><span class="pre">sys.maxint</span></code> です。どちらかの境界値が負である場合、シーケンスの長さが加算されます。こうして、スライスは <em>i</em> および <em>j</em> をそれぞれ指定した下境界、上境界として、インデクス <em>k</em> が <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">j</span></code> となる全ての要素を選択します。選択の結果、空のシーケンスになることもあります。 <em>i</em> や <em>j</em> が有効なインデクス範囲の外側にある場合でも、エラーにはなりません (範囲外の要素は存在しないので、選択されないだけです)。</p>
<p id="index-37">拡張スライスに対する意味付けは、以下のようになります。プライマリの値評価結果は、辞書型のオブジェクトでなければなりません。また、辞書は以下に述べるようにしてスライスリストから生成されたキーによってインデクス指定できなければなりません。スライスリストに少なくとも一つのカンマが含まれている場合、キーは各スライス要素を値変換したものからなるタプルになります; それ以外の場合、単一のスライス要素自体を値変換したものがキーになります。一個の式でできたスライス要素の変換は、その式になります。省略表記スライス要素の変換は、組み込みの <code class="docutils literal"><span class="pre">Ellipsis</span></code> オブジェクトになります。適切なスライスの変換は、スライスオブジェクト (<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> 参照) で <code class="xref py py-attr docutils literal"><span class="pre">start</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">stop</span></code> および <code class="xref py py-attr docutils literal"><span class="pre">step</span></code> 属性は、それぞれ指定した下境界、上境界、およびとび幅 (stride) になります。式がない場合には <code class="docutils literal"><span class="pre">None</span></code> に置き換えられます。</p>
</div>
<div class="section" id="calls">
<span id="index-38"></span><span id="id9"></span><h3>5.3.4. 呼び出し (call)<a class="headerlink" href="#calls" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>呼び出しは、呼び出し可能オブジェクト (例えば <a class="reference internal" href="../glossary.html#term-function"><span class="xref std std-term">function</span></a>) を <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">arguments</span></a> の系列とともに呼び出します。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-call">call                </strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-argument_list"><code class="xref docutils literal"><span class="pre">argument_list</span></code></a> [&quot;,&quot;]
                          | <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> <code class="xref docutils literal"><span class="pre">genexpr_for</span></code>] &quot;)&quot;
<strong id="grammar-token-argument_list">argument_list       </strong> ::=  <a class="reference internal" href="#grammar-token-positional_arguments"><code class="xref docutils literal"><span class="pre">positional_arguments</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_arguments"><code class="xref docutils literal"><span class="pre">keyword_arguments</span></code></a>]
                            [&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>] [&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_arguments"><code class="xref docutils literal"><span class="pre">keyword_arguments</span></code></a>]
                            [&quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-keyword_arguments"><code class="xref docutils literal"><span class="pre">keyword_arguments</span></code></a> [&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
                            [&quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
                          | &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_arguments"><code class="xref docutils literal"><span class="pre">keyword_arguments</span></code></a>] [&quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
                          | &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-positional_arguments">positional_arguments</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>)*
<strong id="grammar-token-keyword_arguments">keyword_arguments   </strong> ::=  <a class="reference internal" href="#grammar-token-keyword_item"><code class="xref docutils literal"><span class="pre">keyword_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_item"><code class="xref docutils literal"><span class="pre">keyword_item</span></code></a>)*
<strong id="grammar-token-keyword_item">keyword_item        </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
</pre>
<p>固定引数やキーワード引数の後ろにカンマをつけてもかまいません。構文の意味付けに影響を及ぼすことはありません。</p>
<p id="index-39">プライマリの値評価結果は、呼び出し可能オブジェクトでなければなりません (ユーザ定義関数、組み込み関数、組み込みオブジェクトのメソッド、クラスオブジェクト、クラスインスタンスのメソッド、そして特定のクラスインスタンス自体が呼び出し可能です; 拡張によって、その他の呼び出し可能オブジェクト型を定義することができます)。引数式は全て、呼び出しを試みる前に値評価されます。仮引数 (formal <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameter</span></a>) リストの構文については <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> を参照してください。</p>
<p>キーワード引数が存在する場合、以下のようにして最初に固定引数 (positional argument) に変換されます。まず、値の入っていないスロットが仮引数に対して生成されます。N 個の固定引数がある場合、固定引数は先頭の N スロットに配置されます。次に、各キーワード引数について、識別子を使って対応するスロットを決定します (識別子が最初の仮引数パラメタ名と同じなら、最初のスロットを使う、といった具合です)。スロットがすでにすべて埋まっていたなら <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます。それ以外の場合、引数値をスロットに埋めていきます。 (式が <code class="docutils literal"><span class="pre">None</span></code> であっても、その式でスロットを埋めます)。全ての引数が処理されたら、まだ埋められていないスロットをそれぞれに対応する関数定義時のデフォルト値で埋めます。(デフォルト値は、関数が定義されたときに一度だけ計算されます; 従って、リストや辞書のような変更可能なオブジェクトがデフォルト値として使われると、対応するスロットに引数を指定しない限り、このオブジェクトが全ての呼び出しから共有されます; このような状況は通常避けるべきです。) デフォルト値が指定されていない、値の埋められていないスロットが残っている場合 <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます。そうでない場合、値の埋められたスロットからなるリストが呼び出しの引数として使われます。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> 実装では、名前を持たない固定引数を受け取る組み込み関数を提供するかもしれません。そういった引数がドキュメント化のために &#8216;名付けられて&#8217; いたとしても、実際には名付けられていないのでキーワードによって提供されません。 CPython では、C 言語で実装された関数の、名前を持たない固定引数を解析するために <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a> を使用します。</p>
</div>
<p>仮引数スロットの数よりも多くの固定引数がある場合、構文 <code class="docutils literal"><span class="pre">*identifier</span></code> を使って指定された仮引数がないかぎり、 <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます; 仮引数 <code class="docutils literal"><span class="pre">*identifier</span></code> がある場合、この仮引数は余分な固定引数が入ったタプル (もしくは、余分な固定引数がない場合には空のタプル) を受け取ります。</p>
<p>キーワード引数のいずれかが仮引数名に対応しない場合、構文 <code class="docutils literal"><span class="pre">**identifier</span></code> を使って指定された仮引数がない限り、 <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます; 仮引数 <code class="docutils literal"><span class="pre">**identifier</span></code> がある場合、この仮引数は余分なキーワード引数が入った (キーワードをキーとし、引数値をキーに対応する値とした) 辞書を受け取ります。余分なキーワード引数がない場合には、空の (新たな) 辞書を受け取ります。</p>
<p id="index-40">関数呼び出しの際に構文 <code class="docutils literal"><span class="pre">*expression</span></code> が使われるなら、 <code class="docutils literal"><span class="pre">expression</span></code> の評価はシーケンスでなくてはなりません。このシーケンスの要素は、追加の固定引数のように扱われます; すなわち、固定引数 <em>x1</em> ,..., <em>xN</em> があり、 <code class="docutils literal"><span class="pre">expression</span></code> の評価がシーケンス <em>y1</em> ,..., <em>yM</em> であるなら、M+N 個の固定引数 <em>x1</em> ,..., <em>xN</em> , <em>y1</em> ,..., <em>yM</em> を使った呼び出しと同じになります。</p>
<p><code class="docutils literal"><span class="pre">*expression</span></code> 構文はキーワード引数の <em>後ろ</em> で指定しても良いですが、キーワード引数よりも <em>前</em> で指定されたものとして処理されます (<code class="docutils literal"><span class="pre">**expression</span></code> 引数を指定したときの振る舞いは以下を参照)。従って、このようになります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">2 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">TypeError</span>: <span class="n">f() got multiple values for keyword argument &#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">1 2</span>
</pre></div>
</div>
<p>キーワード引数と <code class="docutils literal"><span class="pre">*expression</span></code> 構文を同じ呼び出しで一緒に使うことはあまりないので、実際に上記のような混乱が生じることはありません。</p>
<p id="index-41">関数呼び出しで <code class="docutils literal"><span class="pre">**expression</span></code> 構文が使われた場合、 <code class="docutils literal"><span class="pre">expression</span></code> の値評価結果はマップ型でなければなりません。辞書の内容は追加のキーワード引数として扱われます。明示的なキーワード引数が <code class="docutils literal"><span class="pre">expression</span></code> 内のキーワードと重複した場合には <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます。</p>
<p><code class="docutils literal"><span class="pre">*identifier</span></code> や <code class="docutils literal"><span class="pre">**identifier</span></code> 構文を使った仮引数は、固定引数スロットやキーワード引数名にすることができません。 <code class="docutils literal"><span class="pre">(sublist)</span></code> 構文を使った仮引数は、キーワード引数名には使えません; sublist は、リスト全体が一つの無名の引数スロットに対応しており、sublist 中の引数は、他の全てのパラメタに対する処理が終わった後に、通常のタプル形式の代入規則を使ってスロットに入れられます。</p>
<p>呼び出しを行うと、例外を送出しない限り、常に何らかの値を返します。 <code class="docutils literal"><span class="pre">None</span></code> を返す場合もあります。戻り値がどのように算出されるかは、呼び出し可能オブジェクトの形態によって異なります。</p>
<p>これが&#8212;</p>
<dl class="docutils">
<dt>ユーザ定義関数:</dt>
<dd><p class="first last" id="index-42">関数のコードブロックに引数リストが渡され、実行されます。コードブロックは、まず仮引数を実引数に結合 (bind) します; この動作については <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> で記述しています。コードブロックで <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> 文が実行される際に、関数呼び出しの戻り値 (return value) が決定されます。</p>
</dd>
<dt>組み込み関数またはメソッド:</dt>
<dd><p class="first last" id="index-43">結果はインタプリタに依存します; 組み込み関数やメソッドの詳細は <a class="reference internal" href="../library/functions.html#built-in-funcs"><span class="std std-ref">組み込み関数</span></a> を参照してください。</p>
</dd>
<dt>クラスオブジェクト:</dt>
<dd><p class="first last" id="index-44">そのクラスの新しいインスタンスが返されます。</p>
</dd>
<dt>クラスインスタンスメソッド:</dt>
<dd><p class="first last" id="index-45">対応するユーザ定義の関数が呼び出されます。このとき、呼び出し時の引数リストより一つ長い引数リストで呼び出されます: インスタンスが引数リストの先頭に追加されます。</p>
</dd>
<dt>クラスインスタンス:</dt>
<dd><p class="first last" id="index-46">クラスで <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> メソッドが定義されていなければなりません; <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> メソッドが呼び出された場合と同じ効果をもたらします。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="the-power-operator">
<span id="power"></span><h2>5.4. べき乗演算 (power operator)<a class="headerlink" href="#the-power-operator" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>べき乗演算は、左側にある単項演算子よりも強い結合優先順位があります; 一方、右側にある単項演算子よりは低い結合優先順位になっています。構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-power">power</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> [&quot;**&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a>]
</pre>
<p>従って、べき乗演算子と単項演算子からなる演算列が丸括弧で囲われていない場合、演算子は右から左へと評価されます (この場合は演算子の評価順序を強制しません。つまり <code class="docutils literal"><span class="pre">-1**2</span></code> は <code class="docutils literal"><span class="pre">-1</span></code> になります)。</p>
<p>べき乗演算子は、二つの引数で呼び出される組み込み関数 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a> と同じ意味付けを持っています。引数はまず共通の型に変換されます。結果の型は、型強制後の引数の型になります。</p>
<p>引数型を混合すると、二項算術演算における型強制規則が適用されます。整数や長整数の被演算子の場合、第二引数が負でない限り、結果は (型強制後の) 被演算子と同じになります; 第二引数が負の場合、全ての引数は浮動小数点型に変換され、浮動小数点型が返されます。例えば <code class="docutils literal"><span class="pre">10**2</span></code> は <code class="docutils literal"><span class="pre">100</span></code> を返しますが、 <code class="docutils literal"><span class="pre">10**-2</span></code> は <code class="docutils literal"><span class="pre">0.01</span></code> を返します。 (上述の仕様のうち、最後のものは Python 2.2 で追加されました。 Python 2.1 以前では、双方の引数が整数型で、第二引数が負の場合、例外が送出されていました。)</p>
<p><code class="docutils literal"><span class="pre">0.0</span></code> を負の数でべき乗すると <a class="reference internal" href="../library/exceptions.html#exceptions.ZeroDivisionError" title="exceptions.ZeroDivisionError"><code class="xref py py-exc docutils literal"><span class="pre">ZeroDivisionError</span></code></a> を送出します。負の数を小数でべき乗すると <a class="reference internal" href="../library/exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> になります。</p>
</div>
<div class="section" id="unary-arithmetic-and-bitwise-operations">
<span id="unary"></span><h2>5.5. 単項算術演算とビット単位演算(unary arithmetic and bitwise operation)<a class="headerlink" href="#unary-arithmetic-and-bitwise-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-47">全ての単項算術演算とビット単位演算は、同じ優先順位を持っています:</p>
<pre>
<strong id="grammar-token-u_expr">u_expr</strong> ::=  <a class="reference internal" href="#grammar-token-power"><code class="xref docutils literal"><span class="pre">power</span></code></a> | &quot;-&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | &quot;+&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | &quot;~&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a>
</pre>
<p id="index-48">単項演算子 <code class="docutils literal"><span class="pre">-</span></code> (マイナス) は、引数となる数値の符号を反転 (negation) します。</p>
<p id="index-49">単項演算子 <code class="docutils literal"><span class="pre">+</span></code> (プラス) は、数値引数を変更しません。</p>
<p id="index-50">単項演算子 <code class="docutils literal"><span class="pre">~</span></code> (反転) は、整数または長整数の引数をビット単位反転 (bitwise invert) します。 <code class="docutils literal"><span class="pre">x</span></code> のビット単位反転は、 <code class="docutils literal"><span class="pre">-(x+1)</span></code> として定義されています。この演算子は整数にのみ適用されます。</p>
<p id="index-51">上記の三つはいずれも、引数が正しい型でない場合には <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます。</p>
</div>
<div class="section" id="binary-arithmetic-operations">
<span id="binary"></span><h2>5.6. 二項算術演算 (binary arithmetic operation)<a class="headerlink" href="#binary-arithmetic-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-52">二項算術演算は、慣習的な優先順位を踏襲しています。演算子のいずれかは、特定の非数値型にも適用されるので注意してください。べき乗 (power) 演算子を除き、演算子には二つのレベル、すなわち乗算的 (multiplicatie) 演算子と加算的 (additie) 演算子しかありません:</p>
<pre>
<strong id="grammar-token-m_expr">m_expr</strong> ::=  <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> &quot;*&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> &quot;//&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> &quot;/&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a>
            | <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> &quot;%&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a>
<strong id="grammar-token-a_expr">a_expr</strong> ::=  <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal"><span class="pre">a_expr</span></code></a> &quot;+&quot; <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal"><span class="pre">a_expr</span></code></a> &quot;-&quot; <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a>
</pre>
<p id="index-53"><code class="docutils literal"><span class="pre">*</span></code> (乗算: multiplication) 演算は、引数間の積になります。引数の組は、双方ともに数値型であるか、片方が整数 (通常の整数または長整数) 型で他方がシーケンス型かのどちらかでなければなりません。前者の場合、数値は共通の型に変換された後乗算されます。後者の場合、シーケンスの繰り返し操作が行われます。繰り返し数を負にすると、空のシーケンスになります。</p>
<p id="index-54"><code class="docutils literal"><span class="pre">/</span></code> (除算: division) および <code class="docutils literal"><span class="pre">//</span></code> (切り捨て除算: floor division) は、引数間の商になります。数値引数はまず共通の型に変換されます。整数または長整数の除算結果は、同じ型の整数になります; この場合、結果は数学的な除算に関数 &#8216;floor&#8217; を適用したものになります。ゼロによる除算を行うと <a class="reference internal" href="../library/exceptions.html#exceptions.ZeroDivisionError" title="exceptions.ZeroDivisionError"><code class="xref py py-exc docutils literal"><span class="pre">ZeroDivisionError</span></code></a> 例外を送出します。</p>
<p id="index-55"><code class="docutils literal"><span class="pre">%</span></code> (モジュロ: modulo) 演算は、第一引数を第二引数で除算したときの剰余になります。数値引数はまず共通の型に変換されます。右引数値がゼロの場合には <a class="reference internal" href="../library/exceptions.html#exceptions.ZeroDivisionError" title="exceptions.ZeroDivisionError"><code class="xref py py-exc docutils literal"><span class="pre">ZeroDivisionError</span></code></a> 例外が送出されます。引数値は浮動小数点でもよく。例えば <code class="docutils literal"><span class="pre">3.14%0.7</span></code> は <code class="docutils literal"><span class="pre">0.34</span></code> になります (<code class="docutils literal"><span class="pre">3.14</span></code> は <code class="docutils literal"><span class="pre">4*0.7</span> <span class="pre">+</span> <span class="pre">0.34</span></code> だからです)。モジュロ演算子は常に第二引数と同じ符号 (またはゼロ) の結果になります; モジュロ演算の結果の絶対値は、常に第二引数の絶対値よりも小さくなります。 <a class="footnote-reference" href="#id20" id="id10">[2]</a></p>
<p>整数による除算演算やモジュロ演算は、恒等式: <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x/y)*y</span> <span class="pre">+</span> <span class="pre">(x%y)</span></code> と関係しています。整数除算やモジュロはまた、組み込み関数 <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a>: <code class="docutils literal"><span class="pre">divmod(x,</span> <span class="pre">y)</span> <span class="pre">==</span> <span class="pre">(x/y,</span> <span class="pre">x%y)</span></code> と関係しています。これらの恒等関係は浮動小数点の場合には維持されません; <code class="docutils literal"><span class="pre">x/y</span></code> が <code class="docutils literal"><span class="pre">floor(x/y)</span></code> や <code class="docutils literal"><span class="pre">floor(x/y)</span> <span class="pre">-</span> <span class="pre">1</span></code> に置き換えられた場合、これらの恒等式は近似性を維持します。 <a class="footnote-reference" href="#id21" id="id11">[3]</a></p>
<p>数値に対するモジュロ演算の実行に加えて <code class="docutils literal"><span class="pre">%</span></code> 演算子は文字列 (string) とユニコードオブジェクトにオーバーロードされ、文字列の書式化 (文字列の挿入としても知られる) を行います。文字列の書式化の構文は Python ライブラリリファレンス <a class="reference internal" href="../library/stdtypes.html#string-formatting"><span class="std std-ref">文字列フォーマット操作</span></a> 節を参照してください。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 2.3 で撤廃: </span>切り捨て除算演算子、モジュロ演算子、および <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a> 関数は、複素数に対してはもはや定義されていません。目的に合うならば、代わりに <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a> を使って浮動小数点に変換してください。</p>
</div>
<p id="index-56"><code class="docutils literal"><span class="pre">+</span></code> (加算) 演算は、引数を加算した値を返します。引数は双方とも数値型か、双方とも同じ型のシーケンスでなければなりません。前者の場合、数値は共通の型に変換され、加算されます。後者の場合、シーケンスは結合 (concatenate) されます。</p>
<p id="index-57"><code class="docutils literal"><span class="pre">-</span></code> (減算) 演算は、引数間で減算を行った値を返します。数値引数はまず共通の型に変換されます。</p>
</div>
<div class="section" id="shifting-operations">
<span id="shifting"></span><h2>5.7. シフト演算 (shifting operation)<a class="headerlink" href="#shifting-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-58">シフト演算は、算術演算よりも低い優先順位を持っています:</p>
<pre>
<strong id="grammar-token-shift_expr">shift_expr</strong> ::=  <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal"><span class="pre">a_expr</span></code></a> | <a class="reference internal" href="#grammar-token-shift_expr"><code class="xref docutils literal"><span class="pre">shift_expr</span></code></a> ( &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; ) <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal"><span class="pre">a_expr</span></code></a>
</pre>
<p>シフトの演算子は整数または長整数を引数にとります。引数は共通の型に変換されます。シフト演算では、最初の引数を二つ目の引数に応じたビット数だけ、左または右にビットシフトします。</p>
<p id="index-59"><em>n</em> ビットの右シフトは <code class="docutils literal"><span class="pre">pow(2,n)</span></code> による除算として定義されています。 <em>n</em> ビットの左シフトは <code class="docutils literal"><span class="pre">pow(2,n)</span></code> による乗算として定義されます。負のビット数でシフトを行うと <a class="reference internal" href="../library/exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 例外を送出します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">現在の実装では、右辺被演算子は最大でも <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal"><span class="pre">sys.maxsize</span></code></a> でなければなりません。右辺被演算子が <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal"><span class="pre">sys.maxsize</span></code></a> よりも大きいと、 <a class="reference internal" href="../library/exceptions.html#exceptions.OverflowError" title="exceptions.OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> 例外が送出されます。</p>
</div>
</div>
<div class="section" id="binary-bitwise-operations">
<span id="bitwise"></span><h2>5.8. ビット単位演算の二項演算 (binary bitwise operation)<a class="headerlink" href="#binary-bitwise-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-60">以下の三つのビット単位演算には、それぞれ異なる優先順位レベルがあります:</p>
<pre>
<strong id="grammar-token-and_expr">and_expr</strong> ::=  <a class="reference internal" href="#grammar-token-shift_expr"><code class="xref docutils literal"><span class="pre">shift_expr</span></code></a> | <a class="reference internal" href="#grammar-token-and_expr"><code class="xref docutils literal"><span class="pre">and_expr</span></code></a> &quot;&amp;&quot; <a class="reference internal" href="#grammar-token-shift_expr"><code class="xref docutils literal"><span class="pre">shift_expr</span></code></a>
<strong id="grammar-token-xor_expr">xor_expr</strong> ::=  <a class="reference internal" href="#grammar-token-and_expr"><code class="xref docutils literal"><span class="pre">and_expr</span></code></a> | <a class="reference internal" href="#grammar-token-xor_expr"><code class="xref docutils literal"><span class="pre">xor_expr</span></code></a> &quot;^&quot; <a class="reference internal" href="#grammar-token-and_expr"><code class="xref docutils literal"><span class="pre">and_expr</span></code></a>
<strong id="grammar-token-or_expr">or_expr </strong> ::=  <a class="reference internal" href="#grammar-token-xor_expr"><code class="xref docutils literal"><span class="pre">xor_expr</span></code></a> | <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal"><span class="pre">or_expr</span></code></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-xor_expr"><code class="xref docutils literal"><span class="pre">xor_expr</span></code></a>
</pre>
<p id="index-61"><code class="docutils literal"><span class="pre">&amp;</span></code> 演算子は、引数間でビット単位の AND をとった値になります。引数は整数または長整数でなければなりません。引数は共通の型に変換されます。</p>
<p id="index-62"><code class="docutils literal"><span class="pre">^</span></code> 演算子は、引数間でビット単位の XOR (排他的 OR) をとった値になります。引数は整数または長整数でなければなりません。引数は共通の型に変換されます。</p>
<p id="index-63"><code class="docutils literal"><span class="pre">|</span></code> 演算子は、引数間でビット単位の OR (非排他的 OR) をとった値になります。引数は整数または長整数でなければなりません。引数は共通の型に変換されます。</p>
</div>
<div class="section" id="comparisons">
<span id="id12"></span><h2>5.9. 比較<a class="headerlink" href="#comparisons" title="このヘッドラインへのパーマリンク">¶</a></h2>
<span class="target" id="index-64"></span><p id="index-65">C 言語と違って、Python における比較演算子は同じ優先順位をもっており、全ての算術演算子、シフト演算子、ビット単位演算子よりも低くなっています。また <code class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">c</span></code> が数学で伝統的に用いられているのと同じ解釈になる点も C 言語と違います:</p>
<pre>
<strong id="grammar-token-comparison">comparison   </strong> ::=  <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal"><span class="pre">or_expr</span></code></a> ( <a class="reference internal" href="#grammar-token-comp_operator"><code class="xref docutils literal"><span class="pre">comp_operator</span></code></a> <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal"><span class="pre">or_expr</span></code></a> )*
<strong id="grammar-token-comp_operator">comp_operator</strong> ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;&lt;&gt;&quot; | &quot;!=&quot;
                   | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;
</pre>
<p>比較演算の結果はブール値: <code class="docutils literal"><span class="pre">True</span></code> または <code class="docutils literal"><span class="pre">False</span></code> になります。</p>
<p id="index-66">比較はいくらでも連鎖することができます。例えば <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> と等価になります。ただしこの場合、前者では <code class="docutils literal"><span class="pre">y</span></code> はただ一度だけ評価される点が異なります (どちらの場合でも、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> が偽になると <code class="docutils literal"><span class="pre">z</span></code> の値はまったく評価されません)。</p>
<p>形式的には、 <em>a</em>, <em>b</em>, <em>c</em>, ..., <em>y</em>, <em>z</em> が式で <em>op1</em>, <em>op2</em>, ..., <em>opN</em> が比較演算子である場合、 <code class="docutils literal"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> は <code class="docutils literal"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">and</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">and</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> と等価になります。ただし、前者では各式は多くても一度しか評価されません。</p>
<p><code class="docutils literal"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span></code> と書いた場合、 <em>a</em> から <em>c</em> までの範囲にあるかどうかのテストを指すのではないことに注意してください。例えば <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> は (きれいな書き方ではありませんが) 完全に正しい文法です。</p>
<p><code class="docutils literal"><span class="pre">&lt;&gt;</span></code> と <code class="docutils literal"><span class="pre">!=</span></code> の二つの形式は等価です; C との整合性を持たせるためには <code class="docutils literal"><span class="pre">!=</span></code> を推奨します; 以下で <code class="docutils literal"><span class="pre">!=</span></code> について触れている部分では <code class="docutils literal"><span class="pre">&lt;&gt;</span></code> を使うこともできます。 <code class="docutils literal"><span class="pre">&lt;&gt;</span></code> のような書き方は、現在では古い書き方とみなされています。</p>
<div class="section" id="value-comparisons">
<h3>5.9.1. 値の比較<a class="headerlink" href="#value-comparisons" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>演算子 <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, および <code class="docutils literal"><span class="pre">!=</span></code> は2つのオブジェクトの値を比較します。オブジェクトが同じ型を持つ必要はりません。</p>
<p><a class="reference internal" href="datamodel.html#objects"><span class="std std-ref">オブジェクト、値、および型</span></a> の章では、オブジェクトは (型や同一性に加えて) 値を持つことを述べています。オブジェクトの値は Python ではやや抽象的な概念です: 例えば、オブジェクトの値にアクセスする正統な方法はありません。また、その全てのデータ属性から構成されるなどの特定の方法で、オブジェクトの値を構築する必要性もありません。比較演算子は、オブジェクトの値とは何かについての特定の概念を実装しています。この比較の実装によって、間接的にオブジェクトの値を定義している考えることもできます。</p>
<p><a class="reference internal" href="datamodel.html#customization"><span class="std std-ref">基本的なカスタマイズ</span></a> で解説されているように、型を使って <a class="reference internal" href="datamodel.html#object.__cmp__" title="object.__cmp__"><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code></a> メソッドや <em class="dfn">rich comparison methods</em> である <a class="reference internal" href="datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a> などのメソッドを実装することで、 比較の振る舞いをカスタマイズできます。</p>
<p>等価性比較 (<code class="docutils literal"><span class="pre">==</span></code> および <code class="docutils literal"><span class="pre">!=</span></code>) のデフォルトの振る舞いは、オブジェクトの同一性に基づいています。従って、同一のインスタンスの等価性比較は等価となり、同一でないインスタンスの等価性比較は等価でないとなります。デフォルトの振る舞いをこのようにしたのは、全てのオブジェクトを反射的 (reflexive つまり <code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> ならば <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>) なものにしたかったからです。</p>
<p>デフォルトの順序比較 (<code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code>) は一貫性はありますがいい加減な順序です。</p>
<p>(このような比較演算の変則的な定義は、ソートのような操作や <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> および <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a> といった演算子の定義を単純化するためのものです。将来、異なる型のオブジェクト間における比較規則は変更されるかもしれません。)</p>
<p>同一でないインスタンスは常に等価でないとする等価性比較のデフォルトの振る舞いは、型が必要とするオブジェクトの値や値に基づいた等価性の実用的な定義とは対照的に思えるでしょう。そのような型では比較の振る舞いをカスタマイズする必要が出てきて、実際にたくさんの組み込み型でそれが行われています。</p>
<p>次のリストでは、最重要の組み込み型の比較の振る舞いを解説しています。</p>
<ul>
<li><p class="first">いくつかの組み込みの数値型 (<a class="reference internal" href="../library/stdtypes.html#typesnumeric"><span class="std std-ref">数値型 int, float, long, complex</span></a>) と標準ライブラリの型 <a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">fractions.Fraction</span></code></a> および <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code></a> は、同じ型や別の型どうしで比較できますが、複素数では順序比較がサポートされていないという制限があります。関わる型の制限の範囲内では、精度のロス無しに数学的に (アルゴリズム的に) 正しい比較が行われます。</p>
</li>
<li><p class="first">文字列 (<a class="reference internal" href="../library/functions.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> もしくは <a class="reference internal" href="../library/functions.html#unicode" title="unicode"><code class="xref py py-class docutils literal"><span class="pre">unicode</span></code></a> のインスタンス) では、数値的な同等性 (組み込み関数 <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a> の結果) を使い、辞書式の比較を行います。 <a class="footnote-reference" href="#id22" id="id13">[4]</a>
8 bit 文字列と Unicode 文字列を比較するときは、8 bit 文字列は Unicode へ変換されます。変換が失敗した場合は、その文字列は等価でないと見なされます。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> や <a class="reference internal" href="../library/functions.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> のインスタンスは同じ型どうしでしか比較できません。異なる型どうしでの等価性比較は等価でないとなり、異なる型どうしでの順序比較はいい加減な順序になります。</p>
<p>これらのシーケンスでは、要素の反射性があるものとして、個々の対応する要素の比較を使って辞書式の比較が行われます。</p>
<p>要素の反射性があるものとされると、コレクションの比較では、コレクションの要素 <code class="docutils literal"><span class="pre">x</span></code> に対して <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></code> が常に真だと仮定します。この仮定に基づいて、最初に要素の同一性が比較され、同一でない要素どうしに対してのみ要素の比較が行われます。この手法は、比較される要素が反射的な場合、厳密な要素比較と同じ結果をもたらします。反射的でない要素では、厳密な要素比較と異なる結果になります。</p>
<p>組み込みのコレクションどうしの辞書式比較は次のように動作します:</p>
<ul class="simple">
<li><p class="first">比較の結果が等価となる2つのコレクションは、同じ型、同じ長さ、対応する要素どうしの比較の結果が等価でなければなりません (例えば、 <code class="docutils literal"><span class="pre">[1,2]</span> <span class="pre">==</span> <span class="pre">(1,2)</span></code> は型が同じでないので偽です)。</p>
</li>
<li><p class="first">コレクションの順序は、最初の等価でない要素の順序と同じになります (例えば、 <code class="docutils literal"><span class="pre">cmp([1,2,x],</span> <span class="pre">[1,2,y])</span></code> は <code class="docutils literal"><span class="pre">cmp(x,y)</span></code> と同じ返り値になります)。対応する要素が存在しない場合、短い方のコレクションが順序として先となります (例えば、 <code class="docutils literal"><span class="pre">[1,2]</span> <span class="pre">&lt;</span> <span class="pre">[1,2,3]</span></code> は真です)。</p>
</li>
</ul>
</li>
<li><p class="first">マッピング (<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> のインスタンス) の比較の結果が等価となるのは、同じ <cite>(key, value)</cite> を持っているときかつそのときに限ります。キーと値の等価性比較では反射性が強制されます。</p>
<p>等価性評価以外の結果は一貫したやりかたで解決されるか、定義されないかのいずれかです。 <a class="footnote-reference" href="#id23" id="id14">[5]</a></p>
</li>
<li><p class="first">その他のほとんどの組み込み型のオブジェクト比較では、同じオブジェクトでないかぎり等価にはなりません; あるオブジェクトの他のオブジェクトに対する大小関係は任意に決定され、一つのプログラムの実行中は一貫したものとなります。</p>
</li>
</ul>
<p>比較の振る舞いをカスタマイズしたユーザ定義クラスは、可能なら次の一貫性の規則に従う必要があります:</p>
<ul>
<li><p class="first">等価比較は反射的でなければなりません。つまり、同一のオブジェクトは等しくなければなりません:</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> は暗黙的に <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code></p>
</div></blockquote>
</li>
<li><p class="first">比較は対称でなければなりません。つまり、以下の式の結果は同じでなければなりません:</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">y</span> <span class="pre">!=</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x</span></code></p>
</div></blockquote>
</li>
<li><p class="first">比較は推移的でなければなりません。以下の (包括的でない) 例がその説明です:</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> は暗黙的に <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">z</span></code></p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> は暗黙的に <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">z</span></code></p>
</div></blockquote>
</li>
<li><p class="first">比較の逆はブールの否定でなければなりません。つまり、以下の式の結果は同じでなければなりません:</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code></p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code> (全順序の場合)</p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> (全順序の場合)</p>
</div></blockquote>
<p>最後の2式は全順序の集まりに適用されます (たとえばシーケンスには適用されますがセットやマッピングには適用されません)。
<a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal"><span class="pre">total_ordering()</span></code></a> デコレータも参照してください。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a> の結果は等価性と一貫している必要があります。等価なオブジェクトどうしは同じハッシュ値を持つか、ハッシュ値が計算できないものとされる必要があります。</p>
</li>
</ul>
<p>Python はこれらの一貫性の規則を強制しません。</p>
</div>
<div class="section" id="membership-test-operations">
<span id="membership-test-details"></span><span id="not-in"></span><span id="in"></span><h3>5.9.2. 帰属検査演算<a class="headerlink" href="#membership-test-operations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>演算子 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> および <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a> は所属関係を調べます。 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> の評価は、 <em>x</em> が <em>s</em> の要素であれば <code class="docutils literal"><span class="pre">True</span></code> となり、そうでなければ <code class="docutils literal"><span class="pre">False</span></code> となります。 <code class="docutils literal"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> の否定を返します。すべての組み込みのシーケンスと集合型に加えて、辞書も、 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> を辞書が与えられたキーを持っているかを調べるものとしてサポートしています。リスト、タプル、集合、凍結集合、辞書、あるいは collections.deque のようなコンテナ型について、式 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <code class="docutils literal"><span class="pre">any(x</span> <span class="pre">is</span> <span class="pre">e</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">e</span> <span class="pre">for</span> <span class="pre">e</span> <span class="pre">in</span> <span class="pre">y)</span></code> と等価です。</p>
<p>文字列やバイト列型については、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <em>x</em> が <em>y</em> の部分文字列であるとき、かつそのときに限り <code class="docutils literal"><span class="pre">True</span></code> になります。これは <code class="docutils literal"><span class="pre">y.find(x)</span> <span class="pre">!=</span> <span class="pre">-1</span></code> と等価です。空文字列は、他の任意の文字列の部分文字列とみなされます。従って <code class="docutils literal"><span class="pre">&quot;&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></code> は <code class="docutils literal"><span class="pre">True</span></code> を返すことになります。</p>
<p><a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a> メソッドを実装したユーザ定義クラスでは、 <code class="docutils literal"><span class="pre">y.__contains__(x)</span></code> の返り値が真となる場合に <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> の返り値は <code class="docutils literal"><span class="pre">True</span></code> となり、そうでない場合は <code class="docutils literal"><span class="pre">False</span></code> となります。</p>
<p><a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a> を定義していないが <a class="reference internal" href="datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> は定義しているユーザ定義クラスでは、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">z</span></code> となるようなある値 <code class="docutils literal"><span class="pre">z</span></code> が <code class="docutils literal"><span class="pre">y</span></code> 内にわたる反復で生成された場合、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <code class="docutils literal"><span class="pre">True</span></code> となります。反復処理の途中で例外が送出された場合、 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> が例外を発生させたように振る舞います。</p>
<p>最終的には、旧式の反復プロトコルの実行を試みます、もし <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> を定義しているようなユーザ定義クラスでは、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y[i]</span></code> となるような非負の整数インデクス <em>i</em> が存在するとき、かつそのときにかぎり <code class="docutils literal"><span class="pre">True</span></code> となります。インデクス <em>i</em> が負である場合に <a class="reference internal" href="../library/exceptions.html#exceptions.IndexError" title="exceptions.IndexError"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code></a> 例外が送出されることはありません。 (別の何らかの例外が送出された場合、例外は <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> から送出されたかのようになります)。</p>
<p id="index-67">演算子 <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a> は <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> の真値を反転した値として定義されています。</p>
</div>
<div class="section" id="is-not">
<span id="is"></span><span id="index-68"></span><span id="identity-comparisons"></span><h3>5.9.3. 同一性の比較<a class="headerlink" href="#is-not" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>演算子 <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a> および <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></a> は、オブジェクトのアイデンティティに対するテストを行います: <code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> は、 <em>x</em> と <em>y</em> が同じオブジェクトを指すとき、かつそのときに限り真になります。 <code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">y</span></code> は <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a> の真値を反転したものになります。 <a class="footnote-reference" href="#id24" id="id15">[6]</a></p>
</div>
</div>
<div class="section" id="boolean-operations">
<span id="not"></span><span id="or"></span><span id="and"></span><span id="booleans"></span><h2>5.10. ブール演算 (boolean operation)<a class="headerlink" href="#boolean-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-69">
<strong id="grammar-token-or_test">or_test </strong> ::=  <a class="reference internal" href="#grammar-token-and_test"><code class="xref docutils literal"><span class="pre">and_test</span></code></a> | <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> &quot;or&quot; <a class="reference internal" href="#grammar-token-and_test"><code class="xref docutils literal"><span class="pre">and_test</span></code></a>
<strong id="grammar-token-and_test">and_test</strong> ::=  <a class="reference internal" href="#grammar-token-not_test"><code class="xref docutils literal"><span class="pre">not_test</span></code></a> | <a class="reference internal" href="#grammar-token-and_test"><code class="xref docutils literal"><span class="pre">and_test</span></code></a> &quot;and&quot; <a class="reference internal" href="#grammar-token-not_test"><code class="xref docutils literal"><span class="pre">not_test</span></code></a>
<strong id="grammar-token-not_test">not_test</strong> ::=  <a class="reference internal" href="#grammar-token-comparison"><code class="xref docutils literal"><span class="pre">comparison</span></code></a> | &quot;not&quot; <a class="reference internal" href="#grammar-token-not_test"><code class="xref docutils literal"><span class="pre">not_test</span></code></a>
</pre>
<p>ブール演算のコンテキストや、式が制御フロー文中で使われる最には、以下の値: <code class="docutils literal"><span class="pre">False</span></code> 、 <code class="docutils literal"><span class="pre">None</span></code> 、すべての型における数値のゼロ、空の文字列とコンテナ (文字列、タプル、リスト、辞書、set、frozenset を含む) は偽 (false) であると解釈されます。それ以外の値は真 (true) であると解釈されます。 (この振る舞いを変更する方法については特殊メソッド <a class="reference internal" href="datamodel.html#object.__nonzero__" title="object.__nonzero__"><code class="xref py py-meth docutils literal"><span class="pre">__nonzero__()</span></code></a> を参照してください)</p>
<p id="index-70">演算子 <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a> は、引数が偽である場合には <code class="docutils literal"><span class="pre">True</span></code> を、それ以外の場合には <code class="docutils literal"><span class="pre">False</span></code> になります。</p>
<p id="index-71">式 <code class="docutils literal"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code> は、まず <em>x</em> を評価します; <em>x</em> が偽なら <em>x</em> の値を返します; それ以外の場合には、 <em>y</em> の値を評価し、その結果を返します。</p>
<p id="index-72">式 <code class="docutils literal"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code> は、まず <em>x</em> を評価します; <em>x</em> が真なら <em>x</em> の値を返します; それ以外の場合には、 <em>y</em> の値を評価し、その結果を返します。</p>
<p>(<a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal"><span class="pre">and</span></code></a> も <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a> も、返す値を <code class="docutils literal"><span class="pre">False</span></code> や <code class="docutils literal"><span class="pre">True</span></code> に制限するのではなく、最後に評価した引数の値を返すので注意してください。この仕様は、例えば <code class="docutils literal"><span class="pre">s</span></code> を文字列として <code class="docutils literal"><span class="pre">s</span></code> が空文字列の場合にデフォルトの値に置き換えるような場合に、 <code class="docutils literal"><span class="pre">s</span> <span class="pre">or</span> <span class="pre">'foo'</span></code> と書くと期待通りの値になるために便利なことがあります。 <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a> は、式の値でなく独自に値を作成して返すので、引数と同じ型の値を返すような処理に煩わされることはありません。例えば、 <code class="docutils literal"><span class="pre">not</span> <span class="pre">'foo'</span></code> は、 <code class="docutils literal"><span class="pre">''</span></code> ではなく <code class="docutils literal"><span class="pre">False</span></code> になります)</p>
</div>
<div class="section" id="conditional-expressions">
<h2>5.11. 条件演算 (Conditional Expressions)<a class="headerlink" href="#conditional-expressions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 2.5 で追加.</span></p>
</div>
<pre id="index-73">
<strong id="grammar-token-conditional_expression">conditional_expression</strong> ::=  <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> [&quot;if&quot; <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-expression">expression            </strong> ::=  <a class="reference internal" href="#grammar-token-conditional_expression"><code class="xref docutils literal"><span class="pre">conditional_expression</span></code></a> | <a class="reference internal" href="#grammar-token-lambda_expr"><code class="xref docutils literal"><span class="pre">lambda_expr</span></code></a>
</pre>
<p>条件演算式 (しばしば、&#8221;三項演算子&#8221; と呼ばれます) は最も優先度が低いPython の操作です。</p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">if</span> <span class="pre">C</span> <span class="pre">else</span> <span class="pre">y</span></code> という式は最初に条件 <em>C</em> (<em>x</em> では <em>ありません</em>) を評価します; <em>C</em> が true の場合 <em>x</em> が評価され値が返されます; それ以外の場合には <em>y</em> が評価され返されます。</p>
<p>条件演算に関してより詳しくは <span class="target" id="index-84"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0308"><strong>PEP 308</strong></a> を参照してください。</p>
</div>
<div class="section" id="lambda">
<span id="lambdas"></span><span id="id16"></span><h2>5.12. ラムダ (lambda)<a class="headerlink" href="#lambda" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-75">
<strong id="grammar-token-lambda_expr">lambda_expr    </strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-parameter_list"><code class="xref docutils literal"><span class="pre">parameter_list</span></code></a>]: <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-old_lambda_expr">old_lambda_expr</strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-parameter_list"><code class="xref docutils literal"><span class="pre">parameter_list</span></code></a>]: <a class="reference internal" href="#grammar-token-old_expression"><code class="xref docutils literal"><span class="pre">old_expression</span></code></a>
</pre>
<p>ラムダ式 (lambda expression または lambda forms) は構文的には式と同じ位置づけになります。ラムダは無名関数を作成できる省略記法です; 式 <code class="docutils literal"><span class="pre">lambda</span> <span class="pre">arguments:</span> <span class="pre">expression</span></code> は関数オブジェクトになります。ラムダで表される無名オブジェクトは以下の関数オブジェクト同様に動作します。:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="n">arguments</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">expression</span>
</pre></div>
</div>
<p>パラメータの構文の一覧は <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> を参照してください。ラムダ式で作成された関数は命令文を含むことができない点に注意してください。</p>
</div>
<div class="section" id="expression-lists">
<span id="exprlists"></span><h2>5.13. 式のリスト<a class="headerlink" href="#expression-lists" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-76">
<strong id="grammar-token-expression_list">expression_list</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> ( &quot;,&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> )* [&quot;,&quot;]
</pre>
<p id="index-77">少なくとも一つのカンマを含む式のリストは、タプルになります。タプルの長さは、リスト中の式の数に等しくなります。リスト中の式は左から右へと順に評価されます。</p>
<p id="index-78">単一要素のタプル (別名 <em>単集合 (singleton)</em> ) を作りたければ、末尾にカンマが必要です。単一の式だけで、末尾にカンマをつけない場合には、タプルではなくその式の値になります (空のタプルを作りたいなら、中身が空の丸括弧ペア: <code class="docutils literal"><span class="pre">()</span></code> を使います。)</p>
</div>
<div class="section" id="evaluation-order">
<span id="evalorder"></span><h2>5.14. 評価順序<a class="headerlink" href="#evaluation-order" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-79">Python は、式を左から右へと順に評価してゆきます。ただし、代入式を評価する最には、代入演算子の右側項が左側項よりも先に評価されるので注意してください。</p>
<p>以下に示す実行文の各行での評価順序は、添え字の数字順序と同じになります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span>
<span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span><span class="p">)</span>
<span class="p">{</span><span class="n">expr1</span><span class="p">:</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">:</span> <span class="n">expr4</span><span class="p">}</span>
<span class="n">expr1</span> <span class="o">+</span> <span class="n">expr2</span> <span class="o">*</span> <span class="p">(</span><span class="n">expr3</span> <span class="o">-</span> <span class="n">expr4</span><span class="p">)</span>
<span class="n">expr1</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="o">*</span><span class="n">expr4</span><span class="p">,</span> <span class="o">**</span><span class="n">expr5</span><span class="p">)</span>
<span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span> <span class="o">=</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span>
</pre></div>
</div>
</div>
<div class="section" id="operator-precedence">
<span id="operator-summary"></span><h2>5.15. 演算子の優先順位<a class="headerlink" href="#operator-precedence" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-80">以下の表は、Python における演算子を、優先順位の最も低い (結合度が最も低い) ものから最も高い (結合度が最も高い) ものの順に並べたものです。同じボックス内に示された演算子は同じ優先順位を持ちます。演算子の文法が示されていないかぎり、演算子は全て二項演算子です。同じボックス内の演算子は、左から右へとグループ化されます (値のテストを含む比較演算子を除きます。比較演算子は、左から右に連鎖します &#8212; <a class="reference internal" href="#comparisons"><span class="std std-ref">比較</span></a> を参照してください。また、べき乗演算子も除きます。べき乗演算子は右から左にグループ化されます)。</p>
<table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">演算子</p>
</th>
<th class="head"><p class="first last">説明</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a></td>
<td><p class="first last">ラムダ式</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> &#8211; <a class="reference internal" href="compound_stmts.html#else"><code class="xref std std-keyword docutils literal"><span class="pre">else</span></code></a></td>
<td><p class="first last">条件演算</p>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal"><span class="pre">or</span></code></a></td>
<td><p class="first last">ブール演算 OR</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal"><span class="pre">and</span></code></a></td>
<td><p class="first last">ブール演算 AND</p>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a> <code class="docutils literal"><span class="pre">x</span></code></td>
<td><p class="first last">ブール演算 NOT</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a>, <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a>,
<a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a>, <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></a>, <code class="docutils literal"><span class="pre">&lt;</span></code>,
<code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code>, <code class="docutils literal"><span class="pre">&lt;&gt;</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>, <code class="docutils literal"><span class="pre">==</span></code></td>
<td><p class="first last">帰属や同一性のテストを含む比較</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">|</span></code></td>
<td><p class="first last">ビット単位 OR</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">^</span></code></td>
<td><p class="first last">ビット単位 XOR</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&amp;</span></code></td>
<td><p class="first last">ビット単位 AND</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;&gt;</span></code></td>
<td><p class="first last">シフト演算</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code></td>
<td><p class="first last">加算および減算</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">//</span></code>, <code class="docutils literal"><span class="pre">%</span></code></td>
<td><p class="first last">乗算、除算、剰余 <a class="footnote-reference" href="#id25" id="id17">[7]</a></p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">+x</span></code>, <code class="docutils literal"><span class="pre">-x</span></code>, <code class="docutils literal"><span class="pre">~x</span></code></td>
<td><p class="first last">正符号、負符号、ビット単位 NOT</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">**</span></code></td>
<td><p class="first last">べき乗 <a class="footnote-reference" href="#id26" id="id18">[8]</a></p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x[index]</span></code>, <code class="docutils literal"><span class="pre">x[index:index]</span></code>,
<code class="docutils literal"><span class="pre">x(arguments...)</span></code>, <code class="docutils literal"><span class="pre">x.attribute</span></code></td>
<td><p class="first last">添字指定、スライス操作属性参照</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">(expressions...)</span></code>,
<code class="docutils literal"><span class="pre">[expressions...]</span></code>,
<code class="docutils literal"><span class="pre">{key:</span> <span class="pre">value...}</span></code>,
<code class="docutils literal"><span class="pre">`expressions...`</span></code></td>
<td><p class="first last">式結合またはタプル表現、リスト表現、辞書表現、文字列への型変換</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">注記</p>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td><p class="first last">Python 2.3 以降のリスト内包は <code class="docutils literal"><span class="pre">for</span></code> の中で使う制御変数を内包表記内のスコープに「リーク」します。しかし、この挙動は廃止予定です。Python 3 ではこの挙動に依存したコードは動作しなくなります。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[2]</a></td><td><p class="first last"><code class="docutils literal"><span class="pre">abs(x%y)</span> <span class="pre">&lt;</span> <span class="pre">abs(y)</span></code> は数学的には真となりますが、浮動小数点に対する演算の場合には、値丸め (roundoff) のために数値計算的に真にならない場合があります。例えば、Python の浮動小数点型が IEEE754 倍精度数型になっているプラットフォームを仮定すると、 <code class="docutils literal"><span class="pre">-1e-100</span> <span class="pre">%</span> <span class="pre">1e100</span></code> は <code class="docutils literal"><span class="pre">1e100</span></code> と同じ符号になるはずなのに、計算結果は <code class="docutils literal"><span class="pre">-1e-100</span> <span class="pre">+</span> <span class="pre">1e100</span></code> となります。これは数値計算的には厳密に <code class="docutils literal"><span class="pre">1e100</span></code> と等価です。関数 <a class="reference internal" href="../library/math.html#math.fmod" title="math.fmod"><code class="xref py py-func docutils literal"><span class="pre">math.fmod()</span></code></a> は、最初の引数と符号が一致するような値を返すので、上記の場合には <code class="docutils literal"><span class="pre">-1e-100</span></code> を返します。どちらのアプローチが適切かは、アプリケーションに依存します。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[3]</a></td><td><p class="first last">x が y の整数倍に非常に近い場合、丸め誤差によって <code class="docutils literal"><span class="pre">floor(x/y)</span></code> は <code class="docutils literal"><span class="pre">(x-x%y)/y</span></code> よりも大きな値になる可能性があります。そのような場合、 Python は <code class="docutils literal"><span class="pre">divmod(x,y)[0]</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> が <code class="docutils literal"><span class="pre">x</span></code> に非常に近くなるという関係を保つために、後者の値を返します。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[4]</a></td><td><p class="first">Unicode 標準では、 <em class="dfn">コードポイント (code point)</em> (例えば、U+0041) と <em class="dfn">抽象文字 (abstract character)</em> (例えば、&#8221;LATIN CAPITAL LETTER A&#8221;) を区別します。
Unicode のほとんどの抽象文字は 1 つのコードポイントだけを使って表現されますが、複数のコードポイントの列を使っても表現できる抽象文字もたくさんあります。例えば、抽象文字 &#8220;LATIN CAPITAL LETTER C WITH CEDILLA&#8221; はコード位置 U+00C7 にある <em class="dfn">合成済み文字 (precomposed character)</em> 1 つだけでも表現できますし、コード位置 U+0043 (LATIN CAPITAL LETTER C) にある <em class="dfn">基底文字 (base character)</em> の後ろに、コード位置 U+0327 (COMBINING CEDILLA) にある <em class="dfn">結合文字 (combining character)</em> が続く列としても表現できます。</p>
<p>Unicode 文字列の比較操作は Unicode のコードポイントのレベルで行われます。これは人間にとっては直感的ではないかもしれません。例えば、 <code class="docutils literal"><span class="pre">u&quot;\u00C7&quot;</span> <span class="pre">==</span> <span class="pre">u&quot;\u0043\u0327&quot;</span></code> は、どちらの文字も同じ抽象文字 &#8220;LATIN CAPITAL LETTER C WITH CEDILLA&#8221; を表現しているにもかかわらず、その結果は <code class="docutils literal"><span class="pre">False</span></code> となります。</p>
<p class="last">抽象文字のレベルで (つまり、人間にとって直感的な方法で) 文字列を比較するには <a class="reference internal" href="../library/unicodedata.html#unicodedata.normalize" title="unicodedata.normalize"><code class="xref py py-func docutils literal"><span class="pre">unicodedata.normalize()</span></code></a> を使ってください。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[5]</a></td><td><p class="first last">Python の初期のバージョンでは、ソートされた (key, value) のリストに対して辞書的な比較を行っていましたが、これは等価性の計算のようなよくある操作を実現するには非常にコストの高い操作でした。もっと以前のバージョンの Python では、辞書はアイデンティティだけで比較されていました。しかしこの仕様は、 <code class="docutils literal"><span class="pre">{}</span></code> との比較によって辞書が空であるか確かめられると期待していた人々を混乱させていました。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[6]</a></td><td><p class="first last">自動的なガベージコレクション、フリーリスト、ディスクリプタの動的特性のために、インスタンスメソッドや定数の比較を行うようなときに <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a> 演算子の利用は、一見すると普通ではない振る舞いだと気付くかもしれません。詳細はそれぞれのドキュメントを確認してください。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[7]</a></td><td><p class="first last"><code class="docutils literal"><span class="pre">%</span></code> 演算子は文字列フォーマットにも使われ、同じ優先順位が当てはまります。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[8]</a></td><td><p class="first last">べき乗演算子 <code class="docutils literal"><span class="pre">**</span></code> はその右側にある単項演算子かビット単位演算子よりも優先して束縛されます。つまり <code class="docutils literal"><span class="pre">2**-1</span></code> は <code class="docutils literal"><span class="pre">0.5</span></code> になります。</p>
</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. 式 (expression)</a><ul>
<li><a class="reference internal" href="#arithmetic-conversions">5.1. 算術変換 (arithmetic conversion)</a></li>
<li><a class="reference internal" href="#atoms">5.2. アトム、原子的要素 (atom)</a><ul>
<li><a class="reference internal" href="#atom-identifiers">5.2.1. 識別子 (identifier、または名前 (name))</a></li>
<li><a class="reference internal" href="#literals">5.2.2. リテラル</a></li>
<li><a class="reference internal" href="#parenthesized-forms">5.2.3. 丸括弧形式 (parenthesized form)</a></li>
<li><a class="reference internal" href="#list-displays">5.2.4. リスト表現</a></li>
<li><a class="reference internal" href="#displays-for-sets-and-dictionaries">5.2.5. 集合と辞書の表現</a></li>
<li><a class="reference internal" href="#generator-expressions">5.2.6. ジェネレータ式</a></li>
<li><a class="reference internal" href="#dictionary-displays">5.2.7. 辞書表現</a></li>
<li><a class="reference internal" href="#set-displays">5.2.8. 集合表現</a></li>
<li><a class="reference internal" href="#string-conversions">5.2.9. 文字列変換</a></li>
<li><a class="reference internal" href="#yield-expressions">5.2.10. Yield 式</a><ul>
<li><a class="reference internal" href="#generator-iterator-methods">5.2.10.1. ジェネレータ-イテレータメソッド</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#primaries">5.3. プライマリ</a><ul>
<li><a class="reference internal" href="#attribute-references">5.3.1. 属性参照</a></li>
<li><a class="reference internal" href="#subscriptions">5.3.2. 添字表記 (subscription)</a></li>
<li><a class="reference internal" href="#slicings">5.3.3. スライス表記 (slicing)</a></li>
<li><a class="reference internal" href="#calls">5.3.4. 呼び出し (call)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-power-operator">5.4. べき乗演算 (power operator)</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operations">5.5. 単項算術演算とビット単位演算(unary arithmetic and bitwise operation)</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operations">5.6. 二項算術演算 (binary arithmetic operation)</a></li>
<li><a class="reference internal" href="#shifting-operations">5.7. シフト演算 (shifting operation)</a></li>
<li><a class="reference internal" href="#binary-bitwise-operations">5.8. ビット単位演算の二項演算 (binary bitwise operation)</a></li>
<li><a class="reference internal" href="#comparisons">5.9. 比較</a><ul>
<li><a class="reference internal" href="#value-comparisons">5.9.1. 値の比較</a></li>
<li><a class="reference internal" href="#membership-test-operations">5.9.2. 帰属検査演算</a></li>
<li><a class="reference internal" href="#is-not">5.9.3. 同一性の比較</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-operations">5.10. ブール演算 (boolean operation)</a></li>
<li><a class="reference internal" href="#conditional-expressions">5.11. 条件演算 (Conditional Expressions)</a></li>
<li><a class="reference internal" href="#lambda">5.12. ラムダ (lambda)</a></li>
<li><a class="reference internal" href="#expression-lists">5.13. 式のリスト</a></li>
<li><a class="reference internal" href="#evaluation-order">5.14. 評価順序</a></li>
<li><a class="reference internal" href="#operator-precedence">5.15. 演算子の優先順位</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="前の章へ">4. 実行モデル</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="simple_stmts.html"
                        title="次の章へ">6. 単純文 (simple statement)</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">バグ報告</a></li>
  <li><a href="https://github.com/python/cpython/blob/2.7/Doc/reference/expressions.rst"
         rel="nofollow">ソースの表示</a>
  </li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="6. 単純文 (simple statement)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 実行モデル"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.jp/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.13</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 言語リファレンス</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト).
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 2017-06-20
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>